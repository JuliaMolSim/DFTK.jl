# # Gross-Pitaevskii equation in one dimension with forces and custom potential

# We solve the 1D Gross-Pitaevskii equation with a custom potential.
# This is similar to the
# previous example ([Gross-Pitaevskii equation in one dimension](@ref)) where
# computing forces was not possible as we used an `ExternalFromReal` term
# instead of an `AtomicLocal` term (see [`Model` datastructure](@ref)).
# Here, we use `ElementCustomIonPotential`
# with a custom potential to generate an `AtomicLocal` term for which we can
# compute forces.
using DFTK
using LinearAlgebra

# ## The model
# First we set up the lattice. For a 1D case we supply two zero lattice vectors,
a = 10
lattice = a .* [[1 0 0.]; [0 0 0]; [0 0 0]];

# In this example, we want to generate two Gaussian potentials generated by ions
# localized at positions ``x_1`` and ``x_2``, that are expressed in ``[0,1)`` in
# fractional coordinates. ``|x_1 - x_2|`` should be different from ``0.5`` to
# break symmetry and get nonzero forces.
x1 = 0.2
x2 = 0.8;
# We define the width of the Gaussian potential generated by one ion
L = 0.5;
# We set the potential in its real and Fourier forms
pot_real(x) = exp(-(x/L)^2)
pot_fourier(q::T) where {T <: Real} = exp(- (q*L)^2 / 4);
# And finally we build the elements and set their positions in the `atoms` array
ion = ElementCustomIonPotential(1, pot_real, pot_fourier) # 1 is the charge of each ion
atoms = [ion => [x1*[1,0,0], x2*[1,0,0]]];

# Parameters for the nonlinear potential ``α C ρ^{α-1}``
C = 1.0
α = 2;

# Setup the energy terms and the model
n_electrons = 1  # Increase this for fun
terms = [Kinetic(),
         AtomicLocal(),
         PowerNonlinearity(C, α),
]
model = Model(lattice; atoms=atoms, n_electrons=n_electrons, terms=terms,
              spin_polarization=:spinless);  # use "spinless electrons"

# We discretize using a moderate Ecut
# and run a SCF algorithm to compute forces afterwards:
Ecut = 500
basis = PlaneWaveBasis(model, Ecut)
scfres = self_consistent_field(basis, tol=1e-8)
scfres.energies
# Computing forces is then automatic:
hcat(forces(scfres)...)

# ## Internals
# We run the same checks than in [Gross-Pitaevskii equation in one dimension](@ref).
#
# Extract the converged total local potential:
tot_local_pot = DFTK.total_local_potential(scfres.ham)[:,:,1][:];

# Extract the converged density and the obtained wave function:
ρ = real(scfres.ρ.real)[:, 1, 1]  # converged density
ψ_fourier = scfres.ψ[1][:, 1];    # first kpoint, all G components, first eigenvector

# Transform the wave function to real space and fix the phase:
ψ = G_to_r(basis, basis.kpoints[1], ψ_fourier)[:, 1, 1]
ψ /= (ψ[div(end, 2)] / abs(ψ[div(end, 2)]));

# Check whether ``ψ`` is normalised:
x = a * vec(first.(DFTK.r_vectors(basis)))
N = length(x)
dx = a / N  # real-space grid spacing
@assert sum(abs2.(ψ)) * dx ≈ 1.0

# The density is simply built from ψ:
norm(scfres.ρ.real - abs2.(ψ))

# We summarize the ground state in a nice plot, where we also show the total
# local potential and see that the density shape is consistent with it:
using Plots

p = plot(x, real.(ψ), label="real(ψ)")
plot!(p, x, imag.(ψ), label="imag(ψ)")
plot!(p, x, ρ, label="ρ")
plot!(p, x, tot_local_pot, label="tot local pot")

# The `energy_hamiltonian` function can be used to get the energy and
# effective Hamiltonian (derivative of the energy with respect to the density matrix)
# of a particular state (ψ, occupation).
# The density ρ associated to this state is precomputed
# and passed to the routine as an optimization.
E, ham = energy_hamiltonian(basis, scfres.ψ, scfres.occupation; ρ=scfres.ρ)
@assert sum(values(E)) == sum(values(scfres.energies))

# Now the Hamiltonian contains all the blocks corresponding to kpoints. Here, we just have one kpoint:
H = ham.blocks[1];

# `H` can be used as a linear operator (efficiently using FFTs), or converted to a dense matrix:
ψ11 = scfres.ψ[1][:, 1] # first kpoint, first eigenvector
Hmat = Array(H) # This is now just a plain Julia matrix,
##                which we can compute and store in this simple 1D example
@assert norm(Hmat * ψ11 - H * ψ11) < 1e-10

# Let's check that ψ11 is indeed an eigenstate:
norm(H * ψ11 - dot(ψ11, H * ψ11) * ψ11)

# Build a finite-differences version of the GPE operator ``H``, as a sanity check:
A = Array(Tridiagonal(-ones(N - 1), 2ones(N), -ones(N - 1)))
A[1, end] = A[end, 1] = -1
K = A / dx^2 / 2
V = Diagonal(tot_local_pot + C .* α .* (ρ.^(α-1)))
H_findiff = K + V;
maximum(abs.(H_findiff*ψ - (dot(ψ, H_findiff*ψ) / dot(ψ, ψ)) * ψ))
