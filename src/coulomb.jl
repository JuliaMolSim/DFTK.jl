@doc raw"""
Abstract type for different interaction models

Available models:
- [`Coulomb`](@ref): 1/r
- [`ErfShortRangeCoulomb`](@ref): erfc(ωr)/r
- [`ErfLongRangeCoulomb`](@ref): erf(ωr)/r
- [`SphericallyTruncatedCoulomb`](@ref): θ(R-r)/r

See also: [`compute_fourier_kernel`](@ref)
"""
abstract type InteractionKernel end


@doc raw"""
Compute Coulomb kernel, i.e. essentially ``v(G+q) = 4π/|G+q|²``, on spherical plane-wave grid.

Returns the Fourier-space Coulomb interaction for momentum transfer `q`,
evaluated only on the spherical cutoff |G+q|² < 2Ecut (not the full cubic FFT grid).

!!! note "Gamma-point only"
    Currently only works for single k-point calculations (Gamma-only).
    For general k-points, a q-dependent basis would be needed.

## Arguments
- `basis::PlaneWaveBasis`: Plane-wave basis defining the grid
- `q`: Momentum transfer vector in fractional coordinates
- `interaction_kernel::InteractionKernel`: Method for treating singularity

## Returns
Vector of Coulomb kernel values for each G-vector in the spherical cutoff.
"""
function compute_fourier_kernel(basis::PlaneWaveBasis{T}; q=zero(Vec3{T}),
                                interaction_kernel::InteractionKernel=Coulomb()) where {T}
    is_gamma_only = all(iszero(kpt.coordinate) for kpt in basis.kpoints)
    if !is_gamma_only
        throw(ArgumentError("Currently only Gamma-point calculations are supported in " *
                            "compute_fourier_kernel, respectively Hartree-Fock and " *
                            "calculations involving exact exchange."))
    end
    if mpi_nprocs(basis.comm_kpts) > 1
        error("MPI parallelisation not yet supported for coulomb kernel")
    end
    @assert iszero(q)

    # currently only works for Gamma-only (need correct q-point otherwise)
    qpt = basis.kpoints[1] 
    fourier_kernel =  _compute_kernel(basis, qpt, q, interaction_kernel)

    # TODO: if q=0, symmetrize Fourier coeffs to have real iFFT 

    fourier_kernel = to_device(basis.architecture, fourier_kernel)
end


@doc raw"""
Abstract type for different strategies to regularize the
diverging G+q=0 fourier component of interaction models.

Available models:
- [`ProbeCharge`](@ref): Gygi-Baldereschi probe charge method
- [`ReplaceSingularity`](@ref): Set G+q=0 component to given value (default is zero)

See also: [`InteractionKernel`](@ref)
"""
abstract type KernelRegularization end


"""
Probe charge Ewald method for treating the Coulomb singularity.

Regularize the G+q=0 component of the kernel by adding and subtracting the potential
generated by an array of unit Gaussian charges of width `sqrt(2α)` placed at the
grid points of the supercell with the exception to the origin itself. Here `α` should be
chosen as a localised charge that is well-representable in the chosen plane-wave basis.
We take `α = π²/Ecut` (VASP default). Convergence is `O(1/L³) = O(1 / Nk)` with `Nk`
the number of k-points.

The rationale of this method is that these artificial charges screen the Coulomb interactions
between the unit cell with the origin and the displaced unit cells of the supercell due to
the k-point sampling, such that the G+q=0 term only has contributions from these Gaussian
charges, which can be computed using an Ewald sum.

## References
- [S. Massidda, M. Posternak, A. Baldereschi. Phys. Rev. B **48**, 5058 (1993)](https://doi.org/10.1103/PhysRevB.48.5058)
"""
@kwdef struct ProbeCharge <: KernelRegularization 
    α::Union{Float64, Nothing} = nothing  # Width of the probe charge
end
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    interaction_kernel::InteractionKernel, 
    regularization::ProbeCharge
) where {T}
    # Default value well-tested in VASP; ensures that e^(-α*G²) is localized 
    # charge with full support on G grid
    α = @something regularization.α T(π)^2 / basis.Ecut

    Ω = basis.model.unit_cell_volume  # volume of unit cell 
    Gpq = map(Gpq -> sum(abs2, Gpq), Gplusk_vectors_cart(basis, qpt))

    fourier_kernel = eval_kernel_fourier.(Ref(interaction_kernel), Gpq) # Note: q+G = 0 component is not special-cased, i.e. wrong here

    # Potential of Gaussian charges (skipping term at G+q=0)
    probe_charge_sum = sum((fourier_kernel .* exp.(-α*Gpq))[2:end])

    # Interaction of Gaussian charges with uniform background (i.e. integral of charges)
    #  = Ω/(2π)^3 ∫ 4π/q² ρ(q) dq  with  ρ(q)=e^(-αq²)
    probe_charge_integral = evaluate_probe_charge_integral(interaction_kernel, α, Ω)

    if iszero(qpt.coordinate)
        GPUArraysCore.@allowscalar begin
            fourier_kernel[1] = probe_charge_integral - probe_charge_sum
        end
    end
    fourier_kernel
end


"""
Simply set the G+q=0 Coulomb kernel component to Gpq_zero_value.

This is useful for interaction models with an analytic G+q=0 component
or for testing/comparison purposes.

In case of Gpq_zero_value=0 this leads to slow `O(1/L) = O(1 / ∛(Nk))` 
convergence where `L` is the size of the supercell,`Nk` is the number of k-points.
"""
@kwdef struct ReplaceSingularity{V <: Real} <: KernelRegularization
    Gpq_zero_value::V = 0.0
end
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    interaction_kernel::InteractionKernel, 
    regularization::ReplaceSingularity
) where {T}
    # Compute truncated Coulomb kernel without special-casing singularity at G+q=0 
    fourier_kernel = map(Gplusk_vectors_cart(basis, qpt)) do Gpq
        eval_kernel_fourier(interaction_kernel, sum(abs2, Gpq))
    end

    if iszero(qpt.coordinate)  # Neglect the singularity
        GPUArraysCore.@allowscalar fourier_kernel[1] = 
            T(regularization.Gpq_zero_value)
    end
    fourier_kernel
end


"""
Coulomb interaction: 1/r 
"""
@kwdef struct Coulomb{KR <: KernelRegularization} <: InteractionKernel 
    regularization::KR = ProbeCharge()
end
eval_kernel_fourier(::Coulomb, Gsq::T) where {T} = 4T(π) / Gsq
evaluate_probe_charge_integral(::Coulomb, α, Ω) = 8π^2 * sqrt(π / α) * Ω / (2π)^3
_compute_kernel(basis, qpt, q, m::Coulomb) = _compute_kernel(basis, qpt, q, m, m.regularization)


"""
Short-range Coulomb interaction via error function: erfc(ωr)/r
"""
@kwdef struct ErfShortRangeCoulomb <: InteractionKernel 
    ω = 0.106  # ≈ 0.2 / Angstrom
end
eval_kernel_fourier(m::ErfShortRangeCoulomb, Gsq::T) where {T} = -(4T(π) / Gsq) * expm1(-Gsq / (4 * m.ω^2))
_compute_kernel(basis, qpt, q, m::ErfShortRangeCoulomb) = _compute_kernel(basis, qpt, q, m, ReplaceSingularity(π/m.ω^2))


"""
Long-range Coulomb interaction via error function: erf(ωr)/r
"""
@kwdef struct ErfLongRangeCoulomb{KR <: KernelRegularization} <: InteractionKernel 
    ω = 0.106 # ≈ 0.2 / Angstrom
    regularization::KR = ProbeCharge()
end
eval_kernel_fourier(m::ErfLongRangeCoulomb, Gsq::T) where {T} = (4T(π) / Gsq) * exp(-Gsq / (4 * m.ω^2))
evaluate_probe_charge_integral(m::ErfLongRangeCoulomb, α, Ω) = 8π^2 * sqrt(π / (α + 1/(4 * m.α^2))) * Ω / (2π)^3
_compute_kernel(basis, qpt, q, m::ErfLongRangeCoulomb) = _compute_kernel(basis, qpt, q, m, m.regularization)


"""
Spherically truncated Coulomb interaction: θ(Rcut-r)/r
If Rcut is nothing, it uses `Rcut = cbrt(3Ω / (4π))` where `Ω` is the unit cell volume.

## References
- [J. Spencer, A. Alavi. Phys. Rev. B **77**, 193110 (2008)](https://doi.org/10.1103/PhysRevB.77.193110)
"""
@kwdef struct SphericallyTruncatedCoulomb <: InteractionKernel
    Rcut::Union{Float64, Nothing} = nothing
end   
eval_kernel_fourier(m::SphericallyTruncatedCoulomb, Gsq::T) where {T} = 4T(π) / Gsq * (1 - cos(m.Rcut * sqrt(Gsq)))
function _compute_kernel(basis, qpt, q, m::SphericallyTruncatedCoulomb) 
    Ω = basis.model.unit_cell_volume  
    Rcut = @something m.Rcut cbrt(3Ω/(4π))  # convert from potential `nothing` to specific Rcut
    interaction_kernel_with_Rcut = SphericallyTruncatedCoulomb(Rcut)
    _compute_kernel(basis, qpt, q, interaction_kernel_with_Rcut, ReplaceSingularity(2π*Rcut^2))
end

