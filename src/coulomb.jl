@doc raw"""
Abstract type for different methods of computing the 
discretised Coulomb kernel ``v(G+q) = 4π/|G+q|²``.

Available models:
- [`ProbeCharge`](@ref): Gygi-Baldereschi probe charge method
- [`NeglectSingularity`](@ref): Set G+q=0 component to zero
- [`SphericallyTruncated`](@ref): Spherical truncation at radius Rcut
- [`WignerSeitzTruncated`](@ref): Wigner-Seitz cell truncation
- [`VoxelAveraged`](@ref): Replacing 1/(G+q)^2 by its average over the voxel

See also: [`compute_coulomb_kernel`](@ref)
"""
abstract type CoulombKernelModel end

# TODO: Rename to CoulombKernel ???


@doc raw"""
Compute Coulomb kernel, i.e. essentially ``v(G+q) = 4π/|G+q|²``, on spherical plane-wave grid.

Returns the Fourier-space Coulomb interaction for momentum transfer `q`,
evaluated only on the spherical cutoff |G+q|² < 2Ecut (not the full cubic FFT grid).

!!! note "Gamma-point only"
    Currently only works for single k-point calculations (Gamma-only).
    For general k-points, a q-dependent basis would be needed.

## Arguments
- `basis::PlaneWaveBasis`: Plane-wave basis defining the grid
- `q`: Momentum transfer vector in fractional coordinates
- `coulomb_kernel_model::CoulombKernelModel`: Method for treating singularity

## Returns
Vector of Coulomb kernel values for each G-vector in the spherical cutoff.
"""
function compute_coulomb_kernel(basis::PlaneWaveBasis{T}; q=zero(Vec3{T}),
                                coulomb_kernel_model::CoulombKernelModel=ProbeCharge()) where {T}
    is_gamma_only = all(iszero(kpt.coordinate) for kpt in basis.kpoints)
    if !is_gamma_only
        throw(ArgumentError("Currently only Gamma-point calculations are supported in " *
                            "compute_coulomb_kernel, respectively Hartree-Fock and " *
                            "calculations involving exact exchange."))
    end
    if mpi_nprocs(basis.comm_kpts) > 1
        error("MPI parallelisation not yet supported for coulomb kernel")
    end
    @assert iszero(q)

    # currently only works for Gamma-only (need correct q-point otherwise)
    qpt = basis.kpoints[1] 
    coulomb_kernel =  _compute_coulomb_kernel(coulomb_kernel_model, basis, qpt)

    # TODO: if q=0, symmetrize Fourier coeffs to have real iFFT 

    coulomb_kernel = to_device(basis.architecture, coulomb_kernel)
end


"""
Simply set the G+q=0 Coulomb kernel component to zero.
This is the simplest approach but leads to slow `O(1/L) = O(1 / ∛(Nk))` convergence
where `L` is the size of the supercell,`Nk` is the number of k-points.
Useful for testing or comparison purposes.
"""
struct NeglectSingularity <: CoulombKernelModel end
function _compute_coulomb_kernel(::NeglectSingularity, basis::PlaneWaveBasis{T}, qpt::Kpoint) where {T}
    # Compute truncated Coulomb kernel without special-casing singularity at G+q=0 
    coulomb_kernel = map(Gplusk_vectors_cart(basis, qpt)) do Gpq
        4T(π) / sum(abs2, Gpq)
    end

    if iszero(qpt.coordinate)  # Neglect the singularity
        GPUArraysCore.@allowscalar coulomb_kernel[1] = zero(T)
    end
    coulomb_kernel
end


"""
Probe charge Ewald method for treating the Coulomb singularity.

Regularize the G+q=0 component of the kernel by adding and subtracting the potential
generated by an array of unit Gaussian charges of width `sqrt(2α)` placed at the
grid points of the supercell with the exception to the origin itself. Here `α` should be roughly
equal to the Brillouin zone diameter, which we take as `α = π²/Ecut` (VASP default).
Convergence is `O(1/L³) = O(1 / Nk)` with `Nk` the number of k-points.

The rationale of this method is that these artificial charges screen the Coulomb interactions
between the unit cell with the origin and the displaced unit cells of the supercell due to
the k-point sampling, such that the G+q=0 term only has contributions from these Gaussian
charges, which can be computed using an Ewald sum.

## References
- [S. Massidda, M. Posternak, A. Baldereschi. Phys. Rev. B **48**, 5058 (1993)](https://doi.org/10.1103/PhysRevB.48.5058)
"""
@kwdef struct ProbeCharge <: CoulombKernelModel
    α::Union{Float64, Nothing} = nothing  # Width of the probe charge
end
@views function _compute_coulomb_kernel(kernel::ProbeCharge, basis::PlaneWaveBasis{T},
                                        qpt::Kpoint) where {T}
    # Default value well-tested in VASP; ensures that e^(-α*G²) is localized 
    # charge with full support on G grid
    α = @something kernel.α T(π)^2 / basis.Ecut

    Ω = basis.model.unit_cell_volume  # volume of unit cell 
    Gpq = map(Gpq -> sum(abs2, Gpq), Gplusk_vectors_cart(basis, qpt))

    coulomb_kernel = 4T(π) ./ Gpq  # Note: q+G = 0 component is not special-cased, i.e. wrong here

    # Potential of Gaussian charges (skipping term at G+q=0)
    probe_charge_sum = sum((coulomb_kernel .* exp.(-α*Gpq))[2:end])

    # Interaction of Gaussian charges with uniform background (i.e. integral of charges)
    #  = Ω/(2π)^3 ∫ 4π/q² ρ(q) dq  with  ρ(q)=e^(-αq²)
    probe_charge_integral = 8*π^2*sqrt(π/α) * Ω/(2π)^3 

    if iszero(qpt.coordinate)
        GPUArraysCore.@allowscalar begin
            coulomb_kernel[1] = probe_charge_integral - probe_charge_sum
        end
    end
    coulomb_kernel
end


"""
Spherical truncation of Coulomb interaction at radius Rcut.
If Rcut is nothing, it uses `Rcut = cbrt(3Ω / (4π))` where `Ω` is the unit cell volume.

## References
- [J. Spencer, A. Alavi. Phys. Rev. B **77**, 193110 (2008)](https://doi.org/10.1103/PhysRevB.77.193110)
"""
@kwdef struct SphericallyTruncated <: CoulombKernelModel 
    Rcut::Union{Float64, Nothing} = nothing  # Cutoff after which Coulomb operator is set to zero
end
function _compute_coulomb_kernel(kernel::SphericallyTruncated, basis::PlaneWaveBasis{T},
                                 qpt::Kpoint) where {T}
    Ω = basis.model.unit_cell_volume  # volume of unit cell 
    Rcut = @something kernel.Rcut cbrt(3Ω / T(4π))

    # Compute truncated Coulomb kernel without special-casing singularity at G+q=0 
    coulomb_kernel = map(Gplusk_vectors_cart(basis, qpt)) do Gpq
        Gnorm2 = sum(abs2, Gpq)
        4T(π) / Gnorm2 * (1 - cos(Rcut * sqrt(Gnorm2)))
    end

    if iszero(qpt.coordinate)
        GPUArraysCore.@allowscalar begin
            coulomb_kernel[1] = 2T(π)*Rcut^2
        end
    end
    coulomb_kernel
end
