using FastGaussQuadrature

@doc raw"""
Abstract type for different interaction models

Available models:
- [`Coulomb`](@ref): 1/r
- [`ErfShortRangeCoulomb`](@ref): erfc(ωr)/r
- [`ErfLongRangeCoulomb`](@ref): erf(ωr)/r
- [`TruncatedCoulomb`](@ref): spatially truncated 1/r

See also: [`compute_interaction_kernel`](@ref)
"""
abstract type InteractionModel end


@doc raw"""
Compute Coulomb kernel, i.e. essentially ``v(G+q) = 4π/|G+q|²``, on spherical plane-wave grid.

Returns the Fourier-space Coulomb interaction for momentum transfer `q`,
evaluated only on the spherical cutoff |G+q|² < 2Ecut (not the full cubic FFT grid).

!!! note "Gamma-point only"
    Currently only works for single k-point calculations (Gamma-only).
    For general k-points, a q-dependent basis would be needed.

## Arguments
- `basis::PlaneWaveBasis`: Plane-wave basis defining the grid
- `q`: Momentum transfer vector in fractional coordinates
- `interaction_model::InteractionModel`: Method for treating singularity

## Returns
Vector of Coulomb kernel values for each G-vector in the spherical cutoff.
"""
function compute_interaction_kernel(basis::PlaneWaveBasis{T}; q=zero(Vec3{T}),
                                interaction_model::InteractionModel=ProbeCharge()) where {T}
    is_gamma_only = all(iszero(kpt.coordinate) for kpt in basis.kpoints)
    if !is_gamma_only
        throw(ArgumentError("Currently only Gamma-point calculations are supported in " *
                            "compute_interaction_kernel, respectively Hartree-Fock and " *
                            "calculations involving exact exchange."))
    end
    if mpi_nprocs(basis.comm_kpts) > 1
        error("MPI parallelisation not yet supported for coulomb kernel")
    end
    @assert iszero(q)

    # currently only works for Gamma-only (need correct q-point otherwise)
    qpt = basis.kpoints[1] 
    fourier_kernel =  _compute_kernel(basis, qpt, q, interaction_model)

    # TODO: if q=0, symmetrize Fourier coeffs to have real iFFT 

    fourier_kernel = to_device(basis.architecture, fourier_kernel)
end


@doc raw"""
Abstract type for different strategies to regularize the
diverging G+q=0 fourier componentn of interaction models.

Available models:
- [`ProbeCharge`](@ref): Gygi-Baldereschi probe charge method
- [`ReplaceSingularity`](@ref): Set G+q=0 component to given value (default is zero)
- [`VoxelAveraged`](@ref): Replacing 1/(G+q)^2 by its average over the voxel

See also: [`InteractionModel`](@ref)
"""
abstract type KernelRegularization end


"""
Probe charge Ewald method for treating the Coulomb singularity.

Regularize the G+q=0 component of the kernel by adding and subtracting the potential
generated by an array of unit Gaussian charges of width `sqrt(2α)` placed at the
grid points of the supercell with the exception to the origin itself. Here `α` should be
chosen as a localised charge that is well-representable in the chosen plane-wave basis.
We take `α = π²/Ecut` (VASP default). Convergence is `O(1/L³) = O(1 / Nk)` with `Nk`
the number of k-points.

The rationale of this method is that these artificial charges screen the Coulomb interactions
between the unit cell with the origin and the displaced unit cells of the supercell due to
the k-point sampling, such that the G+q=0 term only has contributions from these Gaussian
charges, which can be computed using an Ewald sum.

## References
- [S. Massidda, M. Posternak, A. Baldereschi. Phys. Rev. B **48**, 5058 (1993)](https://doi.org/10.1103/PhysRevB.48.5058)
"""
@kwdef struct ProbeCharge <: KernelRegularization 
    α::Union{Float64, Nothing} = nothing  # Width of the probe charge
end
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    interaction_model::InteractionModel, 
    regularization::ProbeCharge
) where {T}
    # Default value well-tested in VASP; ensures that e^(-α*G²) is localized 
    # charge with full support on G grid
    α = @something regularization.α T(π)^2 / basis.Ecut

    Ω = basis.model.unit_cell_volume  # volume of unit cell 
    Gpq = map(Gpq -> sum(abs2, Gpq), Gplusk_vectors_cart(basis, qpt))

    interaction_kernel = evaluate_kernel.(Ref(interaction_model), Gpq) # Note: q+G = 0 component is not special-cased, i.e. wrong here

    # Potential of Gaussian charges (skipping term at G+q=0)
    probe_charge_sum = sum((interaction_kernel .* exp.(-α*Gpq))[2:end])

    # Interaction of Gaussian charges with uniform background (i.e. integral of charges)
    #  = Ω/(2π)^3 ∫ 4π/q² ρ(q) dq  with  ρ(q)=e^(-αq²)
    probe_charge_integral = evaluate_probe_charge_integral(interaction_model, α, Ω)

    if iszero(qpt.coordinate)
        GPUArraysCore.@allowscalar begin
            interaction_kernel[1] = probe_charge_integral - probe_charge_sum
        end
    end
    interaction_kernel
end


"""
Simply set the G+q=0 Coulomb kernel component to Gpq_zero_value.

In case of Gpq_zero_value=0 this leads to slow `O(1/L) = O(1 / ∛(Nk))` 
convergence where `L` is the size of the supercell,`Nk` is the number of k-points.
Useful for testing or comparison purposes.
"""
@kwdef struct ReplaceSingularity{V <: Real} <: KernelRegularization
    Gpq_zero_value::V = 0.0
end
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    interaction_model::InteractionModel, 
    regularization::ReplaceSingularity
) where {T}
    # Compute truncated Coulomb kernel without special-casing singularity at G+q=0 
    interaction_kernel = map(Gplusk_vectors_cart(basis, qpt)) do Gpq
        evaluate_kernel(interaction_model, sum(abs2, Gpq))
    end

    if iszero(qpt.coordinate)  # Neglect the singularity
        GPUArraysCore.@allowscalar interaction_kernel[1] = 
            T(regularization.Gpq_zero_value)
    end
    interaction_kernel
end


"""
Calculates the average of the Coulomb kernel over the Brillouin zone voxel associated
with each grid point. It is particularly well suited for highly anisotropic cells.

- **G=0 (Singularity):** Uses an exact mathematical reduction of the volume integral 
  ``∫ 1/G^2 dV`` to a smooth surface integral over the voxel faces (surface reduction).
- **G≠0 (Smooth):** Uses high-order Gaussian quadrature.

It is conceptually equivalent to the HFMEANPOT flag in VASP but uses improved integration
techniques to calcualte the average in the voxel.

# Arguments
- `N_quadrature_points::Int`: The number of Gauss-Legendre quadrature points used per dimension. 
  Defaults to 12. For highly anisotropic cells or rigorous Thermodynamic Limit (TDL) extrapolations, 
    it is advisable to check if higher values (e.g., to 18 or 24) eliminate numerical noise.

## Reference
J. Chem. Phys. 160, 051101 (2024) (doi.org/10.1063/5.0182729)
"""
@kwdef struct VoxelAveraged <: KernelRegularization 
    n_quadrature_points::Int = 12
end
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    interaction_model::InteractionModel, 
    regularization::VoxelAveraged
) where {T}
    model = basis.model
    q = qpt.coordinate
    
    # Get kgrid_size
    if isnothing(basis.kgrid)
        kgrid_size = Vec3{Int}(1, 1, 1)
    elseif basis.kgrid isa AbstractVector
        kgrid_size = Vec3{Int}(basis.kgrid)
    elseif basis.kgrid isa MonkhorstPack
        kgrid_size = Vec3{Int}(basis.kgrid.kgrid_size)
    else
        @error "Cannot determine kgrid_size for VoxelAveraged Coulomb model."
    end

    # Define Voxels as reciprocal cell deivided by k-mesh
    voxel_basis = model.recip_lattice * Diagonal(1 ./ Vec3{T}(kgrid_size))
    voxel_vol = abs(det(voxel_basis))
    
    # get Gauss-Legendre nodes and weights
    nodes_std, weights_std = gausslegendre(regularization.n_quadrature_points)
    # Scale from [-1, 1] to [-0.5, 0.5]
    nodes = T.(nodes_std ./ 2)
    weights = T.(weights_std ./ 2)
    
    interaction_kernel = zeros(T, length(qpt.G_vectors))

    for (iG, G) in enumerate(to_cpu(qpt.G_vectors))
        G_cart = model.recip_lattice * (G+q)

        found_singularity = (iG==1 && iszero(q))
        
        if found_singularity 
            # === At Singularity (G+q=0) use surface reduction method ===
            
            # We only do that for the 4π/(G+q)^2 kernel, hence the quadrature below
            # covers the rest if interaction_model is different from Coulomb().
            
            # Transforms volume integral ∫ 1/G^2 dV to surface integral Σ h * ∫ 1/G^2 dS
            integral = zero(T)
            for i in 1:3
                u_i = voxel_basis[:, i]
                u_j = voxel_basis[:, mod1(i+1, 3)]
                u_k = voxel_basis[:, mod1(i+2, 3)]
                
                # Height of the face from origin
                normal = cross(u_j, u_k)
                area_norm = norm(normal)
                
                # Calculate distance h from center to face.
                # Since face is at u_i/2, h = |(u_i/2) . n|
                h = abs(dot(u_i, normal)) / (2 * area_norm)
                
                # Integrate 1/G^2 over the face parallelogram
                face_integral = zero(T)
                for (wa, a) in zip(weights, nodes)
                    for (wb, b) in zip(weights, nodes)
                        # Parametrization of the face: r = u_i/2 + a*u_j + b*u_k
                        r_vec = 0.5f0 * u_i + a * u_j + b * u_k 
                        r_sq  = dot(r_vec, r_vec)
                        face_integral += wa * wb / r_sq
                    end
                end
                
                # Add contribution: 2 faces * h * Area * Mean(1/r^2)
                # Area factor (area_norm) comes from the Jacobian.
                integral += 2 * h * area_norm * face_integral
            end
            
            interaction_kernel[iG] = 4T(π) * (integral / voxel_vol)
        end

        # === Use smooth 3D Gaussian Quadrature ===
        integral = zero(T)
        for (wx, x) in zip(weights, nodes)
            for (wy, y) in zip(weights, nodes)
                for (wz, z) in zip(weights, nodes)
                    # q vector inside voxel
                    q_local = x * voxel_basis[:, 1] + 
                              y * voxel_basis[:, 2] + 
                              z * voxel_basis[:, 3]
                    
                    G_total = G_cart + q_local
                    Gsq = dot(G_total, G_total)

                    # switch temporarily to BigFloat
                    Gsq_big = BigFloat(Gsq)
                    val_big = evaluate_kernel(interaction_model, Gsq_big)

                    # At singularity, already captured the 4π/(G+q)^2 contribution above: subtract
                    if found_singularity
                        val_big -= 4π/Gsq_big
                    end

                    # back to type T
                    val = T(val_big)

                    integral += wx * wy * wz * val
                end
            end
        end
        interaction_kernel[iG] += integral
    end
    
    interaction_kernel
end


@doc raw"""
Abstract type for truncation strategies of interaction models.

Available models:
- [`Spherically`](@ref): Spherical truncation at radius Rcut
- [`WignerSeitz`](@ref): Wigner-Seitz cell truncation

See also: [`InteractionModel`](@ref)
"""
abstract type TruncationStrategy end


"""
Spherical truncation of Coulomb interaction at radius Rcut.
If Rcut is nothing, it uses `Rcut = cbrt(3Ω / (4π))` where `Ω` is the unit cell volume.

## References
- [J. Spencer, A. Alavi. Phys. Rev. B **77**, 193110 (2008)](https://doi.org/10.1103/PhysRevB.77.193110)
"""
@kwdef struct Spherically <: TruncationStrategy 
    Rcut::Union{Float64, Nothing} = nothing
end   
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    truncation::Spherically, 
) where {T}
    Ω = basis.model.unit_cell_volume  # volume of unit cell 
    Rcut = @something truncation.Rcut cbrt(3Ω / T(4π))

    # Compute truncated Coulomb kernel without special-casing singularity at G+q=0 
    interaction_kernel = map(Gplusk_vectors_cart(basis, qpt)) do Gpq
        Gnorm2 = sum(abs2, Gpq)
        4T(π) / Gnorm2 * (1 - cos(Rcut * sqrt(Gnorm2)))
    end

    if iszero(qpt.coordinate)
        GPUArraysCore.@allowscalar begin
            interaction_kernel[1] = 2T(π)*Rcut^2
        end
    end
    interaction_kernel
end


"""
Truncate Coulomb interaction at the Wigner-Seitz cell boundary.

## Reference
- [R. Sundararaman, T. A. Arias. Phys. Rev. B **87**, 165122 (2013)](https://doi.org/10.1103/PhysRevB.87.165122)
"""
struct WignerSeitz <: TruncationStrategy end 
@views function _compute_kernel(
    basis::PlaneWaveBasis{T}, 
    qpt, 
    q, 
    truncation::WignerSeitz
) where {T}
    model = basis.model
    NG = length(qpt.G_vectors)
    interaction_kernel = zeros(T, NG)
    q = qpt.coordinate
    # calculate inradius R_in of Wigner-Seitz cell
    # R_in is given by the largest possible 
    # R_in = (sum_i n_i * a*i) / 2 
    # with integers n_i and |R_in| <= a_min where a_min is the length of the smallest lattice vector.
    # The inequality allows us to restrict n_i by exploiting Cauchy-Schwarz, leading to 
    # |n_i| <= a_min * |b_i| / 2π 
    # where b_i are the reciprocal lattice vectors.
    L_min = minimum(norm, eachcol(model.lattice))
    n_bounds = zeros(Int, 3)
    for i in 1:3
        b_vec = model.recip_lattice[:, i]
        b_len = norm(b_vec)
        N = (L_min * b_len) / (2π)
        n_bounds[i] = ceil(Int, N)
    end
    nx, ny, nz = n_bounds # in case of a cubic cell nx=ny=nz=1
    # construct R_in
    R_in = T(Inf)
    for ix in -nx:nx, iy in -ny:ny, iz in -nz:nz # loop through all necessary integers 
        ix == 0 && iy == 0 && iz == 0 && continue
        R = model.lattice * [ix, iy, iz]
        d = norm(R) / 2 # distance from origin to perpendicular bisector plane = |R|/2
        R_in = min(R_in, d)
    end
    
    # Nyquist frequency of FFT grid
    G_Nyquist = minimum(basis.fft_size[d] / 2 * norm(model.recip_lattice[:, d]) for d in 1:3) 

    ε_target = 1e-12
    ε_min = exp(-0.5*G_Nyquist*R_in)  # required: G_Nyquist > -2*log(ε)/R_in (Appendix A.1 in paper)
    ε = max(ε_target, ε_min)
    if ε > 1e-8
        @warn "Grid too coarse for Wigner-Seitz truncation. Effective truncation error: $ε"
    end
    ω = sqrt(-log(ε)) / R_in  # range separation parameter

    # FFT of long-range term erf(ωr)/r restricted to Wigner-Seitz cell 
    r_vectors = DFTK.r_vectors(basis)
    V_lr_real = zeros(Complex{T}, basis.fft_size...)
    for idx in CartesianIndices(V_lr_real)
        r_frac = r_vectors[idx]
        r_centered = r_frac .- round.(r_frac) # MIC
        r_cart = model.lattice * r_centered
        d_min = norm(r_cart)
        for dx in -nx:nx, dy in -ny:ny, dz in -nz:nz # Check neighbors for non-orthorhombic cells
            dx == 0 && dy == 0 && dz == 0 && continue 
            r_shifted = r_centered - T[dx, dy, dz]
            d = norm(model.lattice * r_shifted)
            d_min = min(d_min, d)
        end
        if d_min > sqrt(eps(T))
            V_lr_real[idx] = erf(ω * d_min) / d_min
        else
            V_lr_real[idx] = 2*ω / sqrt(T(π))
        end
        V_lr_real[idx] *= exp(-im * 2*T(π) * dot(q, r_frac)) # add phase e^{-2πiqr}
    end
    interaction_kernel_lr = real.(fft(basis, qpt, V_lr_real))
    interaction_kernel_lr .*= sqrt(model.unit_cell_volume)
    
    # analytic short-range term + long-range term 
    for (iG, G) in enumerate(to_cpu(qpt.G_vectors))
        G_cart = model.recip_lattice * (G+q)
        Gnorm2 = sum(abs2, G_cart)
        found_singularity = (iG==1 && iszero(q))
        Rcut = cbrt(basis.model.unit_cell_volume*3/4/π)
        if !found_singularity
            interaction_kernel[iG] = 4T(π) / Gnorm2 * (1 - exp(-Gnorm2/(4ω^2))) + interaction_kernel_lr[iG]
        else
            interaction_kernel[iG] = T(π)/ω^2 + interaction_kernel_lr[iG]
        end
    end
    interaction_kernel
end


"""
Coulomb interaction 1/r requires regularization
"""
@kwdef struct Coulomb{KR <: KernelRegularization} <: InteractionModel 
    regularization::KR = ProbeCharge()
end
evaluate_kernel(::Coulomb, Gsq::T) where {T} = 4T(π) / Gsq
evaluate_probe_charge_integral(::Coulomb, α, Ω) = 8π^2 * sqrt(π / α) * Ω / (2π)^3
_compute_kernel(basis, qpt, q, m::Coulomb) = _compute_kernel(basis, qpt, q, m, m.regularization)


"""
Spatially truncated Coulomb interaction requires truncation strategy
"""
@kwdef struct TruncatedCoulomb{TS <: TruncationStrategy} <: InteractionModel 
    truncation::TS = WignerSeitz()
end
_compute_kernel(basis, qpt, q, m::TruncatedCoulomb) = _compute_kernel(basis, qpt, q, m.truncation)


"""
Short-range Coulomb interaction via error function: erfc(ωr)/r
"""
@kwdef struct ErfShortRangeCoulomb <: InteractionModel 
    ω = 0.106  # ≈ 0.2 / Angstrom
end
evaluate_kernel(m::ErfShortRangeCoulomb, Gsq::T) where {T} = -(4T(π) / Gsq) * expm1(-Gsq / (4 * m.ω^2))
_compute_kernel(basis, qpt, q, m::ErfShortRangeCoulomb) = _compute_kernel(basis, qpt, q, m, ReplaceSingularity(π/m.ω^2))


"""
Long-range Coulomb interaction via error function: erf(ωr)/r
"""
@kwdef struct ErfLongRangeCoulomb{KR <: KernelRegularization} <: InteractionModel 
    ω = 0.106 # ≈ 0.2 / Angstrom
    regularization::KR = ProbeCharge()
end
evaluate_kernel(m::ErfLongRangeCoulomb, Gsq::T) where {T} = (4T(π) / Gsq) * exp(-Gsq / (4 * m.ω^2))
evaluate_probe_charge_integral(m::ErfLongRangeCoulomb, α, Ω) = 8π^2 * sqrt(π / (α + 1/(4 * m.α^2))) * Ω / (2π)^3
_compute_kernel(basis, qpt, q, m::ErfLongRangeCoulomb) = _compute_kernel(basis, qpt, q, m, m.regularization)


