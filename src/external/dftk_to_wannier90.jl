using ProgressMeter
using LinearAlgebra
using Dates

## Works in the following order
# $ dftk2wan_win_file(...) to generate the win file
# $ wannier90.x -pp "prefix" ------------ nnkp file
# $ dftk2wan_wannierization_files(...)--- mmn,amn,eig files
# $ wannier90.x "prefix"  --------------- actual wannierization

## Remark : the routines "dict_AOs", "guess_win", "cart_to_spherical" and "A_k_matrix_win_guesses" and the "projs" table in "read_nnkp_file"
# are dedicated to computation of A_k matrices with Wannier90 guess, read from the nnkp file.
# It is bugged and may not be usefull but I left it there.

## TODO
# 1 - check if kgrid can be removed from dftk2wan_win_file arguments
# 2 - add handling of the SCDM routine as an alternative guess
# 3 - optimize the "generate_mmn" routine


"""
    Create a .win file for Wannier90, compatible with the system studied with DFTK.
    Options have to be compeleted by hand.
"""
function dftk2wan_win_file(prefix::String,basis::PlaneWaveBasis,scfres,num_wann;
                           kgrid = [4,4,4], #can we retrieve this from scfres or basis ? Feel this should not be an argument.
                           bands_plot = false,
                           num_iter = 500,
                           num_print_cycles = 50
                           )
    
    ## Check kgrids
    if (prod(kgrid) != size(scfres.ψ,1))
        error("The given kgrid doesn't match the one used for the scf calculation")
    end    

    ## Write in file   
    open("$prefix.win","w") do f

        write(f,"! $prefix.win file generated by DFTK at "*string(now())*"\n"^2)
        
        ## General parameters
        num_bands = size(scfres.ψ[1],2)
        write(f,"num_bands "*(" "^9)*"= $num_bands"*"\n")
        write(f,"num_wann "*(" "^10)*"= $num_wann"*"\n"^2)

        write(f,"num_iter "*(" "^10)*"= $num_iter"*"\n")
        write(f,"num_print_cycles "*(" "^2)*"= $num_print_cycles"*"\n"^2)
        
        ## Messages for the user
        write(f,"!"^20*" Complete with optional parameters :"*"\n"^2)



        ## System
        write(f,"!"^20*" System"*"\n"^2)

        # Unit cell block
        write(f,"begin unit_cell_cart"*"\n"*"bohr"*"\n")
        unit_cell = transpose(basis.model.lattice)         #unit cell vectors are in raws in Wannier90.
        for i in 1:3
            for j in 1:3
                write(f,"$(unit_cell[i,j]) ")
            end
            write(f,"\n")
        end
        write(f,"end unit_cell_cart"*"\n"^2)

        # Atoms bloc
        atoms = basis.model.atoms
        write(f,"begin atoms_frac"*"\n")
        for i in 1:length(atoms)                  #loop over different elements
            symbol = String(atoms[i][1].symbol)
            for coord in atoms[i][2]              #loop over atoms of the same element
                write(f,symbol*"  "*"$(coord[1])  $(coord[2])  $(coord[3])"*"\n")  
            end
        end
        write(f,"end atoms_frac"*"\n"^2)

        ## Projection bloc : message for the user.
        write(f,"""
        ! Add a projection bloc only with the option : guess = "win" in dftk2wan_wannierization_files.
        ! Otherwise, DFTK uses by default gaussian guesses on specified centers 
        ! or the SCDM method if guess = "SCDM" (not yet implemented).


        """)


        ## k points
        write(f,"!"^20*" k_points"*"\n"^2)

        # Bands_plot bloc
        if bands_plot
            trash,labels,path = high_symmetry_kpath(basis.model)
            write(f,"begin kpoint_path"*"\n")
            for i in 1:size(path[1],1)-1
                ## write path section A -> B
                A,B = path[1][i],path[1][i+1]
                # kpoints are writen in the file with normalized coordinates
                k_A = round.(DFTK.normalize_kpoint_coordinate.(get!(labels,A,1)), digits = 5)
                k_B = round.(DFTK.normalize_kpoint_coordinate.(get!(labels,B,1)), digits = 5)
                # Wannier90 convention for the Γ point is G
                if A == "\\Gamma"
                    A = "G"
                end
                if B == "\\Gamma"
                    B = "G"
                end
                write(f,"$A $(k_A[1]) $(k_A[2]) $(k_A[3]) $B $(k_B[1]) $(k_B[2]) $(k_B[3])"*"\n") 
            end
            write(f,"end kpoint_path"*"\n")
            write(f,"bands_plot = T"*"\n"^2)
        end
        
        # Mp grid
        if kgrid[1]*kgrid[2]*kgrid[3] !== size(scfres.ψ,1)
            error("Given kgrid doesn't match the kgrid used for scf calculation")
        end
        write(f,"mp_grid : $(kgrid[1]) $(kgrid[2]) $(kgrid[3])"*"\n")
        if kgrid == [1,1,1]
            write(f,"gamma_only      = true"*"\n")
        else
            write(f,"\n")
        end
        
        # kpoints bloc
        write(f,"begin kpoints"*"\n")
        for i in 1:size(scfres.ψ,1)
            for x in basis.kpoints[i].coordinate
                write(f,"$x ")
            end
            write(f,"\n")
        end
        write(f,"end kpoints"*"\n"^2)

        @info "File generated.",f
    end
    
    
end


"""
Read the .nnkp file provided by the preprocessing routine of Wannier90 (i.e. "wannier90.x -pp prefix")
Returns: 
1) the array 'nn_kpts' of k points, they respective neirest neighbours and associated shifing vectors (non zero if the neighbour of is located in another cell).
2) the number 'nn_num' of neighbours per k point. 
2) the array 'projs' of projections. Each line contains the informations for one projection :  [center],[quantum numbers: l,mr,r],[ref. z_axis],[ref. x_axis],α = Z/a
"""
function read_nnkp_file(prefix::String)

    ## Check the presence of the file
    if !isfile("$prefix.nnkp")
        error("file $prefix.nnkp not found.")   
    end

    ## Read the file
    file = open("$prefix.nnkp")
    @info "Reading nnkp file", file 
    ln = [string(l) for l in eachline(file)]
    close(file)


    ## Extract nnkp block 
    i_nn_kpts = findall(x-> endswith(x,"nnkpts"),ln)                               #Indices of the first and last line of the nnkpts block
    @assert size(i_nn_kpts,1) == 2
    char_to_vec(line) = [parse.(Int,x) for x in split(line,' ',keepempty=false)]
    
    nn_num = parse(Int64,ln[i_nn_kpts[1]+1])                                       #number of neighbours per k points
    nn_kpts =  [ char_to_vec(l) for l in ln[i_nn_kpts[1]+2:i_nn_kpts[2]-1] ]       



    ## Extract projections block : NEEDED FOR WIN GUESSES
    i_projs = findall(x-> endswith(x,"projections"),ln)                                  #Indices of the first and last line of the projection block
    @assert size(i_projs,1) == 2
    raw_projs = [split(ln[i],' ',keepempty = false) for i in i_projs[1]+1:i_projs[2]-1]  #data in strings

    # reshape so that one line gives all infos about one projection
    n_projs = parse(Int,only(popfirst!(raw_projs)))
    @assert(n_projs == size(raw_projs,1)/2)
    raw_projs = reshape(raw_projs,(2,n_projs))

    # Parse in the format proj = [ [[center],[l,mr,r],[z_axis],[x_axis], α], ... ]
    projs = []
    for j in 1:n_projs
        center = [parse(Float64,x) for x in raw_projs[1,j][1:3]]
        quantum_numbers = [parse(Int,x) for x in raw_projs[1,j][4:end] ]
        z_axis = [parse(Float64,x) for x in raw_projs[2,j][1:3]]
        x_axis = [parse(Float64,x) for x in raw_projs[2,j][4:6]]
        α = parse(Float64,raw_projs[2,j][7])
        push!(projs, [center,quantum_numbers,z_axis,x_axis,α])
    end
    
    nn_kpts,nn_num,projs    
end



"""
Take scf_res, the result of a self_consistent_field calculation and writes eigenvalues (in eV) in a format readable by Wannier90.
"""
function generate_eig_file(prefix::String,scf_res)
    Ha_to_eV = 1/(unit_to_au(:eV))

    eigvalues = scf_res.eigenvalues
    k_size = size(eigvalues,1)
    n_bands = size(eigvalues[1],1)

    #write file
    open("$prefix.eig","w") do f
        for k in 1:k_size
            for n in 1:n_bands
                write(f,"  $n  $k  $(Ha_to_eV*eigvalues[k][n])"*"\n")
            end
        end
    end

    return nothing
    
end


@doc raw"""
 Computes the matrix ``[M^{k,b}]_{m,n} = \langle u_{m,k} | u_{n,k+b} \rangle`` for given k, kpb = k+b.
 
 Return in the format of a (n_bands^2, 2) matrix, where each line is one overlap, and columns are real and imaginary parts.

 K_shift is the "shifting" vector, correction due to the periodicity conditions imposed on k -> ψ_k. 
 It is non zero if kpb is taken in another unit cell of the reciprocal lattice.
 We use here that : ``u_{n(k + K_shift)}(r) = e^{-i*\langle K_shift,r \rangle} u_{nk}``
"""
function overlap_Mmn_k_kpb(pw_basis::PlaneWaveBasis,ψ,k,kpb,n_bands; K_shift = [0,0,0])
    Mkb = zeros(Float64,n_bands*n_bands,2)
    current_line = 0 #Manual count necessary to match the format of .mmn files.

    for n in 1:n_bands
        for m in 1:n_bands
            
            ovlp = 0im
            
            ## Extract Fourier coeffs and corresponding vectors in reciprocal lattice
            Gk_coeffs = ψ[k][:,m] 
            Gk_vec = G_vectors(pw_basis.kpoints[k])
            Gkpb_coeffs = ψ[kpb][:,n]
            Gkpb_vec = [ G - K_shift for G in G_vectors(pw_basis.kpoints[kpb]) ] # Don't forget the shift, see the DOC block
            
            ## Search for common Fourier modes, corresponding indices are written in map_fourier_mode
            map_fourier_modes = []
            for G1 in Gk_vec
                for G2 in Gkpb_vec
                    if  G1 == G2
                        iG1 = only(findall(x-> x==G1,Gk_vec))
                        iG2 = only(findall(x-> x==G2,Gkpb_vec))
                        push!(map_fourier_modes,[iG1,iG2])
                    end
                end
            end
            
            ## Compute the overlap for mn
            for (i,j) in map_fourier_modes
                ovlp += conj(Gk_coeffs[i])*Gkpb_coeffs[j]
            end
            
            current_line += 1 #Go to the next line
            Mkb[current_line,:] = [real(ovlp),imag(ovlp)]

        end
    end

    Mkb

 end



"""
Iteratively use the preceeding function on each k and kpb to generate the whole .mmn file.
"""
function generate_mmn_file(prefix::String,pw_basis::PlaneWaveBasis,ψ, nn_kpts, nn_num)
    ## general parameters
    n_bands = size(ψ[1],2)
    k_size = length(ψ)
    
    progress = Progress(size(nn_kpts,1),desc = "Computing Mmn overlaps : ")
    
    # Small function for the sake of clarity
    read_nn_kpts(n) = nn_kpts[n][1],nn_kpts[n][2],nn_kpts[n][3:end]

    ## Write file
    open("$prefix.mmn","w") do f
        write(f,"Generated by DFTK at ",string(now()),"\n")
        write(f,"$n_bands  $k_size  $nn_num"*"\n")
        
        for i_nnkp in 1:size(nn_kpts,1) #Loop over all (k_points, neirest_neighbour, shif_vector)
            #Write the label of the matrix
            k,kpb,shift = read_nn_kpts(i_nnkp)
            write(f,string(k)*"  "*string(kpb)*"  "*string(shift[1])*"  "*string(shift[2])*"  "*string(shift[3])*"\n")   
            #The matrix itself
            Mkb = overlap_Mmn_k_kpb(pw_basis,ψ,k,kpb,n_bands,; K_shift = shift)
            for i in 1:n_bands*n_bands
                write(f, "$(Mkb[i,1])  $(Mkb[i,2])"*"\n")
            end
            next!(progress)
        end
    end

end


"""
Given a k point, provide the indices of the corresponding G_vectors in the general FFT grid.
Used in 'A_k_matrix_gaussian_guesses'.
"""
function map_k_G_vectors(pw_basis::PlaneWaveBasis,k,fft_grid)
    map = []
    for G in G_vectors(pw_basis.kpoints[k])
        iG = only( findall(x -> x==G, fft_grid) )
        push!(map,iG)
    end
    map
    
end


@doc raw"""
Compute the matrix ``[A_k]_{m,n} = \langle ψ_m^k | g^{\text{per}}_n \rangle`` 

``g^{per}_n`` are periodized gaussians whose respective centers are given as an (n_bands,1) array [ [center 1], ... ].
Centers are to be given in lattice coordinates.

The dot product is computed in the Fourier space. 

Given an orbital ``g_n``, the periodized orbital is defined by : ``g^{per}_n=  \sum\limits_{R in lattice} g_n( ⋅ - R)``. 
``g^{per}_n`` is not explicitly computed. Its Fourier coefficient at any G is given by the value of the Fourier transform of ``g_n`` in G.
"""
function A_k_matrix_gaussian_guesses(pw_basis::PlaneWaveBasis,ψ,k,n_bands,n_wann; centers = [], projs = [])
    ## Before calculation 
    guess_fourier(center) = xi ->  exp(-im*dot(xi,center) - dot(xi,xi)/4)   #associate a center with the fourier transform of the corresponding gaussian

    fft_grid = [G for (iG,G) in enumerate(G_vectors(pw_basis)) ]            #FFT grid in recip lattice coordinates
    G_cart =[ pw_basis.model.recip_lattice * G for G in fft_grid ]          #FFT grid in cartesian coordinates
    index = map_k_G_vectors(pw_basis,k,fft_grid)                            #Indices of the Fourier modes of the bloch states in the general FFT_grid for given k

    ## Initialize output
    A_k = zeros(Complex,(n_bands,n_wann))

    ## Compute A_k
    for n in 1:n_wann
        # Compute fourier coeffs of g_per_n
        fourier_gn = guess_fourier(pw_basis.model.lattice*transpose(centers[n]))        # the center is first computed in cartesian coordinates
        norm_g_per_n = norm([fourier_gn(G) for G in G_cart],2)                          # functions are l^2 normalized in Fourier, in DFTK conventions.
        coeffs_g_per_n = [ fourier_gn(G_cart[iG]) for iG in index ]  ./ norm_g_per_n    # Fourier coeffs of gn for G_vectors in common with ψm
        # Compute overlap
        for m in 1:n_bands
            coeffs_ψm = ψ[k][:,m]
            A_k[m,n] = dot(coeffs_ψm,coeffs_g_per_n)
        end  
    end
    
    A_k
end


## This is the part dedicated to "win" guesses
"""
Generate the dictionary associating quantum numbers r,l and mr with corrsponding radial and angular parts of hydrogen AOs.
(See Tables 3.1 and 3.2 of Wannier90 user_guide.)
Return two dictionaries, radial_parts and angular_parts. Needed to generate guesses from the projection block in the .nnkp file.
"""
function dict_AOs(α)

    ##Radial parts of hydrogen AOs in a dictionary : quantum number r -> AO radial part
    radial_parts = Dict()
    push!(radial_parts, 1 => r -> 2*α^(3/2)*exp(-α*r) ) 
    push!(radial_parts, 2 => r -> (1/(2*√2)) * α^(3/2) * (2-α*r) * exp(-α*r/2) )
    push!(radial_parts, 3 => r -> √(4/27) * α^(3/2) * (1-2*α*r/3+2*(α^2)*(r^2)/27) * exp(-α*r/3) )
    
    ## Basic blocs of hydrogen AOs' angular parts
    s(θ,φ) = 1/√(4*pi)
    pz(θ,φ) = √( 3/(4*π) )*cos(θ)
    px(θ,φ) = √( 3/(4*π) )*sin(θ)*cos(φ)
    py(θ,φ) = √( 3/(4*π) )*sin(θ)*sin(φ)

    dz2(θ,φ) = √(5/(16π))*(3*cos(θ)^2 -1)
    dx2(θ,φ) = √(15/(4π))*sin(θ)*cos(θ)*cos(φ)
    dx2_y2(θ,φ) = √(15/(16π))*(sin(θ)^2)*cos(2*φ)

    ## All angular parts in a dictionary : quantum numbers [l,mr] => AO angular part
    angular_parts = Dict()
    push!(angular_parts, [0,1] => s)
    push!(angular_parts, [1,1] => pz)
    push!(angular_parts, [1,2] => px)
    push!(angular_parts, [1,3] => py)

    push!(angular_parts, [2,1] => dz2 )                                        #dz2
    push!(angular_parts, [2,2] => dx2 )                                        #dxz
    push!(angular_parts, [2,3] => (θ,φ) -> √(15/(4π))*sin(θ)*cos(θ)*sin(φ) )   #dyz
    push!(angular_parts, [2,4] => dx2_y2 )                                     #dx2-y2
    push!(angular_parts, [2,5] => (θ,φ) -> √(15/(16π))*(sin(θ)^2)*sin(2*φ) )   #dxy

    push!(angular_parts, [3,1] => (θ,φ) -> (√7/(4*√(2π)))  * (5*cos(θ)^3 - 3*cos(θ)) )                   #fz3  
    push!(angular_parts, [3,2] => (θ,φ) -> (√21/(4*√(2π))) * (5*cos(θ)^2 - 1)*sin(θ)*cos(φ) )            #fxz2
    push!(angular_parts, [3,3] => (θ,φ) -> (√21/(4*√(2π))) * (5*cos(θ)^2 - 1)*sin(θ)*sin(φ) )            #fyz2
    push!(angular_parts, [3,4] => (θ,φ) -> (√105/(4*√π))   * (sin(θ)^2)*cos(θ)*cos(2*φ) )                #fz(x2-y2)
    push!(angular_parts, [3,5] => (θ,φ) -> (√105/(4*√π))   * (sin(θ)^2)*cos(θ)*sin(2*φ) )                #fxyz
    push!(angular_parts, [3,6] => (θ,φ) -> (√35/(4*√(2π))) * (sin(θ)^3)*(cos(φ)^2 - 3*sin(φ)^2)*cos(φ) ) #fx(x2-3y2)
    push!(angular_parts, [3,7] => (θ,φ) -> (√35/(4*√(2π))) * (sin(θ)^3)*(3*cos(φ)^2 - sin(φ)^2)*sin(φ) ) #fy(3x2-y2)
        
    push!(angular_parts, [-1,1] => (θ,φ) -> (1/√2)*s + (1/√2)*px ) #sp-1 
    push!(angular_parts, [-1,2] => (θ,φ) -> (1/√2)*s - (1/√2)*px ) #sp-2
    
    push!(angular_parts, [-2,1] => (θ,φ) -> (1/√3)*s - (1/√6)*px + (1/√2)*py) #sp2-1
    push!(angular_parts, [-2,2] => (θ,φ) -> (1/√3)*s - (1/√6)*px - (1/√2)*py) #sp2-2
    push!(angular_parts, [-2,3] => (θ,φ) -> (1/√3)*s + (2/√6)*px )            #sp2-3
    
    push!(angular_parts, [-3,1] => (θ,φ) -> 0.5*(s(θ,φ)+px(θ,φ)+py(θ,φ)+pz(θ,φ)) )  #sp3-1
    push!(angular_parts, [-3,2] => (θ,φ) -> 0.5*(s(θ,φ)+px(θ,φ)-py(θ,φ)-pz(θ,φ)) )  #sp3-2
    push!(angular_parts, [-3,3] => (θ,φ) -> 0.5*(s(θ,φ)-px(θ,φ)+py(θ,φ)-pz(θ,φ)) )  #sp3-3
    push!(angular_parts, [-3,4] => (θ,φ) -> 0.5*(s(θ,φ)-px(θ,φ)-py(θ,φ)+pz(θ,φ)) )  #sp3-4

    push!(angular_parts, [-4,1] => (θ,φ) ->  (1/√3)*s - (1/√6)*px + (1/√2)*py)  #sp3d-1
    push!(angular_parts, [-4,2] => (θ,φ) ->  (1/√3)*s - (1/√6)*px - (1/√2)*py)  #sp3d-2
    push!(angular_parts, [-4,3] => (θ,φ) ->  (1/√3)*s + (2/√6)*px)              #sp3d-3
    push!(angular_parts, [-4,4] => (θ,φ) ->  (1/√2)*pz + (1/√2)*dz2 )           #sp3d-4
    push!(angular_parts, [-4,5] => (θ,φ) -> -(1/√2)*pz + (1/√2)*dz2 )           #sp3d-5


    push!(angular_parts, [-5,1] => (θ,φ) -> (1/√6)*s - (1/√2)*px - (1/√12)*dz2 +  (1/2)*dx2_y2) #sp3d2-1
    push!(angular_parts, [-5,2] => (θ,φ) -> (1/√6)*s + (1/√2)*px - (1/√12)*dz2 +  (1/2)*dx2_y2) #sp3d2-2
    push!(angular_parts, [-5,3] => (θ,φ) -> (1/√6)*s - (1/√2)*py - (1/√12)*dz2 -  (1/2)*dx2_y2) #sp3d2-3
    push!(angular_parts, [-5,4] => (θ,φ) -> (1/√6)*s + (1/√2)*py - (1/√12)*dz2 -  (1/2)*dx2_y2) #sp3d2-4
    push!(angular_parts, [-5,5] => (θ,φ) -> (1/√6)*s - (1/√2)*pz + (1/√3)*dz2)                  #sp3d2-5
    push!(angular_parts, [-5,6] => (θ,φ) -> (1/√6)*s + (1/√2)*pz + (1/√3)*dz2)                  #sp3d2-6
    
 

    radial_parts,angular_parts
end



""" 
    Takes one line of the projections table given by read_nnkp_file and  dictionaries linking quantum numbers
    and radial or angular parts of hydrogen AOs, and produce the analytic expression of the guess.
    Remember that : proj = [ [center], [quantum numbers], [z_axis], [x_axis], α ]
"""
function guess_win(proj)
    center = proj[1]
    l,mr,r = proj[2]
    α = proj[5]

    radial_parts,angular_parts = dict_AOs(α)
    #TODO take into account non-canonical basis
    @assert(proj[3] == [0.00,0.00,1.00]) #For now we limit ourselves to the canonical basis
    @assert(proj[4] == [1.00,0.00,0.00])

    #Choose radial and angular parts
    R = get!(radial_parts,r,1)
    Θ = get!(angular_parts,[l,mr],1)
    
    g_n(r,θ,φ) = R(r)*Θ(θ,φ)

    g_n
    
end

"""
Convert cartesian to spherical coordinates.
"""
function cart_to_spherical(cart_coord)
    x,y,z = cart_coord
    r = norm(cart_coord,2)
    if r != 0.0
        φ = atan(y,x)                 #atan(x,y) gives atan(x/y) and selects the right quadrant
        θ = atan(norm([x,y],2),z)
    else
        φ = 0.0
        θ = 0.0
    end
    [r,φ,θ]
end



function A_k_matrix_win_guesses(pw_basis::PlaneWaveBasis,ψ,k; projs = [],centers = [])
    n_bands = size(ψ[1][1,:],1)
    n_projs = size(projs,1)
    
    r_cart = [pw_basis.model.lattice*r for (i,r) in enumerate(r_vectors(pw_basis)) ]
    r_sph  = cart_to_spherical.(r_cart)
    
    A_k = zeros(Complex,(n_bands,n_projs))

    for n in 1:n_projs
        ## Obtain fourier coeff of projection g_n
        gn = guess_win(projs[n])
        real_gn = complex.([gn(r,θ,φ) for (r,θ,φ) in r_sph])
        coeffs_g_per_n = r_to_G(pw_basis,pw_basis.kpoints[k],real_gn)

        ## Compute overlaps
        for m in 1:n_bands
            coeffs_ψm = ψ[k][:,m]
            A_k[m,n] = dot(coeffs_ψm,coeffs_g_per_n)
        end
    end

    A_k
        
end

## End of "win" guess part


"""
Use the preceding functions on every k to generate the .amn file 
"""
function generate_amn_file(prefix::String,pw_basis::PlaneWaveBasis,ψ, n_wann ; projs = [], centers = [], guess = "")
    ##Select guess
    if guess == "win"
        compute_A_k = A_k_matrix_win_guesses
        @assert n_wann == size(projs,1)             #Check if the right number of projection is given...
        
    elseif guess == "gaussian"
        compute_A_k = A_k_matrix_gaussian_guesses
        @assert n_wann == size(centers, 1)          #... same for the number of centers.
        
    end

    ## general parameters
    n_bands = size(ψ[1],2)
    k_size = size(ψ,1)

    progress = Progress(k_size,desc = "Computing Amn overlaps : ")

    ## write file
    open("$prefix.amn","w") do f
        # Header
        write(f,"Generated by DFTK at "*string(now())*"\n")
        write(f,string(n_bands)*"   "*string(k_size)*"   "*string(n_wann)*"\n")

        # Matrices
        for k in 1:k_size
            A_k = compute_A_k(pw_basis,ψ,k,n_bands,n_wann; centers = centers, projs = projs)
            for n in 1:size(A_k,2)
                for m in 1:size(A_k,1)
                    write(f,"$m  $n  $k  $(real(A_k[m,n]))  $(imag(A_k[m,n]))"*"\n")
                end
            end
            next!(progress)
        end      
    end         

end




"""
Use the above functions to read the nnkp file and generate the .eig, .amn and .mmn files needed by Wannier90.
"""
function dftk2wan_wannierization_files(prefix::String, pw_basis::PlaneWaveBasis, scf_res, n_wann;
                                       write_amn = true,
                                       write_mmn = true,
                                       write_eig = true,
                                       guess = "gaussian",
                                       centers = [])

    ## Check for errors
    @assert guess ∈ ("gaussian","SCDM","win")
    
    if guess == "SCDM"
        error("SCDM not yet implemented")
    end

    @info "Guess = $guess"

    ## Generate random centers for gaussian guesses if none are given
    # The centers are in lattice coordinate in [-1,1]^3.
    if (guess == "gaussian") & isempty(centers)
        for i in 1:n_wann
            push!(centers, 1 .- 2 .*rand(1,3))   
        end
    end
    
    ## Read the .nnkp file
    ψ = scf_res.ψ
    nn_kpts,nn_num,projs = read_nnkp_file(prefix) 
    
    ## Generate_files
    if write_eig
        generate_eig_file("Si",scf_res)
    end
    
    if write_amn
        generate_amn_file("Si", pw_basis, ψ, n_wann;
                          centers = centers, projs = projs, guess = guess)
    end
    
    if write_mmn
        generate_mmn_file("Si", pw_basis, ψ, nn_kpts, nn_num)
    end

end
