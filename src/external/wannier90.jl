using Dates
using wannier90_jll

"""
    Create a .win file for Wannier90, compatible with the system studied with DFTK.
    Parameters to Wannier90 can be added as kwargs : e.g. num_iter = 500.
"""
function write_win(prefix::String, basis::PlaneWaveBasis, ψ,
                           num_wann::Integer;
                           bands_plot=false,
                           kwargs...
                           )
    open("$prefix.win", "w") do f

        write(f, "! $prefix.win file generated by DFTK at $(now())\n\n")

        # Required parameters
        num_bands = size(ψ[1],2)
        write(f,@sprintf("%-20s %s %5s \n","num_bands","=",num_bands))
        write(f,@sprintf("%-20s %s %5s \n","num_wann","=",num_wann))
        write(f,"\n")

        # Optional parameters in kwargs
        for (key,value) in kwargs
            write(f,@sprintf("%-20s %s   %-30s\n",key,"=",value))
        end
        write(f,"\n\n")

        # System
        write(f,"!"^20*" System \n\n")

        # Unit cell block
        write(f,"begin unit_cell_cart\n"*"bohr\n")
        unit_cell = transpose(basis.model.lattice) # cell vectors are in rows in Wannier90
        for vec in eachrow(unit_cell)
            write(f,@sprintf("%10.6f %10.6f %10.6f \n",vec[1],vec[2],vec[3]))
        end
        write(f,"end unit_cell_cart \n\n")

        # Atoms block
        atoms = basis.model.atoms
        write(f,"begin atoms_frac\n")
        for i in 1:length(atoms)                  # loop over different elements 
            for coord in atoms[i][2]              # loop over atoms of the same element
                write(f,@sprintf("%-2s %10.6f %10.6f %10.6f \n",
                                 atoms[i][1].symbol,coord[1],coord[2],coord[3]) )
            end
        end
        write(f,"end atoms_frac\n\n")

        # k points
        write(f,"!"^20*" k_points\n\n")

        # Bands_plot block
        if bands_plot
            trash, labels, path = high_symmetry_kpath(basis.model)
            write(f,"begin kpoint_path\n")
            for i in 1:size(path[1],1)-1
                # write path section A -> B
                A,B = path[1][i],path[1][i+1]
                (A == "\\Gamma") && (A = "Γ")
                (B == "\\Gamma") && (B = "Γ")

                # kpoints are writen in the file with normalized coordinates
                k_A = round.(DFTK.normalize_kpoint_coordinate.(get!(labels,A,1)),
                             digits = 5)
                k_B = round.(DFTK.normalize_kpoint_coordinate.(get!(labels,B,1)),
                             digits = 5)
                write(f,@sprintf("%s %10.6f %10.6f %10.6f  %s %10.6f %10.6f %10.6f \n",
                                 A,k_A[1],k_A[2],k_A[3],B,k_B[1],k_B[2],k_B[3]) )
            end
            write(f,"end kpoint_path\n")
            write(f,"bands_plot = T\n\n")
        end

        # MP grid
        (isnothing(basis.kgrid)) && (@error("The system must be constructed"*
                                            " from a MP grid"))
        write(f,"mp_grid : $(basis.kgrid[1]) $(basis.kgrid[2]) $(basis.kgrid[3])\n\n")

        # kpoints block
        write(f,"begin kpoints"*"\n")
        for i in 1:size(ψ,1)
            coord =  basis.kpoints[i].coordinate
            # "coord" already contains the shift
            write(f,@sprintf("%10.6f %10.6f %10.6f\n",coord[1],coord[2],coord[3]))
        end
        write(f,"end kpoints\n\n")
    end
    return nothing
end

write_win(prefix::String, scfres, num_wann::Integer; bands_plot=false, kwargs...) =
    write_win(prefix, scfres.basis, scfres.ψ, num_wann; bands_plot=bands_plot, kwargs...)


"""
Read the .nnkp file provided by the preprocessing routine of Wannier90
(i.e. "wannier90.x -pp prefix")
Returns:
1) the array 'nn_kpts' of k points, their respective nearest neighbors and associated
   shifing vectors (non zero if the neighbor of is located in another cell).
2) the number 'nn_num' of neighbors per k point.
2) the array 'projs' of projections. Each line contains the informations for one 
   projection :  [center],[quantum numbers: l,mr,r],[ref. z_axis],[ref. x_axis],α = Z/a
"""
function read_nnkp(prefix::String)

    # Check the presence of the file
    if !isfile("$prefix.nnkp")
        error("file $prefix.nnkp not found.")
    end

    # Read the file
    file = open("$prefix.nnkp", "r")
    @info "Reading nnkp file", file
    ln = [string(l) for l in eachline(file)]
    close(file)

    # Extract nnkp block
    i_nn_kpts = findall(x-> endswith(x,"nnkpts"),ln)  # 1st and last line of the block
    @assert size(i_nn_kpts,1) == 2
    nn_num = parse(Int,ln[i_nn_kpts[1]+1])          # number of neighbors per k points
    nn_kpts =  [parse.(Int,split(l,' ',keepempty = false))
                for l in ln[i_nn_kpts[1]+2:i_nn_kpts[2]-1] ]
    nn_kpts,nn_num
end


"""
Take scfres, the result of a self_consistent_field calculation and writes eigenvalues
(in eV) in a format readable by Wannier90.
"""
function write_eig(prefix::String, scfres)
    open("$prefix.eig", "w") do f
        for (k,e_k) in enumerate(scfres.eigenvalues)
            for (n,e_kn) in enumerate(e_k)
                # write(f,@sprintf("%3i  %3i   %25.18f \n",n,k,(1/DFTK.units.eV)*e_kn))
                write(f,@sprintf("%3i  %3i   %25.18f \n",n,k,auconvert(Unitful.eV,e_kn).val))
            end
        end
    end
    return nothing
end

@doc raw"""
 Computes the matrix ``[M^{k,b}]_{m,n} = \langle u_{m,k} | u_{n,k+b} \rangle``
 for given k, kpb = k+b.

 G_shift is the "shifting" vector, correction due to the periodicity conditions
 imposed on k -> ψ_k.
 It is non zero if kpb is taken in another unit cell of the reciprocal lattice.
 We use here that : ``u_{n(k + G_shift)}(r) = e^{-i*\langle G_shift,r \rangle} u_{nk}``
"""
function overlap_Mmn_k_kpb(basis::PlaneWaveBasis, ψ, ik::Integer, ikpb::Integer,
                           n_bands::Integer;
                           G_shift=[0,0,0])

    Mkb = zeros(ComplexF64,(n_bands,n_bands))
    # Search for common Fourier modes and their resp. indices in bloch states k and kpb
    k = basis.kpoints[ik]; kpb = basis.kpoints[ikpb] #renaming for clarity
    map_fourier_modes = [ (iGk,DFTK.index_G_vectors(basis, kpb, Gk+G_shift))
                          for (iGk,Gk) in enumerate(G_vectors(k))
                          if !isnothing(DFTK.index_G_vectors(basis,kpb,Gk+G_shift)) ]
    iGk = [i[1] for i in map_fourier_modes]   # TODO search for better structure than
    iGkpb = [i[2] for i in map_fourier_modes] # map_fourier_modes

    # Compute overlaps
    for n in 1:n_bands
        for m in 1:n_bands
            # Select the coefficient in right order
            Gk_coeffs = @view ψ[ik][iGk,m]
            Gkpb_coeffs = @view ψ[ikpb][iGkpb,n]
            Mkb[m,n] = dot(Gk_coeffs,Gkpb_coeffs)
        end
    end
    Mkb
end

"""
Iteratively use the preceding function on each k and kpb to generate the whole .mmn file.
"""
function write_mmn(prefix::String, basis::PlaneWaveBasis, ψ,
                           nn_kpts, nn_num::Integer)
    # general parameters
    n_bands = size(ψ[1],2)
    k_size = length(ψ)

    # Small function for the sake of clarity
    read_nn_kpts(n) = nn_kpts[n][1],nn_kpts[n][2],nn_kpts[n][3:end]

    # Write file
    open("$prefix.mmn", "w") do f
        write(f,"Generated by DFTK at $(now())\n")
        write(f,"$n_bands  $k_size  $nn_num\n")
        # Loop over all (k_points, nearest_neighbor, shif_vector)
        for i_nnkp in 1:size(nn_kpts,1)
            # Write the label of the matrix
            k,kpb,shift = read_nn_kpts(i_nnkp)
            write(f,@sprintf("%i  %i  %i  %i  %i \n",
                             k,kpb,shift[1],shift[2],shift[3]) )
            # The matrix itself
            Mkb = overlap_Mmn_k_kpb(basis, ψ, k, kpb, n_bands,; G_shift=shift)
            for ovlp in Mkb
                write(f, @sprintf("%22.18f %22.18f \n",real(ovlp),imag(ovlp)) )
            end
        end
    end
    return nothing
end

write_mmn(prefix::String, scfres, nn_kpts, nn_num) =
    write_mmn(prefix, scfres.basis, scfres.ψ, nn_kpts, nn_num)


@doc raw"""
Compute the matrix ``[A_k]_{m,n} = \langle ψ_m^k | g^{\text{per}}_n \rangle``

``g^{per}_n`` are periodized gaussians whose respective centers are given as an
 (n_bands,1) array [ [center 1], ... ].

Centers are to be given in lattice coordinates and G_vectors in reduced coordinates.
The dot product is computed in the Fourier space.

Given an orbital ``g_n``, the periodized orbital is defined by :
 ``g^{per}_n =  \sum\limits_{R \in {\rm lattice}} g_n( \cdot - R)``.
The  Fourier coefficient of ``g^{per}_n`` at any G
is given by the value of the Fourier transform of ``g_n`` in G.
"""
function compute_Ak_gaussian_guess(basis::PlaneWaveBasis, ψ_k, k_pt,
                                     n_bands::Integer, num_wann::Integer;
                                     centers=[])

    # associate a center with the fourier transform of the corresponding gaussian
    fourier_gn(center,qs) = [exp(-im*dot(q,center) - dot(q,q)/4) for q in qs]
    # All q = k+G in reduced coordinates (2π .*)
    q_vec = (2π) .*[G + k_pt.coordinate_cart for (iG,G) in enumerate(G_vectors(basis))]

    # Indices of the Fourier modes of the Bloch states in the general FFT_grid for given k
    index = [DFTK.index_G_vectors(basis,G) for G in G_vectors(k_pt)]
    Ak = zeros(eltype(ψ_k),(n_bands,num_wann))

    # Compute Ak
    for n in 1:num_wann
        center = basis.model.lattice*transpose(centers[n])
        # Functions are l^2 normalized in Fourier, in DFTK conventions.
        norm_gn_per = norm(fourier_gn(center,q_vec),2)
        # Fourier coeffs of gn_per for q_vectors in common with ψ_k
        coeffs_gn_per = fourier_gn(center,q_vec[index]) ./ norm_gn_per
        # Compute overlap
        for m in 1:n_bands
            coeffs_ψm = ψ_k[:,m]
            Ak[m,n] = dot(coeffs_ψm, coeffs_gn_per)
        end
    end
    Ak
end

"""
Use the preceding functions on every k to generate the .amn file
"""
function write_amn(prefix::String, basis::PlaneWaveBasis, ψ, num_wann::Integer;
                           centers=[])
    # Check if the right number of center is given
    @assert num_wann == size(centers, 1)
    # general parameters
    n_bands = size(ψ[1],2); k_size = size(ψ,1);

    # write file
    open("$prefix.amn", "w") do f
        # Header
        write(f,"Generated by DFTK at $(now())"*"\n")
        write(f,"$n_bands   $k_size   $num_wann \n")

        # Matrices
        for k in 1:k_size
            ψ_k = ψ[k]; k_pt = basis.kpoints[k];
            Ak = compute_Ak_gaussian_guess(basis, ψ_k, k_pt, n_bands, num_wann;
                              centers=centers)
            for n in 1:size(Ak,2)
                for m in 1:size(Ak,1)
                    write(f, @sprintf("%3i %3i %3i  %22.18f %22.18f \n",
                                     m, n, k, real(Ak[m,n]), imag(Ak[m,n])) )
                end
            end
        end
    end
    return nothing
end

write_amn(prefix, scfres, num_wann; centers=[]) =
    write_amn(prefix, scfres.basis, scfres.ψ, num_wann, centers=centers)

"""
   Random gaussian guess for MLWF used as default. Centers are generated in
   reduced coordinates (see notations and conventions).
"""
random_gaussian_guess(num_wann) = [rand(1,3) for i in 1:num_wann]

"""
    Wraps every step in a single routine by using the package wannier90_jll
"""
function run_wannier90(prefix::String, scfres, num_wann::Integer;
                       bands_plot=false,
                       centers=random_gaussian_guess(num_wann),
                       kwargs...)
    # Unfold scfres to retrieve full k-point list
    scfres_unfold = unfold_bz(scfres)
    # Write wannier90 input file and launch Wannier90 preprocessing task
    write_win(prefix, scfres_unfold, num_wann; bands_plot=bands_plot, kwargs...)
    wannier90() do exe
        run(`$exe -pp $prefix`)
    end

    # Generate eig, amn and mmn files
    nn_kpts, nn_num = read_nnkp(prefix)
    write_eig(prefix, scfres_unfold)
    write_amn(prefix, scfres_unfold, num_wann; centers=centers)
    write_mmn(prefix, scfres_unfold, nn_kpts, nn_num)

    # Launch wannierization
    wannier90() do exe
        @info "Wannier90 post-processing"
        run(`$exe $prefix`)
    end
    return nothing
end
