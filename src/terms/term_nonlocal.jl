# Functionality for building the non-local potential term
# and constructing the builder itself.

# Count the number of projection vectors implied by the potential array
# generated by term_nonlocal
function count_n_proj_(psp::PspHgh)
    psp.lmax < 0 ? 0 : sum(size(psp.h[l + 1], 1) * (2l + 1) for l in 0:psp.lmax)
end
function count_n_proj_(atoms)
    sum(count_n_proj_(psp)*length(positions) for (psp, positions) in atoms)
end


# Build projection coefficients for a atoms array generated by term_nonlocal
function build_projection_coefficients_(basis, atoms)
    # TODO In the current version the proj_coeffs still has a lot of zeros.
    #      One could improve this by storing the blocks as a list or in a
    #      BlockDiagonal data structure
    n_proj = count_n_proj_(atoms)
    proj_coeffs = zeros(n_proj, n_proj)

    count = 0
    for (psp, positions) in atoms, r in positions
        n_proj_psp = count_n_proj_(psp)
        proj_coeffs[count+1:count+n_proj_psp, count+1:count+n_proj_psp] = build_projection_coefficients_(psp)
        count += n_proj_psp
    end # psp, r
    @assert count == n_proj

    proj_coeffs
end
# Builds the projection coefficient matrix for a single atom
function build_projection_coefficients_(psp::PspHgh)
    n_proj = count_n_proj_(psp)
    proj_coeffs = zeros(n_proj, n_proj)
    count = 0
    for l in 0:psp.lmax, m in -l:l
        n_proj_l = size(psp.h[l + 1], 1)
        range = count .+ (1:n_proj_l)
        proj_coeffs[range, range] = psp.h[l + 1]
        count += n_proj_l
    end # l, m
    proj_coeffs
end


"""
Build projection vectors for a atoms array generated by term_nonlocal

H_at  = sum_ij Cij |pi> <pj|
H_per = sum_R sum_ij Cij |pi(x-R)> <pj(x-R)|
      = sum_R sum_ij Cij |pi(x-R)> <pj(x-R)|

<e_kG'|H_per|e_kG> = ...
                   = 1/Ω sum_ij Cij pihat(k+G') pjhat(k+G)^*

where pihat(q) = ∫_R^3 pi(r) e^{-iqr} dr

We store 1/√Ω pihat(k+G) in proj_vectors.
"""
build_projection_vectors_(basis, atoms, kpt)

# The doc system does not like memoize, so we document it above
@memoize function build_projection_vectors_(basis::PlaneWaveBasis, atoms, kpt::Kpoint)
    n_proj = count_n_proj_(atoms)
    model = basis.model
    T = eltype(basis.kpoints[1].coordinate)

    proj_vectors = zeros(Complex{T}, length(G_vectors(kpt)), n_proj)
    qs = [model.recip_lattice * (kpt.coordinate + G) for G in G_vectors(kpt)]
    qsqs = [sum(abs2, q) for q in qs]

    # Compute the columns of proj_vectors = 1/√Ω pihat(k+G)
    # Since the pi are translates of each others, pihat(k+G) decouples as
    # pihat(q) = ∫ p(r-R) e^{-iqr} dr = e^{-iqR} phat(q).
    # The first term is the structure factor, the second the form factor.
    offset = 0 # offset into proj_vectors
    for (psp, positions) in atoms
        # Compute position-independent form factors
        form_factors = build_form_factors(psp, qs)

        # Combine with structure factors
        for r in positions
            # k+G in this formula can also be G, this only changes an unimportant phase factor
            structure_factors = [cis(-2T(π)*dot(kpt.coordinate + G, r)) for G in G_vectors(kpt)]
            for iproj = 1:count_n_proj_(psp)
                proj_vectors[:, offset+iproj] = structure_factors .* form_factors[:, iproj]
            end
            offset += count_n_proj_(psp)
        end
    end
    @assert offset == n_proj

    proj_vectors ./ sqrt(model.unit_cell_volume)
end

"""
Build form factors (Fourier transforms of projectors) for an atom centered at 0.
"""
function build_form_factors(psp, qs)
    qsqs = [sum(abs2, q) for q in qs]
    T = real(eltype(qsqs))
    # Compute position-independent form factors
    form_factors = zeros(Complex{T}, length(qs), count_n_proj_(psp))
    count = 1
    for l in 0:psp.lmax, m in -l:l
        prefac_lm = im^l .* ylm_real.(l, m, qs)
        n_proj_l = size(psp.h[l + 1], 1)

        for iproj in 1:n_proj_l
            radial_il = eval_psp_projection_radial.(psp, iproj, l, qsqs)
            form_factors[:, count] = prefac_lm .* radial_il
            count += 1
        end
    end
    @assert count == count_n_proj_(psp) + 1
    form_factors
end

"""
    term_nonlocal(psp_or_atoms)

Return a representation of the non-local potential term in Kleinman-Bylander form.
`psp_or_atoms` are pairs mapping from a Pseudopotential object or a `Element` object
to a list of positions in fractional coordinates.

## Examples
```julia-repl
julia> psp = load_psp("hgh/lda/si-q4")
       nlpot = term_nonlocal(psp => [[0,0,0], [0,1/2,1/2]])
```
or similarly using a Element object
```julia-repl
julia> si = Element(14, psp=load_psp("hgh/lda/si-q4"))
       nlpot = term_nonlocal(si => [[0,0,0], [0,1/2,1/2]])
```
Of course multiple psps or species are possible:
```julia-repl
julia> si = Element(14, psp=load_psp("hgh/lda/si-q4"))
       c = Element(6, psp=load_psp("hgh/lda/c-q4"))
       nlpot = term_nonlocal(si => [[0,0,0]], c =>  [[0,1/2,1/2]])
```

Notice: If a species does not have an associated pseudopotential it will be silently
ignored by this function.
"""
function term_nonlocal(psps_or_atoms)
    # Function to extract the psp object in case the passed items are "Element"
    extract_psp(elem::Element) = elem.psp
    extract_psp(elem) = elem
    atoms = [extract_psp(elem) => positions
             for (elem, positions) in psps_or_atoms
             if extract_psp(elem) !== nothing]

    function inner(basis::PlaneWaveBasis, energy, potential; Psi=nothing,
                   occupation=nothing, kwargs...)
        potnl = PotNonLocal(basis, build_projection_coefficients_(basis, atoms),
                            kpt -> build_projection_vectors_(basis, atoms, kpt))
        if energy !== nothing
            energy[] = energy_term_operator(potnl, Psi, occupation)
        end
        energy, potnl
    end
    inner
end
