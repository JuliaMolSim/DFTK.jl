using Memoize

# Functionality for building the non-local potential term
# and constructing the builder itself.

# Count the number of projection vectors implied by the potential array
# generated by term_nonlocal
function count_n_proj_(potentials)
    n_proj = 0
    for (psp, positions) in potentials
        psp.lmax < 0 && continue  # No non-local projectors
        n_proj_psp = sum(size(psp.h[l + 1], 1) * (2l + 1) for l in 0:psp.lmax)
        n_proj += length(positions) * n_proj_psp
    end
    n_proj
end


# Build projection coefficients for a potentials array generated by term_nonlocal
function build_projection_coefficients_(basis, potentials)
    # TODO In the current version the proj_coeffs still has a lot of zeros.
    #      One could improve this by storing the blocks as a list or in a
    #      BlockDiagonal data structure
    n_proj = count_n_proj_(potentials)
    proj_coeffs = zeros(n_proj, n_proj)

    count = 0
    for (psp, positions) in potentials, r in positions
        for l in 0:psp.lmax, m in -l:l
            n_proj_l = size(psp.h[l + 1], 1)
            range = count .+ (1:n_proj_l)
            proj_coeffs[range, range] = psp.h[l + 1]
            count += n_proj_l
        end # l, m
    end # psp, r
    @assert count == n_proj

    proj_coeffs
end


"""
Build projection vectors for a potentials array generated by term_nonlocal

H_at  = sum_ij Cij |pi> <pj|
H_per = sum_R sum_ij Cij |pi(x-R)> <pj(x-R)|
      = sum_R sum_ij Cij |pi(x-R)> <pj(x-R)|

<e_kG'|H_per|e_kG> = ...
                   = 1/Ω sum_ij Cij pihat(k+G') pjhat(k+G)^*

where pihat(q) = ∫_R^3 pi(r) e^{-iqr}

We store 1/√Ω pihat(k+G) in proj_vectors.
"""
build_projection_vectors_(basis, potentials, kpt)

# The doc system does not like memoize, so we document it above
@memoize function build_projection_vectors_(basis::PlaneWaveBasis, potentials, kpt::Kpoint)
    n_proj = count_n_proj_(potentials)
    model = basis.model
    T = eltype(basis.kpoints[1].coordinate)

    proj_vectors = zeros(Complex{T}, length(kpt.basis), n_proj)
    qs = [model.recip_lattice * (kpt.coordinate + G) for G in kpt.basis]
    qsqs = [sum(abs2, q) for q in qs]

    count = 0
    for (psp, positions) in potentials, r in positions
            structure_factors = [cis(-2T(π) * dot(G, r)) for G in kpt.basis]
            radial_proj(iproj, l, qsq) = eval_psp_projection_radial(psp, iproj, l, qsq)

            for l in 0:psp.lmax, m in -l:l
                prefac_lm = im^l .* structure_factors .* ylm_real.(l, m, qs)
                n_proj_l = size(psp.h[l + 1], 1)

                for iproj in 1:n_proj_l
                    radial_il = radial_proj.(iproj, l, qsqs)
                    proj_vectors[:, count + iproj] = prefac_lm .* radial_il
                end # iproj

                count += n_proj_l
            end # l, m
    end # psp, r
    @assert count == n_proj

    proj_vectors ./ sqrt(model.unit_cell_volume)
end


"""
    term_nonlocal(psp_or_composition...)

Return a representation of the non-local potential term in Kleinman-Bylander form.
`psp_or_composition` are pairs mapping from a Pseudopotential object or a `Species` object
to a list of positions in fractional coordinates.

## Examples
```julia-repl
julia> psp = load_psp("si-pade-q4.hgh")
       nlpot = term_nonlocal(psp => [[0,0,0], [0,1/2,1/2]])
```
or similarly using a Species object
```julia-repl
julia> si = Species(14, psp=load_psp("si-pade-q4.hgh"))
       nlpot = term_nonlocal(si => [[0,0,0], [0,1/2,1/2]])
```
Of course multiple psps or species are possible:
```julia-repl
julia> si = Species(14, psp=load_psp("si-pade-q4.hgh"))
       c = Species(6, psp=load_psp("c-pade-q4.hgh"))
       nlpot = term_nonlocal(si => [[0,0,0]], c =>  [[0,1/2,1/2]])
```

Notice: If a species does not have an associated pseudopotential it will be silently
ignored by this function.
"""
function term_nonlocal(psps_or_composition...)
    # Function to extract the psp object in case the passed items are "Species"
    extract_psp(elem::Species) = elem.psp
    extract_psp(elem) = elem
    potentials = [extract_psp(elem) => positions
                  for (elem, positions) in psps_or_composition
                  if extract_psp(elem) !== nothing]

    function inner(basis::PlaneWaveBasis, energy, potential; Psi=nothing,
                   occupation=nothing, kwargs...)
        potnl = PotNonLocal(basis, build_projection_coefficients_(basis, potentials),
                            kpt -> build_projection_vectors_(basis, potentials, kpt))
        if energy !== nothing
            energy[] = energy_term_operator(potnl, Psi, occupation)
        end
        energy, potnl
    end
    inner
end
