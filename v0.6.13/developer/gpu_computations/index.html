<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU computations · DFTK.jl</title><meta name="title" content="GPU computations · DFTK.jl"/><meta property="og:title" content="GPU computations · DFTK.jl"/><meta property="twitter:title" content="GPU computations · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/developer/gpu_computations/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/developer/gpu_computations/"/><link rel="canonical" href="https://docs.dftk.org/stable/developer/gpu_computations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/installation/">Installation</a></li><li><a class="tocitem" href="../../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/periodic_problems/">Problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../../guide/introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../../examples/dielectric/">Eigenvalues of the dielectric matrix</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../examples/wannier90/">Wannierization using Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../setup/">Developer setup</a></li><li><a class="tocitem" href="../conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../data_structures/">Data structures</a></li><li><a class="tocitem" href="../useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../symmetries/">Crystal symmetries</a></li><li class="is-active"><a class="tocitem" href>GPU computations</a><ul class="internal"><li><a class="tocitem" href="#Current-implementation"><span>Current implementation</span></a></li><li><a class="tocitem" href="#Pitfalls"><span>Pitfalls</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li class="is-active"><a href>GPU computations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU computations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/developer/gpu_computations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GPU-computations"><a class="docs-heading-anchor" href="#GPU-computations">GPU computations</a><a id="GPU-computations-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-computations" title="Permalink"></a></h1><p>Performing GPU computations in DFTK is still work in progress. The goal is to build on Julia&#39;s multiple dispatch to have the same code base for CPU and GPU. Our current approach is to aim at decent performance without writing any custom kernels at all, relying only on the high level functionalities implemented in the GPU packages.</p><p>To go even further with this idea of unified code, we would also like to be able to support any type of GPU architecture: we do not want to hard-code the use of a specific architecture, say a NVIDIA CUDA GPU. DFTK does not realy on an architecture-specific package (<a href="https://github.com/JuliaGPU/CUDA.jl">CUDA</a>, <a href="https://github.com/JuliaGPU/AMDGPU.jl">ROCm</a>, <a href="https://github.com/JuliaGPU/oneAPI.jl">OneAPI</a>...) but rather uses <a href="https://github.com/JuliaGPU/GPUArrays.jl">GPUArrays</a>, which is the counterpart of <code>AbstractArray</code> but for GPU arrays.</p><h2 id="Current-implementation"><a class="docs-heading-anchor" href="#Current-implementation">Current implementation</a><a id="Current-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Current-implementation" title="Permalink"></a></h2><p>For now, GPU computations are done by specializing the <code>architecture</code> keyword argument when creating the basis. <code>architecture</code> should be an initialized instance of the (non-exported) <code>CPU</code> and <code>GPU</code> structures. <code>CPU</code> does not require any argument, but <code>GPU</code> requires the type of array which will be used for GPU computations.</p><pre><code class="language-julia hljs">PlaneWaveBasis(model; Ecut, kgrid, architecture = DFTK.CPU())
PlaneWaveBasis(model; Ecut, kgrid, architecture = DFTK.GPU(CuArray))</code></pre><div class="admonition is-info"><header class="admonition-header">GPU API is experimental</header><div class="admonition-body"><p>It is very likely that this API will change, based on the evolution of the Julia ecosystem concerning distributed architectures.</p></div></div><p>Not all terms can be used when doing GPU computations. As of January 2023 this concerns <code>Anyonic</code>, <code>Magnetic</code> and <code>TermPairwisePotential</code>. Similarly GPU features are not yet exhaustively tested, and it is likely that some aspects of the code such as automatic differentiation or stresses will not work.</p><h2 id="Pitfalls"><a class="docs-heading-anchor" href="#Pitfalls">Pitfalls</a><a id="Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Pitfalls" title="Permalink"></a></h2><p>There are a few things to keep in mind when doing GPU programming in DFTK.</p><ul><li>Transfers to and from a device can be done simply by converting an array to</li></ul><p>an other type. However, hard-coding the new array type (such as writing <code>CuArray(A)</code> to move <code>A</code> to a CUDA GPU) is not cross-architecture, and can be confusing for developers working only on the CPU code. These data transfers should be done using the helper functions <code>to_device</code> and <code>to_cpu</code> which provide a level of abstraction while also allowing multiple architectures to be used.</p><pre><code class="language-julia hljs">cuda_gpu = DFTK.GPU(CuArray)
cpu_architecture = DFTK.CPU()
A = rand(10)  # A is on the CPU
B = DFTK.to_device(cuda_gpu, A)  # B is a copy of A on the CUDA GPU
B .+= 1.
C = DFTK.to_cpu(B)  # C is a copy of B on the CPU
D = DFTK.to_device(cpu_architecture, B)  # Equivalent to the previous line, but
                                         # should be avoided as it is less clear</code></pre><p><em>Note:</em> <code>similar</code> could also be used, but then a reference array (one which already lives on the device) needs to be available at call time. This was done previously, with helper functions to easily build new arrays on a given architecture: see for example <a href="https://github.com/JuliaMolSim/DFTK.jl/pull/711/commits/ce5da66009440bd8552429eb8cfe96944da16564"><code>zeros_like</code></a>.</p><ul><li>Functions which will get executed on the GPU should always have arguments</li></ul><p>which are <code>isbits</code> (immutable and contains no references to other values). When using <code>map</code>, also make sure that every structure used is also <code>isbits</code>. For example, the following map will fail, as <code>model</code> contains strings and arrays which are not <code>isbits</code>.</p><pre><code class="language-julia hljs">function map_lattice(model::Model, Gs::AbstractArray{Vec3})
    # model is not isbits
    map(Gs) do Gi
        model.lattice * Gi
    end
end</code></pre><p>However, the following map will run on a GPU, as the lattice is a static matrix.</p><pre><code class="language-julia hljs">function map_lattice(model::Model, Gs::AbstractArray{Vec3})
    lattice = model.lattice # lattice is isbits
    map(Gs) do Gi
        model.lattice * Gi
    end
end</code></pre><ul><li>List comprehensions should be avoided, as they always return a CPU <code>Array</code>.</li></ul><p>Instead, we should use <code>map</code> which returns an array of the same type as the input one.</p><ul><li>Sometimes, creating a new array or making a copy can be necessary to achieve good</li></ul><p>performance. For example, iterating through the columns of a matrix to compute their norms is not efficient, as a new kernel is launched for every column. Instead, it is better to build the vector containing these norms, as it is a vectorized operation and will be much faster on the GPU.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../symmetries/">« Crystal symmetries</a><a class="docs-footer-nextpage" href="../../api/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 20 November 2023 22:02">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
