<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · DFTK.jl</title><meta name="title" content="API reference · DFTK.jl"/><meta property="og:title" content="API reference · DFTK.jl"/><meta property="twitter:title" content="API reference · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/api/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/api/"/><link rel="canonical" href="https://docs.dftk.org/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../guide/installation/">Installation</a></li><li><a class="tocitem" href="../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../guide/periodic_problems/">Problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../guide/introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../examples/dielectric/">Eigenvalues of the dielectric matrix</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../examples/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../examples/compare_solvers/">Comparison of DFT solvers</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../developer/setup/">Developer setup</a></li><li><a class="tocitem" href="../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../developer/gpu_computations/">GPU computations</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This page provides a plain list of all documented functions, structs, modules and macros in DFTK. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.timer" href="#DFTK.timer"><code>DFTK.timer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>TimerOutput object used to store DFTK timings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/timer.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AbstractArchitecture" href="#DFTK.AbstractArchitecture"><code>DFTK.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for architectures supported by DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/architecture.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AdaptiveBands" href="#DFTK.AdaptiveBands"><code>DFTK.AdaptiveBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dynamically adapt number of bands to be converged to ensure that the orbitals of lowest occupation are occupied to at most <code>occupation_threshold</code>. To obtain rapid convergence of the eigensolver a gap between the eigenvalues of the last occupied orbital and the last computed (but not converged) orbital of <code>gap_min</code> is ensured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/nbands_algorithm.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AdaptiveDiagtol" href="#DFTK.AdaptiveDiagtol"><code>DFTK.AdaptiveDiagtol</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Algorithm for the tolerance used for the next diagonalization. This function takes <span>$|ρnext - ρin|$</span> and multiplies it with <code>ratio_ρdiff</code> to get the next <code>diagtol</code>, ensuring additionally that the returned value is between <code>diagtol_min</code> and <code>diagtol_max</code> and never increases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Applyχ0Model" href="#DFTK.Applyχ0Model"><code>DFTK.Applyχ0Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Full χ0 application, optionally dropping terms or disabling Sternheimer. All keyword arguments passed to <a href="#DFTK.apply_χ0-Union{Tuple{TδV}, Tuple{T}, Tuple{Any, Any, Any, T, Any, AbstractArray{TδV}}} where {T, TδV}"><code>apply_χ0</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/chi0models.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AtomicLocal" href="#DFTK.AtomicLocal"><code>DFTK.AtomicLocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Atomic local potential defined by <code>model.atoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/local.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.AtomicNonlocal" href="#DFTK.AtomicNonlocal"><code>DFTK.AtomicNonlocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal term coming from norm-conserving pseudopotentials in Kleinmann-Bylander form. <span>$\text{Energy} = \sum_a \sum_{ij} \sum_{n} f_n &lt;ψ_n|p_{ai}&gt; D_{ij} &lt;p_{aj}|ψ_n&gt;.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/nonlocal.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupAbinit" href="#DFTK.BlowupAbinit"><code>DFTK.BlowupAbinit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as used in Abinit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/kinetic.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupCHV" href="#DFTK.BlowupCHV"><code>DFTK.BlowupCHV</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as proposed in https://arxiv.org/abs/2210.00442 The blow-up order of the function is fixed to ensure C^2 regularity of the energies bands away from crossings and Lipschitz continuity at crossings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/kinetic.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.BlowupIdentity" href="#DFTK.BlowupIdentity"><code>DFTK.BlowupIdentity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default blow-up corresponding to the standard kinetic energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/kinetic.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DielectricMixing" href="#DFTK.DielectricMixing"><code>DFTK.DielectricMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We use a simplification of the Resta model DOI 10.1103/physrevb.16.2717 and set <span>$χ_0(q) = \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)}$</span> where <span>$C_0 = 1 - ε_r$</span> with <span>$ε_r$</span> being the macroscopic relative permittivity. We neglect <span>$K_\text{xc}$</span>, such that <span>$J^{-1} ≈ \frac{k_{TF}^2 - C_0 G^2}{ε_r k_{TF}^2 - C_0 G^2}$</span></p><p>By default it assumes a relative permittivity of 10 (similar to Silicon). <code>εr == 1</code> is equal to <code>SimpleMixing</code> and <code>εr == Inf</code> to <code>KerkerMixing</code>. The mixing is applied to <span>$ρ$</span> and <span>$ρ_\text{spin}$</span> in the same way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DielectricModel" href="#DFTK.DielectricModel"><code>DFTK.DielectricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A localised dielectric model for <span>$χ_0$</span>:</p><p class="math-container">\[\sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <code>L(r)</code> is a real-space localization function and otherwise the same conventions are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/chi0models.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.DivAgradOperator" href="#DFTK.DivAgradOperator"><code>DFTK.DivAgradOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal &quot;divAgrad&quot; operator <span>$-½ ∇ ⋅ (A ∇)$</span> where <span>$A$</span> is a scalar field on the real-space grid. The <span>$-½$</span> is included, such that this operator is a generalisation of the kinetic energy operator (which is obtained for <span>$A=1$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementCohenBergstresser-Tuple{Any}" href="#DFTK.ElementCohenBergstresser-Tuple{Any}"><code>DFTK.ElementCohenBergstresser</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementCohenBergstresser(
    key;
    lattice_constant
) -&gt; ElementCohenBergstresser
</code></pre><p>Element where the interaction with electrons is modelled as in <a href="https://doi.org/10.1103/PhysRev.141.789">CohenBergstresser1966</a>. Only the homonuclear lattices of the diamond structure are implemented (i.e. Si, Ge, Sn).</p><p><code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementCoulomb-Tuple{Any}" href="#DFTK.ElementCoulomb-Tuple{Any}"><code>DFTK.ElementCoulomb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementCoulomb(key; mass) -&gt; ElementCoulomb
</code></pre><p>Element interacting with electrons via a bare Coulomb potential (for all-electron calculations) <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementGaussian-Tuple{Any, Any}" href="#DFTK.ElementGaussian-Tuple{Any, Any}"><code>DFTK.ElementGaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementGaussian(α, L; symbol) -&gt; ElementGaussian
</code></pre><p>Element interacting with electrons via a Gaussian potential. Symbol is non-mandatory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ElementPsp-Tuple{Any}" href="#DFTK.ElementPsp-Tuple{Any}"><code>DFTK.ElementPsp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ElementPsp(key; psp, mass)
</code></pre><p>Element interacting with electrons via a pseudopotential model. <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Energies" href="#DFTK.Energies"><code>DFTK.Energies</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple struct to contain a vector of energies, and utilities to print them in a nice format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Energies.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Entropy" href="#DFTK.Entropy"><code>DFTK.Entropy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Entropy term -TS, where S is the electronic entropy. Turns the energy E into the free energy F=E-TS. This is in particular useful because the free energy, not the energy, is minimized at self-consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/entropy.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Ewald" href="#DFTK.Ewald"><code>DFTK.Ewald</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Ewald term: electrostatic energy per unit cell of the array of point charges defined by <code>model.atoms</code> in a uniform background of compensating charge yielding net neutrality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/ewald.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExplicitKpoints" href="#DFTK.ExplicitKpoints"><code>DFTK.ExplicitKpoints</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Explicitly define the k-points along which to perform BZ sampling. (Useful for bandstructure calculations)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromFourier" href="#DFTK.ExternalFromFourier"><code>DFTK.ExternalFromFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from the (unnormalized) Fourier coefficients <code>V(G)</code> G is passed in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/local.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromReal" href="#DFTK.ExternalFromReal"><code>DFTK.ExternalFromReal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from an analytic function <code>V</code> (in cartesian coordinates). No low-pass filtering is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/local.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ExternalFromValues" href="#DFTK.ExternalFromValues"><code>DFTK.ExternalFromValues</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential given as values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/local.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FermiTwoStage" href="#DFTK.FermiTwoStage"><code>DFTK.FermiTwoStage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Two-stage Fermi level finding algorithm starting from a Gaussian-smearing guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/occupation.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FixedBands" href="#DFTK.FixedBands"><code>DFTK.FixedBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>In each SCF step converge exactly <code>n_bands_converge</code>, computing along the way exactly <code>n_bands_compute</code> (usually a few more to ease convergence in systems with small gaps).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/nbands_algorithm.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.FourierMultiplication" href="#DFTK.FourierMultiplication"><code>DFTK.FourierMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Fourier space multiplication, like a kinetic energy term: (Hψ)(G) = multiplier(G) ψ(G).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray" href="#DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray"><code>DFTK.GPU</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a particular GPU architecture by passing the ArrayType</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/architecture.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.GaussianWannierProjection" href="#DFTK.GaussianWannierProjection"><code>DFTK.GaussianWannierProjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Gaussian-shaped initial guess. Can be used as an approximation of an s- or σ-like orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Hartree" href="#DFTK.Hartree"><code>DFTK.Hartree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Hartree term: for a decaying potential V the energy would be</p><p>1/2 ∫ρ(x)ρ(y)V(x-y) dxdy</p><p>with the integral on x in the unit cell and of y in the whole space. For the Coulomb potential with periodic boundary conditions, this is rather</p><p>1/2 ∫ρ(x)ρ(y) G(x-y) dx dy</p><p>where G is the Green&#39;s function of the periodic Laplacian with zero mean (-Δ G = sum<em>{R} 4π δ</em>R, integral of G zero on a unit cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/hartree.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.HydrogenicWannierProjection" href="#DFTK.HydrogenicWannierProjection"><code>DFTK.HydrogenicWannierProjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A hydrogenic initial guess.</p><p><code>α</code> is the diffusivity, <span>$\frac{Z}/{a}$</span> where <span>$Z$</span> is the atomic number and     <span>$a$</span> is the Bohr radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.KerkerDosMixing" href="#DFTK.KerkerDosMixing"><code>DFTK.KerkerDosMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The same as <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, but the Thomas-Fermi wavevector is computed from the current density of states at the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.KerkerMixing" href="#DFTK.KerkerMixing"><code>DFTK.KerkerMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kerker mixing: <span>$J^{-1} ≈ \frac{|G|^2}{k_{TF}^2 + |G|^2}$</span> where <span>$k_{TF}$</span> is the Thomas-Fermi wave vector. For spin-polarized calculations by default the spin density is not preconditioned. Unless a non-default value for <span>$ΔDOS_Ω$</span> is specified. This value should roughly be the expected difference in density of states (per unit volume) between spin-up and spin-down.</p><p>Notes:</p><ul><li>Abinit calls <span>$1/k_{TF}$</span> the dielectric screening length (parameter <em>dielng</em>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Kinetic" href="#DFTK.Kinetic"><code>DFTK.Kinetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kinetic energy: 1/2 sum<em>n f</em>n ∫ |∇ψn|^2 * blowup(-i∇Ψ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/kinetic.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Kpoint" href="#DFTK.Kpoint"><code>DFTK.Kpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discretization information for <span>$k$</span>-point-dependent quantities such as orbitals. More generally, a <span>$k$</span>-point is a block of the Hamiltonian; eg collinear spin is treated by doubling the number of kpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LazyHcat" href="#DFTK.LazyHcat"><code>DFTK.LazyHcat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple wrapper to represent a matrix formed by the concatenation of column blocks: it is mostly equivalent to hcat, but doesn&#39;t allocate the full matrix. LazyHcat only supports a few multiplication routines: furthermore, a multiplication involving this structure will always yield a plain array (and not a LazyHcat structure). LazyHcat is a lightweight subset of BlockArrays.jl&#39;s functionalities, but has the advantage to be able to store GPU Arrays (BlockArrays is heavily built on Julia&#39;s CPU Array).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/eigen/lobpcg_hyper_impl.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LdosModel" href="#DFTK.LdosModel"><code>DFTK.LdosModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the LDOS-based <span>$χ_0$</span> model</p><p class="math-container">\[χ_0(r, r&#39;) = (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states and <span>$D$</span> the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/chi0models.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}" href="#DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}"><code>DFTK.LibxcDensities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LibxcDensities(
    basis,
    max_derivative::Integer,
    ρ,
    τ
) -&gt; DFTK.LibxcDensities
</code></pre><p>Compute density in real space and its derivatives starting from ρ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/xc.jl#L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LocalNonlinearity" href="#DFTK.LocalNonlinearity"><code>DFTK.LocalNonlinearity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Local nonlinearity, with energy ∫f(ρ) where ρ is the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/local_nonlinearity.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Magnetic" href="#DFTK.Magnetic"><code>DFTK.Magnetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic term <span>$A⋅(-i∇)$</span>. It is assumed (but not checked) that <span>$∇⋅A = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/magnetic.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.MagneticFieldOperator" href="#DFTK.MagneticFieldOperator"><code>DFTK.MagneticFieldOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic field operator A⋅(-i∇).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Tuple{AtomsBase.AbstractSystem}" href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(system::AbstractSystem; kwargs...)</code></pre><p>AtomsBase-compatible Model constructor. Sets structural information (<code>atoms</code>, <code>positions</code>, <code>lattice</code>, <code>n_electrons</code> etc.) from the passed <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(lattice, atoms, positions; n_electrons, magnetic_moments, terms, temperature,
      smearing, spin_polarization, symmetries)</code></pre><p>Creates the physical specification of a model (without any discretization information).</p><p><code>n_electrons</code> is taken from <code>atoms</code> if not specified.</p><p><code>spin_polarization</code> is :none by default (paired electrons) unless any of the elements has a non-zero initial magnetic moment. In this case the spin_polarization will be :collinear.</p><p><code>magnetic_moments</code> is only used to determine the symmetry and the <code>spin_polarization</code>; it is not stored inside the datastructure.</p><p><code>smearing</code> is Fermi-Dirac if <code>temperature</code> is non-zero, none otherwise</p><p>The <code>symmetries</code> kwarg allows (a) to pass <code>true</code> / <code>false</code> to enable / disable the automatic determination of lattice symmetries or (b) to pass an explicit list of symmetry operations to use for lowering the computational effort. The default behaviour is equal to <code>true</code>, namely that the code checks the specified model in form of the Hamiltonian <code>terms</code>, <code>lattice</code>, <code>atoms</code> and <code>magnetic_moments</code> parameters and from these automatically determines a set of symmetries it can safely use. If you want to pass custom symmetry operations (e.g. a reduced or extended set) use the <code>symmetry_operations</code> function. Notice that this may lead to wrong results if e.g. the external potential breaks some of the passed symmetries. Use <code>false</code> to turn off symmetries completely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Model-Union{Tuple{Model}, Tuple{T}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{Model}, Tuple{T}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(model; [lattice, positions, atoms, kwargs...])
Model{T}(model; [lattice, positions, atoms, kwargs...])</code></pre><p>Construct an identical model to <code>model</code> with the option to change some of the contained parameters. This constructor is useful for changing the data type in the model or for changing <code>lattice</code> or <code>positions</code> in geometry/lattice optimisations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.MonkhorstPack" href="#DFTK.MonkhorstPack"><code>DFTK.MonkhorstPack</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Perform BZ sampling employing a Monkhorst-Pack grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NbandsAlgorithm" href="#DFTK.NbandsAlgorithm"><code>DFTK.NbandsAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NbandsAlgorithm subtypes determine how many bands to compute and converge in each SCF step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/nbands_algorithm.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NonlocalOperator" href="#DFTK.NonlocalOperator"><code>DFTK.NonlocalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal operator in Fourier space in Kleinman-Bylander format, defined by its projectors P matrix and coupling terms D: Hψ = PDP&#39; ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.NoopOperator" href="#DFTK.NoopOperator"><code>DFTK.NoopOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Noop operation: don&#39;t do anything. Useful for energy terms that don&#39;t depend on the orbitals at all (eg nuclei-nuclei interaction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PairwisePotential-Tuple{Any, Any}" href="#DFTK.PairwisePotential-Tuple{Any, Any}"><code>DFTK.PairwisePotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PairwisePotential(
    V,
    params;
    max_radius
) -&gt; PairwisePotential
</code></pre><p>Pairwise terms: Pairwise potential between nuclei, e.g., Van der Waals potentials, such as Lennard—Jones terms. The potential is dependent on the distance between to atomic positions and the pairwise atomic types: For a distance <code>d</code> between to atoms <code>A</code> and <code>B</code>, the potential is <code>V(d, params[(A, B)])</code>. The parameters <code>max_radius</code> is of <code>100</code> by default, and gives the maximum distance (in Cartesian coordinates) between nuclei for which we consider interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/pairwise.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A plane-wave discretized <code>Model</code>. Normalization conventions:</p><ul><li>Things that are expressed in the G basis are normalized so that if <span>$x$</span> is the vector, then the actual function is <span>$\sum_G x_G e_G$</span> with <span>$e_G(x) = e^{iG x} / \sqrt(\Omega)$</span>, where <span>$\Omega$</span> is the unit cell volume. This is so that, eg <span>$norm(ψ) = 1$</span> gives the correct normalization. This also holds for the density and the potentials.</li><li>Quantities expressed on the real-space grid are in actual values.</li></ul><p><code>ifft</code> and <code>fft</code> convert between these representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, DFTK.AbstractKgrid}" href="#DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, DFTK.AbstractKgrid}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a new basis identical to <code>basis</code>, but with a new k-point grid, e.g. an <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> or a <a href="#DFTK.ExplicitKpoints"><code>ExplicitKpoints</code></a> grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Union{Tuple{Model{T}}, Tuple{T}} where T&lt;:Real" href="#DFTK.PlaneWaveBasis-Union{Tuple{Model{T}}, Tuple{T}} where T&lt;:Real"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a <code>PlaneWaveBasis</code> using the kinetic energy cutoff <code>Ecut</code> and a k-point grid. By default a <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> grid is employed, which can be specified as a <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> object or by simply passing a vector of three integers as the <code>kgrid</code>. Optionally <code>kshift</code> allows to specify a shift (0 or 1/2 in each direction). If not specified a grid is generated using <code>kgrid_from_maximal_spacing</code> with a maximal spacing of <code>2π * 0.022</code> per Bohr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PreconditionerNone" href="#DFTK.PreconditionerNone"><code>DFTK.PreconditionerNone</code></a> — <span class="docstring-category">Type</span></header><section><div><p>No preconditioning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/eigen/preconditioners.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PreconditionerTPA" href="#DFTK.PreconditionerTPA"><code>DFTK.PreconditionerTPA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(simplified version of) Tetter-Payne-Allan preconditioning ↑ M.P. Teter, M.C. Payne and D.C. Allan, Phys. Rev. B 40, 12255 (1989).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/eigen/preconditioners.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspCorrection" href="#DFTK.PspCorrection"><code>DFTK.PspCorrection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pseudopotential correction energy. TODO discuss the need for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/psp_correction.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspHgh-Tuple{Any}" href="#DFTK.PspHgh-Tuple{Any}"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspHgh(path[, identifier, description])</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998) from file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspHgh.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.PspUpf-Tuple{Any}" href="#DFTK.PspUpf-Tuple{Any}"><code>DFTK.PspUpf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspUpf(path[, identifier])</code></pre><p>Construct a Unified Pseudopotential Format pseudopotential from file.</p><p>Does not support:</p><ul><li>Fully-realtivistic / spin-orbit pseudos</li><li>Bare Coulomb / all-electron potentials</li><li>Semilocal potentials</li><li>Ultrasoft potentials</li><li>Projector-augmented wave potentials</li><li>GIPAW reconstruction data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspUpf.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.RealFourierOperator" href="#DFTK.RealFourierOperator"><code>DFTK.RealFourierOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Linear operators that act on tuples (real, fourier) The main entry point is <code>apply!(out, op, in)</code> which performs the operation out += op*in where out and in are named tuples (real, fourier) They also implement mul! and Matrix(op) for exploratory use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.RealSpaceMultiplication" href="#DFTK.RealSpaceMultiplication"><code>DFTK.RealSpaceMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Real space multiplication by a potential: (Hψ)(r) = V(r) ψ(r).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/operators.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceDensity" href="#DFTK.ScfConvergenceDensity"><code>DFTK.ScfConvergenceDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag convergence by using the L2Norm of the density change in one SCF step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceEnergy" href="#DFTK.ScfConvergenceEnergy"><code>DFTK.ScfConvergenceEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag convergence as soon as total energy change drops below a tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfConvergenceForce" href="#DFTK.ScfConvergenceForce"><code>DFTK.ScfConvergenceForce</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag convergence on the change in cartesian force between two iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfDefaultCallback" href="#DFTK.ScfDefaultCallback"><code>DFTK.ScfDefaultCallback</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default callback function for <code>self_consistent_field</code> methods, which prints a convergence table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfSaveCheckpoints" href="#DFTK.ScfSaveCheckpoints"><code>DFTK.ScfSaveCheckpoints</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Adds checkpointing to a DFTK self-consistent field calculation. The checkpointing file is silently overwritten. Requires the package for writing the output file (usually JLD2) to be loaded.</p><ul><li><code>filename</code>: Name of the checkpointing file.</li><li><code>compress</code>: Should compression be used on writing (rarely useful)</li><li><code>save_ψ</code>:   Should the bands also be saved (noteworthy additional cost ... use carefully)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_callbacks.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.SimpleMixing" href="#DFTK.SimpleMixing"><code>DFTK.SimpleMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple mixing: <span>$J^{-1} ≈ 1$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.TermNoop" href="#DFTK.TermNoop"><code>DFTK.TermNoop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with a constant zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/terms.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Xc" href="#DFTK.Xc"><code>DFTK.Xc</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Exchange-correlation term, defined by a list of functionals and usually evaluated through libxc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/xc.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.χ0Mixing" href="#DFTK.χ0Mixing"><code>DFTK.χ0Mixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Generic mixing function using a model for the susceptibility composed of the sum of the <code>χ0terms</code>. For valid <code>χ0terms</code> See the subtypes of <code>χ0Model</code>. The dielectric model is solved in real space using a GMRES. Either the full kernel (<code>RPA=false</code>) or only the Hartree kernel (<code>RPA=true</code>) are employed. <code>verbose=true</code> lets the GMRES run in verbose mode (useful for debugging).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.fft!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fft!(
    f_fourier::AbstractArray{T, 3} where T,
    basis::PlaneWaveBasis,
    f_real::AbstractArray{T, 3} where T
) -&gt; Any
</code></pre><p>In-place version of <code>fft!</code>. NOTE: If <code>kpt</code> is given, not only <code>f_fourier</code> but also <code>f_real</code> is overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}" href="#AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fft(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    f_real::AbstractArray{U}
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">fft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_real)</code></pre><p>Perform an FFT to obtain the Fourier representation of <code>f_real</code>. If <code>kpt</code> is given, the coefficients are truncated to the k-dependent spherical basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.ifft!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifft!(
    f_real::AbstractArray{T, 3} where T,
    basis::PlaneWaveBasis,
    f_fourier::AbstractArray{T, 3} where T
) -&gt; Any
</code></pre><p>In-place version of <code>ifft</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}" href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>AbstractFFTs.ifft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifft(basis::PlaneWaveBasis, f_fourier::AbstractArray) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">ifft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_fourier)</code></pre><p>Perform an iFFT to obtain the quantity defined by <code>f_fourier</code> defined on the k-dependent spherical basis set (if <code>kpt</code> is given) or the k-independent cubic (if it is not) on the real-space grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.atomic_mass-Tuple{DFTK.Element}" href="#AtomsBase.atomic_mass-Tuple{DFTK.Element}"><code>AtomsBase.atomic_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomic_mass(el::DFTK.Element)
</code></pre><p>Return the atomic mass of an atom type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.atomic_symbol-Tuple{DFTK.Element}" href="#AtomsBase.atomic_symbol-Tuple{DFTK.Element}"><code>AtomsBase.atomic_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atomic_symbol(_::DFTK.Element) -&gt; Symbol
</code></pre><p>Chemical symbol corresponding to an element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.atomic_system" href="#AtomsBase.atomic_system"><code>AtomsBase.atomic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atomic_system(
    lattice::AbstractMatrix{&lt;:Number},
    atoms::Vector{&lt;:DFTK.Element},
    positions::AbstractVector
) -&gt; AtomsBase.FlexibleSystem
atomic_system(
    lattice::AbstractMatrix{&lt;:Number},
    atoms::Vector{&lt;:DFTK.Element},
    positions::AbstractVector,
    magnetic_moments::AbstractVector
) -&gt; AtomsBase.FlexibleSystem
</code></pre><pre><code class="nohighlight hljs">atomic_system(model::DFTK.Model, magnetic_moments=[])
atomic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/atomsbase.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AtomsBase.periodic_system" href="#AtomsBase.periodic_system"><code>AtomsBase.periodic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">periodic_system(model::Model) -&gt; AtomsBase.FlexibleSystem
periodic_system(
    model::Model,
    magnetic_moments
) -&gt; AtomsBase.FlexibleSystem
</code></pre><pre><code class="nohighlight hljs">periodic_system(model::DFTK.Model, magnetic_moments=[])
periodic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/atomsbase.jl#L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Brillouin.KPaths.irrfbz_path" href="#Brillouin.KPaths.irrfbz_path"><code>Brillouin.KPaths.irrfbz_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">irrfbz_path(model::Model) -&gt; Brillouin.KPaths.KPath
irrfbz_path(
    model::Model,
    magnetic_moments;
    dim,
    space_group_number
) -&gt; Brillouin.KPaths.KPath
</code></pre><p>Extract the high-symmetry <span>$k$</span>-point path corresponding to the passed <code>model</code> using <code>Brillouin</code>. Uses the conventions described in the reference work by Cracknell, Davies, Miller, and Love (CDML). Of note, this has minor differences to the <span>$k$</span>-path reference (<a href="https://doi.org/10.1016/j.commatsci.2016.10.015">Y. Himuma et. al. Comput. Mater. Sci. <strong>128</strong>, 140 (2017)</a>) underlying the path-choices of <code>Brillouin.jl</code>, specifically for oA and mC Bravais types.</p><p>If the cell is a supercell of a smaller primitive cell, the standard <span>$k$</span>-path of the associated primitive cell is returned. So, the high-symmetry <span>$k$</span> points are those of the primitive cell Brillouin zone, not those of the supercell Brillouin zone.</p><p>The <code>dim</code> argument allows to artificially truncate the dimension of the employed model, e.g. allowing to plot a 2D bandstructure of a 3D model (useful for example for plotting band structures of sheets with <code>dim=2</code>).</p><p>Due to lacking support in <code>Spglib.jl</code> for two-dimensional lattices it is (a) assumed that <code>model.lattice</code> is a <em>conventional</em> lattice and (b) required to pass the space group number using the <code>space_group_number</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.CROP" href="#DFTK.CROP"><code>DFTK.CROP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CROP(
    f,
    x0,
    m::Int64,
    max_iter::Int64,
    tol::Real
) -&gt; NamedTuple{(:fixpoint, :converged), _A} where _A&lt;:Tuple{Any, Any}
CROP(
    f,
    x0,
    m::Int64,
    max_iter::Int64,
    tol::Real,
    warming
) -&gt; NamedTuple{(:fixpoint, :converged), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>CROP-accelerated root-finding iteration for <code>f</code>, starting from <code>x0</code> and keeping a history of <code>m</code> steps. Optionally <code>warming</code> specifies the number of non-accelerated steps to perform for warming up the history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_solvers.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors(
    basis::PlaneWaveBasis
) -&gt; AbstractArray{StaticArraysCore.SVector{3, Int64}, 3}
</code></pre><pre><code class="nohighlight hljs">G_vectors(basis::PlaneWaveBasis)
G_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of wave vectors <span>$G$</span> in reduced (integer) coordinates of a <code>basis</code> or a <span>$k$</span>-point <code>kpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L416">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}" href="#DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors(fft_size::Union{Tuple, AbstractVector}) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">G_vectors([architecture=AbstractArchitecture], fft_size::Tuple)</code></pre><p>The wave vectors <code>G</code> in reduced (integer) coordinates for a cubic basis set of given sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors_cart(basis::PlaneWaveBasis) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">G_vectors_cart(basis::PlaneWaveBasis)
G_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G$</span> vectors of a given <code>basis</code> or <code>kpt</code>, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L428">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors(basis::PlaneWaveBasis, kpt::Kpoint) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">Gplusk_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors_cart(
    basis::PlaneWaveBasis,
    kpt::Kpoint
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">Gplusk_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_in_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors_in_supercell(
    basis::PlaneWaveBasis,
    basis_supercell::PlaneWaveBasis,
    kpt::Kpoint
) -&gt; Any
</code></pre><p>Maps all <span>$k+G$</span> vectors of an given basis as <span>$G$</span> vectors of the supercell basis, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/supercell.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.HybridMixing-Tuple{}" href="#DFTK.HybridMixing-Tuple{}"><code>DFTK.HybridMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HybridMixing(
;
    εr,
    kTF,
    localization,
    adjust_temperature,
    kwargs...
) -&gt; χ0Mixing
</code></pre><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D) \\
    &amp;+ \sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}
\end{aligned}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states and the same convention for parameters are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Additionally there is the real-space localization function <code>L(r)</code>. For details see Herbst, Levitt 2020 arXiv:2009.01665</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.IncreaseMixingTemperature-Tuple{}" href="#DFTK.IncreaseMixingTemperature-Tuple{}"><code>DFTK.IncreaseMixingTemperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IncreaseMixingTemperature(
;
    factor,
    above_ρdiff,
    temperature_max
) -&gt; DFTK.var&quot;#callback#686&quot;{DFTK.var&quot;#callback#685#687&quot;{Int64, Float64}}
</code></pre><p>Increase the temperature used for computing the SCF preconditioners. Initially the temperature is increased by a <code>factor</code>, which is then smoothly lowered towards the temperature used within the model as the SCF converges. Once the density change is below <code>above_ρdiff</code> the mixing temperature is equal to the model temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.LdosMixing-Tuple{}" href="#DFTK.LdosMixing-Tuple{}"><code>DFTK.LdosMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LdosMixing(; adjust_temperature, kwargs...) -&gt; χ0Mixing
</code></pre><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)
\end{aligned}\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665.</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/mixing.jl#L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ScfAcceptImprovingStep-Tuple{}" href="#DFTK.ScfAcceptImprovingStep-Tuple{}"><code>DFTK.ScfAcceptImprovingStep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ScfAcceptImprovingStep(
;
    max_energy_change,
    max_relative_residual
) -&gt; DFTK.var&quot;#accept_step#773&quot;{Float64, Float64}
</code></pre><p>Accept a step if the energy is at most increasing by <code>max_energy</code> and the residual is at most <code>max_relative_residual</code> times the residual in the previous step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/potential_mixing.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_K-Tuple{PlaneWaveBasis, Vararg{Any, 4}}" href="#DFTK.apply_K-Tuple{PlaneWaveBasis, Vararg{Any, 4}}"><code>DFTK.apply_K</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_K(basis::PlaneWaveBasis, δψ, ψ, ρ, occupation) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">apply_K(basis::PlaneWaveBasis, δψ, ψ, ρ, occupation)</code></pre><p>Compute the application of K defined at ψ to δψ. ρ is the density issued from ψ. δψ also generates a δρ, computed with <code>compute_δρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/hessian.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}" href="#DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}"><code>DFTK.apply_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_kernel(
    basis::PlaneWaveBasis,
    δρ;
    RPA,
    kwargs...
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">apply_kernel(basis::PlaneWaveBasis, δρ; kwargs...)</code></pre><p>Computes the potential response to a perturbation δρ in real space, as a 4D (i,j,k,σ) array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/terms.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_symop(
    symop::SymOp,
    basis,
    kpoint,
    ψk::AbstractVecOrMat
) -&gt; Tuple{Any, Any}
</code></pre><p>Apply a symmetry operation to eigenvectors <code>ψk</code> at a given <code>kpoint</code> to obtain an equivalent point in [-0.5, 0.5)^3 and associated eigenvectors (expressed in the basis of the new <span>$k$</span>-point).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_symop(symop::SymOp, basis, ρin; kwargs...) -&gt; Any
</code></pre><p>Apply a symmetry operation to a density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}" href="#DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}"><code>DFTK.apply_Ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_Ω(δψ, ψ, H::Hamiltonian, Λ) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">apply_Ω(δψ, ψ, H::Hamiltonian, Λ)</code></pre><p>Compute the application of Ω defined at ψ to δψ. H is the Hamiltonian computed from ψ and Λ is the set of Rayleigh coefficients ψk&#39; * Hk * ψk at each k-point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/hessian.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.apply_χ0-Union{Tuple{TδV}, Tuple{T}, Tuple{Any, Any, Any, T, Any, AbstractArray{TδV}}} where {T, TδV}" href="#DFTK.apply_χ0-Union{Tuple{TδV}, Tuple{T}, Tuple{Any, Any, Any, T, Any, AbstractArray{TδV}}} where {T, TδV}"><code>DFTK.apply_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_χ0(
    ham,
    ψ,
    occupation,
    εF,
    eigenvalues,
    δV::AbstractArray{TδV};
    occupation_threshold,
    q,
    kwargs_sternheimer...
) -&gt; Any
</code></pre><p>Get the density variation δρ corresponding to a potential variation δV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/chi0.jl#L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}" href="#DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}"><code>DFTK.attach_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">attach_psp(
    system::AtomsBase.AbstractSystem,
    pspmap::AbstractDict{Symbol, String}
) -&gt; AtomsBase.FlexibleSystem
</code></pre><pre><code class="nohighlight hljs">attach_psp(system::AbstractSystem, pspmap::AbstractDict{Symbol,String})
attach_psp(system::AbstractSystem; psps::String...)</code></pre><p>Return a new system with the <code>pseudopotential</code> property of all atoms set according to the passed <code>pspmap</code>, which maps from the atomic symbol to a pseudopotential identifier. Alternatively the mapping from atomic symbol to pseudopotential identifier can also be passed as keyword arguments. An empty string can be used to denote elements where the full Coulomb potential should be employed.</p><p><strong>Examples</strong></p><p>Select pseudopotentials for all silicon and oxygen atoms in the system.</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Dict(:Si =&gt; &quot;hgh/lda/si-q4&quot;, :O =&gt; &quot;hgh/lda/o-q6&quot;)</code></pre><p>Same thing but using the kwargs syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Si=&quot;hgh/lda/si-q4&quot;, O=&quot;hgh/lda/o-q6&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/attach_psp.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.band_data_to_dict-Tuple{NamedTuple}" href="#DFTK.band_data_to_dict-Tuple{NamedTuple}"><code>DFTK.band_data_to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">band_data_to_dict(
    band_data::NamedTuple;
    kwargs...
) -&gt; Dict{String, Any}
</code></pre><p>Convert a band computational result to a dictionary representation. Intended to give a condensed set of results and useful metadata for post processing. See also the <a href="#DFTK.todict-Tuple{Energies}"><code>todict</code></a> function for the <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a> and the <a href="#DFTK.PlaneWaveBasis"><code>PlaneWaveBasis</code></a>, which are called from this function and the outputs merged. Note, that only the master process returns meaningful data. All other processors still return a dictionary (to simplify code in calling locations), but the data may be dummy.</p><p>Some details on the conventions for the returned data:</p><ul><li><code>εF</code>: Computed Fermi level (if present in band_data)</li><li><code>labels</code>: A mapping of high-symmetry k-Point labels to the index in the <code>&quot;kcoords&quot;</code> vector of the corresponding k-Point.</li><li><code>eigenvalues</code>, <code>eigenvalues_error</code>, <code>occupation</code>, <code>residual_norms</code>: <code>(n_bands, n_kpoints, n_spin)</code> arrays of the respective data.</li><li><code>n_iter</code>: <code>(n_kpoints, n_spin)</code> array of the number of iterations the diagonalization routine required.</li><li><code>kpt_max_n_G</code>: Maximal number of G-vectors used for any k-point.</li><li><code>kpt_n_G_vectors</code>: <code>(n_kpoints, n_spin)</code> array, the number of valid G-vectors for each k-point, i.e. the extend along the first axis of <code>ψ</code> where data is valid.</li><li><code>kpt_G_vectors</code>: <code>(3, max_n_G, n_kpoints, n_spin)</code> array of the integer (reduced) coordinates of the G-points used for each k-point.</li><li><code>ψ</code>: <code>(max_n_G, n_bands, n_kpoints, n_spin)</code> arrays where <code>max_n_G</code> is the maximal number of G-vectors used for any k-point. The data is zero-padded, i.e. for k-points which have less G-vectors than max<em>n</em>G, then there are tailing zeros.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/input_output.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}" href="#DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}"><code>DFTK.build_fft_plans!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_fft_plans!(
    tmp::Array{ComplexF64}
) -&gt; Tuple{FFTW.cFFTWPlan{ComplexF64, -1, true}, FFTW.cFFTWPlan{ComplexF64, -1, false}, Any, Any}
</code></pre><p>Plan a FFT of type <code>T</code> and size <code>fft_size</code>, spending some time on finding an optimal algorithm. (Inplace, out-of-place) x (forward, backward) FFT plans are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_form_factors-Tuple{Any, Array}" href="#DFTK.build_form_factors-Tuple{Any, Array}"><code>DFTK.build_form_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_form_factors(psp, qs::Array) -&gt; Matrix
</code></pre><p>Build form factors (Fourier transforms of projectors) for an atom centered at 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/nonlocal.jl#L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T" href="#DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T"><code>DFTK.build_projection_vectors_</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_projection_vectors_(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt::Kpoint,
    psps,
    psp_positions
) -&gt; Any
</code></pre><p>Build projection vectors for a atoms array generated by term_nonlocal</p><p class="math-container">\[\begin{aligned}
H_{\rm at}  &amp;= \sum_{ij} C_{ij} \ket{p_i} \bra{p_j} \\
H_{\rm per} &amp;= \sum_R \sum_{ij} C_{ij} \ket{p_i(x-R)} \bra{p_j(x-R)}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\braket{e_k(G&#39;) \middle| H_{\rm per}}{e_k(G)}
        &amp;= \ldots \\
        &amp;= \frac{1}{Ω} \sum_{ij} C_{ij} \hat p_i(k+G&#39;) \hat p_j^*(k+G),
\end{aligned}\]</p><p>where <span>$\hat p_i(q) = ∫_{ℝ^3} p_i(r) e^{-iq·r} dr$</span>.</p><p>We store <span>$\frac{1}{\sqrt Ω} \hat p_i(k+G)$</span> in <code>proj_vectors</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/nonlocal.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Tuple{NamedTuple}" href="#DFTK.cell_to_supercell-Tuple{NamedTuple}"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_to_supercell(scfres::NamedTuple) -&gt; Any
</code></pre><p>Transpose all data from a given self-consistent-field result from unit cell to supercell conventions. The parameters to adapt are the following:</p><ul><li><code>basis_supercell</code> and <code>ψ_supercell</code> are computed by the routines above.</li><li>The supercell occupations vector is the concatenation of all input occupations vectors.</li><li>The supercell density is computed with supercell occupations and <code>ψ_supercell</code>.</li><li>Supercell energies are the multiplication of input energies by the number of unit cells in the supercell.</li></ul><p>Other parameters stay untouched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/supercell.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.cell_to_supercell-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_to_supercell(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real
) -&gt; PlaneWaveBasis
</code></pre><p>Construct a plane-wave basis whose unit cell is the supercell associated to an input basis <span>$k$</span>-grid. All other parameters are modified so that the respective physical systems associated to both basis are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/supercell.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real" href="#DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cell_to_supercell(
    ψ,
    basis::PlaneWaveBasis{T&lt;:Real, VT} where VT&lt;:Real,
    basis_supercell::PlaneWaveBasis{T&lt;:Real, VT} where VT&lt;:Real
) -&gt; Any
</code></pre><p>Re-organize Bloch waves computed in a given basis as Bloch waves of the associated supercell basis. The output <code>ψ_supercell</code> have a single component at <span>$Γ$</span>-point, such that <code>ψ_supercell[Γ][:, k+n]</code> contains <code>ψ[k][:, n]</code>, within normalization on the supercell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/supercell.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T" href="#DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T"><code>DFTK.cg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cg!(
    x::AbstractArray{T, 1},
    A::LinearMaps.LinearMap{T},
    b::AbstractArray{T, 1};
    precon,
    proj,
    callback,
    tol,
    maxiter,
    miniter
) -&gt; NamedTuple{(:x, :converged, :tol, :residual_norm, :n_iter, :maxiter, :stage), _A} where _A&lt;:Tuple{AbstractVector, Bool, Float64, Any, Int64, Int64, Symbol}
</code></pre><p>Implementation of the conjugate gradient method which allows for preconditioning and projection operations along iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/cg.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.charge_ionic-Tuple{DFTK.Element}" href="#DFTK.charge_ionic-Tuple{DFTK.Element}"><code>DFTK.charge_ionic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_ionic(el::DFTK.Element) -&gt; Int64
</code></pre><p>Return the total ionic charge of an atom type (nuclear charge - core electrons)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.charge_nuclear-Tuple{DFTK.Element}" href="#DFTK.charge_nuclear-Tuple{DFTK.Element}"><code>DFTK.charge_nuclear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_nuclear(_::DFTK.Element) -&gt; Int64
</code></pre><p>Return the total nuclear charge of an atom type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cis2pi-Tuple{Any}" href="#DFTK.cis2pi-Tuple{Any}"><code>DFTK.cis2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cis2pi(x) -&gt; Any
</code></pre><p>Function to compute exp(2π i x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/cis2pi.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_amn_kpoint-Tuple{PlaneWaveBasis, Vararg{Any, 4}}" href="#DFTK.compute_amn_kpoint-Tuple{PlaneWaveBasis, Vararg{Any, 4}}"><code>DFTK.compute_amn_kpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_amn_kpoint(
    basis::PlaneWaveBasis,
    kpt,
    ψk,
    projections,
    n_bands
) -&gt; Any
</code></pre><p>Compute the starting matrix for Wannierization.</p><p>Wannierization searches for a unitary matrix <span>$U_{m_n}$</span>. As a starting point for the search, we can provide an initial guess function <span>$g$</span> for the shape of the Wannier functions, based on what we expect from knowledge of the problem or physical intuition. This starting matrix is called <span>$[A_k]_{m,n}$</span>, and is computed as follows: <span>$[A_k]_{m,n} = \langle ψ_m^k | g^{\text{per}}_n \rangle$</span>. The matrix will be orthonormalized by the chosen Wannier program, we don&#39;t need to do so ourselves.</p><p>Centers are to be given in lattice coordinates and G_vectors in reduced coordinates. The dot product is computed in the Fourier space.</p><p>Given an orbital <span>$g_n$</span>, the periodized orbital is defined by :  <span>$g^{per}_n =  \sum\limits_{R \in {\rm lattice}} g_n( \cdot - R)$</span>. The Fourier coefficient of <span>$g^{per}_n$</span> at any G is given by the value of the Fourier transform of <span>$g_n$</span> in G.</p><p>Each projection is a callable object that accepts the basis and some qpoints as an argument, and returns the Fourier transform of <span>$g_n$</span> at the qpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_bands-Tuple{Any, Brillouin.KPaths.KPath}" href="#DFTK.compute_bands-Tuple{Any, Brillouin.KPaths.KPath}"><code>DFTK.compute_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bands(
    basis_or_scfres,
    kpath::Brillouin.KPaths.KPath;
    kline_density,
    kwargs...
) -&gt; NamedTuple{(:basis, :ψ, :eigenvalues, :ρ, :εF, :occupation, :diagonalization, :kinter)}
</code></pre><p>Compute band data along a specific <code>Brillouin.KPath</code> using a <code>kline_density</code>, the number of <span>$k$</span>-points per inverse bohrs (i.e. overall in units of length).</p><p>If not given, the path is determined automatically by inspecting the <code>Model</code>. If you are using spin, you should pass the <code>magnetic_moments</code> as a kwarg to ensure these are taken into account when determining the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_bands-Tuple{NamedTuple, DFTK.AbstractKgrid}" href="#DFTK.compute_bands-Tuple{NamedTuple, DFTK.AbstractKgrid}"><code>DFTK.compute_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bands(
    scfres::NamedTuple,
    kgrid::DFTK.AbstractKgrid;
    n_bands,
    kwargs...
) -&gt; NamedTuple{(:basis, :ψ, :eigenvalues, :ρ, :εF, :occupation, :diagonalization), _A} where _A&lt;:Tuple{PlaneWaveBasis, Any, Any, Any, Any, Any, Vector}
</code></pre><p>Compute band data starting from SCF results. <code>εF</code> and <code>ρ</code> from the <code>scfres</code> are forwarded to the band computation and <code>n_bands</code> is by default selected as <code>n_bands_scf + 5sqrt(n_bands_scf)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_bands-Tuple{PlaneWaveBasis, DFTK.AbstractKgrid}" href="#DFTK.compute_bands-Tuple{PlaneWaveBasis, DFTK.AbstractKgrid}"><code>DFTK.compute_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bands(
    basis::PlaneWaveBasis,
    kgrid::DFTK.AbstractKgrid;
    n_bands,
    n_extra,
    ρ,
    εF,
    eigensolver,
    tol,
    kwargs...
) -&gt; NamedTuple{(:basis, :ψ, :eigenvalues, :ρ, :εF, :occupation, :diagonalization), _A} where _A&lt;:Tuple{PlaneWaveBasis, Any, Any, Any, Nothing, Nothing, Vector}
</code></pre><p>Compute <code>n_bands</code> eigenvalues and Bloch waves at the k-Points specified by the <code>kgrid</code>. All kwargs not specified below are passed to <a href="#DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}"><code>diagonalize_all_kblocks</code></a>:</p><ul><li><code>kgrid</code>: A custom kgrid to perform the band computation, e.g. a new <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> grid.</li><li><code>tol</code> The default tolerance for the eigensolver is substantially lower than for SCF computations. Increase if higher accuracy desired.</li><li><code>eigensolver</code>: The diagonalisation method to be employed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_current</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_current(
    basis::PlaneWaveBasis,
    ψ,
    occupation
) -&gt; Vector
</code></pre><p>Computes the <em>probability</em> (not charge) current, ∑ fn Im(ψn* ∇ψn)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/current.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_density(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    ψ,
    occupation;
    occupation_threshold
) -&gt; AbstractArray{_A, 4} where _A
</code></pre><pre><code class="nohighlight hljs">compute_density(basis::PlaneWaveBasis, ψ::AbstractVector, occupation::AbstractVector)</code></pre><p>Compute the density for a wave function <code>ψ</code> discretized on the plane-wave grid <code>basis</code>, where the individual k-points are occupied according to <code>occupation</code>. <code>ψ</code> should be one coefficient matrix per <span>$k$</span>-point. It is possible to ask only for occupations higher than a certain level to be computed by using an optional <code>occupation_threshold</code>. By default all occupation numbers are considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/densities.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dos-Tuple{Any, Any, Any}" href="#DFTK.compute_dos-Tuple{Any, Any, Any}"><code>DFTK.compute_dos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_dos(
    ε,
    basis,
    eigenvalues;
    smearing,
    temperature
) -&gt; Any
</code></pre><p>Total density of states at energy ε</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/dos.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dynmat-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_dynmat-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_dynmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_dynmat(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    ψ,
    occupation;
    q,
    ρ,
    ham,
    εF,
    eigenvalues,
    kwargs...
) -&gt; Any
</code></pre><p>Compute the dynamical matrix in the form of a <span>$3×n_{\rm atoms}×3×n_{\rm atoms}$</span> tensor in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/phonon.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_dynmat_cart-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_dynmat_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_dynmat_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_dynmat_cart(
    basis::PlaneWaveBasis,
    ψ,
    occupation;
    kwargs...
) -&gt; Any
</code></pre><p>Cartesian form of <a href="#DFTK.compute_dynmat-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>compute_dynmat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/phonon.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T" href="#DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T"><code>DFTK.compute_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_fft_size(
    model::Model{T},
    Ecut
) -&gt; Tuple{Vararg{Any, _A}} where _A
compute_fft_size(
    model::Model{T},
    Ecut,
    kgrid;
    ensure_smallprimes,
    algorithm,
    factors,
    kwargs...
) -&gt; Tuple{Vararg{Any, _A}} where _A
</code></pre><p>Determine the minimal grid size for the cubic basis set to be able to represent product of orbitals (with the default <code>supersampling=2</code>).</p><p>Optionally optimize the grid afterwards for the FFT procedure by ensuring factorization into small primes.</p><p>The function will determine the smallest parallelepiped containing the wave vectors  <span>$|G|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span>. For an exact representation of the density resulting from wave functions represented in the spherical basis sets, <code>supersampling</code> should be at least <code>2</code>.</p><p>If <code>factors</code> is not empty, ensure that the resulting fft_size contains all the factors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_forces(scfres) -&gt; Any
</code></pre><p>Compute the forces of an obtained SCF solution. Returns the forces wrt. the fractional lattice vectors. To get cartesian forces use <a href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>compute_forces_cart</code></a>. Returns a list of lists of forces (as SVector{3}) in the same order as the <code>atoms</code> and <code>positions</code> in the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/forces.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_forces_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_forces_cart(
    basis::PlaneWaveBasis,
    ψ,
    occupation;
    kwargs...
) -&gt; Any
</code></pre><p>Compute the cartesian forces of an obtained SCF solution in Hartree / Bohr. Returns a list of lists of forces <code>[[force for atom in positions] for (element, positions) in atoms]</code> which has the same structure as the <code>atoms</code> object passed to the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/forces.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_inverse_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_inverse_lattice(lattice::AbstractArray{T, 2}) -&gt; Any
</code></pre><p>Compute the inverse of the lattice. Takes special care of 1D or 2D cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/structure.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.compute_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_kernel(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real;
    kwargs...
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">compute_kernel(basis::PlaneWaveBasis; kwargs...)</code></pre><p>Computes a matrix representation of the full response kernel (derivative of potential with respect to density) in real space. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks</p><p class="math-container">\[\left(\begin{array}{cc}
    K_{αα} &amp; K_{αβ}\\
    K_{βα} &amp; K_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/terms.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_ldos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_ldos(
    ε,
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    eigenvalues,
    ψ;
    smearing,
    temperature,
    weight_threshold
) -&gt; AbstractArray{_A, 4} where _A
</code></pre><p>Local density of states, in real space. <code>weight_threshold</code> is a threshold to screen away small contributions to the LDOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/dos.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_occupation(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    eigenvalues::AbstractVector,
    εF::Number;
    temperature,
    smearing
) -&gt; NamedTuple{(:occupation, :εF), _A} where _A&lt;:Tuple{Any, Number}
</code></pre><p>Compute occupation given eigenvalues and Fermi level</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/occupation.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_occupation(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    eigenvalues::AbstractVector
) -&gt; NamedTuple{(:occupation, :εF), _A} where _A&lt;:Tuple{Any, Number}
compute_occupation(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    eigenvalues::AbstractVector,
    fermialg::AbstractFermiAlgorithm;
    tol_n_elec,
    temperature,
    smearing
) -&gt; NamedTuple{(:occupation, :εF), _A} where _A&lt;:Tuple{Any, Number}
</code></pre><p>Compute occupation and Fermi level given eigenvalues and using <code>fermialg</code>. The <code>tol_n_elec</code> gives the accuracy on the electron count which should be at least achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/occupation.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_recip_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_recip_lattice(lattice::AbstractArray{T, 2}) -&gt; Any
</code></pre><p>Compute the reciprocal lattice. We use the convention that the reciprocal lattice is the set of G vectors such that G ⋅ R ∈ 2π ℤ for all R in the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/structure.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_stresses_cart-Tuple{Any}" href="#DFTK.compute_stresses_cart-Tuple{Any}"><code>DFTK.compute_stresses_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_stresses_cart(scfres) -&gt; Any
</code></pre><p>Compute the stresses of an obtained SCF solution. The stress tensor is given by</p><p class="math-container">\[\left( \begin{array}{ccc}
σ_{xx} σ_{xy} σ_{xz} \\
σ_{yx} σ_{yy} σ_{yz} \\
σ_{zx} σ_{zy} σ_{zz}
\right) = \frac{1}{|Ω|} \left. \frac{dE[ (I+ϵ) * L]}{dM}\right|_{ϵ=0}\]</p><p>where <span>$ϵ$</span> is the strain. See <a href="https://doi.org/10.1103/PhysRevB.32.3792">O. Nielsen, R. Martin Phys. Rev. B. <strong>32</strong>, 3792 (1985)</a> for details. In Voigt notation one would use the vector <span>$[σ_{xx} σ_{yy} σ_{zz} σ_{zy} σ_{zx} σ_{yx}]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/stresses.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_transfer_matrix(
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_in::Kpoint,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_out::Kpoint
) -&gt; Any
</code></pre><p>Return a sparse matrix that maps quantities given on <code>basis_in</code> and <code>kpt_in</code> to quantities on <code>basis_out</code> and <code>kpt_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_transfer_matrix(
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real
) -&gt; Any
</code></pre><p>Return a list of sparse matrices (one per <span>$k$</span>-point) that map quantities given in the <code>basis_in</code> basis to quantities given in the <code>basis_out</code> basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_unit_cell_volume-Tuple{Any}" href="#DFTK.compute_unit_cell_volume-Tuple{Any}"><code>DFTK.compute_unit_cell_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_unit_cell_volume(lattice) -&gt; Any
</code></pre><p>Compute unit cell volume volume. In case of 1D or 2D case, the volume is the length/surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/structure.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_δHψ_sα-Tuple{PlaneWaveBasis, Vararg{Any, 4}}" href="#DFTK.compute_δHψ_sα-Tuple{PlaneWaveBasis, Vararg{Any, 4}}"><code>DFTK.compute_δHψ_sα</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_δHψ_sα(
    basis::PlaneWaveBasis,
    ψ,
    q,
    s,
    α;
    kwargs...
) -&gt; Any
</code></pre><p>Assemble the right-hand side term for the Sternheimer equation for all relevant quantities: Compute the perturbation of the Hamiltonian with respect to a variation of the local potential produced by a displacement of the atom s in the direction α.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/phonon.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 4}}} where T" href="#DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 4}}} where T"><code>DFTK.compute_δocc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_δocc!(
    δocc,
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    ψ,
    εF,
    ε,
    δHψ
) -&gt; NamedTuple{(:δocc, :δεF), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Compute the derivatives of the occupations (and of the Fermi level). The derivatives of the occupations are in-place stored in δocc. The tuple (; δocc, δεF) is returned. It is assumed the passed <code>δocc</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/chi0.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_δψ!-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 5}}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 6}}} where T" href="#DFTK.compute_δψ!-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 5}}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Vararg{Any, 6}}} where T"><code>DFTK.compute_δψ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_δψ!(
    δψ,
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    H,
    ψ,
    εF,
    ε,
    δHψ
)
compute_δψ!(
    δψ,
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    H,
    ψ,
    εF,
    ε,
    δHψ,
    ε_minus_q;
    ψ_extra,
    q,
    kwargs_sternheimer...
)
</code></pre><p>Perform in-place computations of the derivatives of the wave functions by solving a Sternheimer equation for each <code>k</code>-points. It is assumed the passed <code>δψ</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/chi0.jl#L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.compute_χ0-Tuple{Any}" href="#DFTK.compute_χ0-Tuple{Any}"><code>DFTK.compute_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_χ0(ham; temperature) -&gt; Any
</code></pre><p>Compute the independent-particle susceptibility. Will blow up for large systems. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks, which are:</p><p class="math-container">\[\left(\begin{array}{cc}
    (χ_0)_{αα}  &amp; (χ_0)_{αβ} \\
    (χ_0)_{βα}  &amp; (χ_0)_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/chi0.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.cos2pi-Tuple{Any}" href="#DFTK.cos2pi-Tuple{Any}"><code>DFTK.cos2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cos2pi(x) -&gt; Any
</code></pre><p>Function to compute cos(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/cis2pi.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{Any, Any}" href="#DFTK.count_n_proj-Tuple{Any, Any}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psps, psp_positions) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">count_n_proj(psps, psp_positions)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code> and for all atoms in the system, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp::DFTK.NormConservingPsp, l::Integer) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">count_n_proj(psp, l)</code></pre><p>Number of projector functions for angular momentum <code>l</code>, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp::DFTK.NormConservingPsp) -&gt; Int64
</code></pre><pre><code class="nohighlight hljs">count_n_proj(psp)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code>, including angular parts from <code>-m:m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(
    psp::DFTK.NormConservingPsp,
    l::Integer
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">count_n_proj_radial(psp, l)</code></pre><p>Number of projector radial functions at angular momentum <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(psp::DFTK.NormConservingPsp) -&gt; Int64
</code></pre><pre><code class="nohighlight hljs">count_n_proj_radial(psp)</code></pre><p>Number of projector radial functions at all angular momenta up to <code>psp.lmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.create_supercell-NTuple{4, Any}" href="#DFTK.create_supercell-NTuple{4, Any}"><code>DFTK.create_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_supercell(
    lattice,
    atoms,
    positions,
    supercell_size
) -&gt; NamedTuple{(:lattice, :atoms, :positions), _A} where _A&lt;:Tuple{Any, Any, Any}
</code></pre><p>Construct a supercell of size <code>supercell_size</code> from a unit cell described by its <code>lattice</code>, <code>atoms</code> and their <code>positions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/supercell.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.datadir_psp-Tuple{}" href="#DFTK.datadir_psp-Tuple{}"><code>DFTK.datadir_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">datadir_psp() -&gt; String
</code></pre><p>Return the data directory with pseudopotential files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/load_psp.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}" href="#DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}"><code>DFTK.default_fermialg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_fermialg(
    _::DFTK.Smearing.SmearingFunction
) -&gt; FermiBisection
</code></pre><p>Default selection of a Fermi level determination algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/occupation.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_symmetries-NTuple{6, Any}" href="#DFTK.default_symmetries-NTuple{6, Any}"><code>DFTK.default_symmetries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_symmetries(
    lattice,
    atoms,
    positions,
    magnetic_moments,
    spin_polarization,
    terms;
    tol_symmetry
) -&gt; Union{Vector{SymOp{Bool}}, Vector{SymOp{Float64}}}
</code></pre><p>Default logic to determine the symmetry operations to be used in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.default_wannier_centers-Tuple{Any}" href="#DFTK.default_wannier_centers-Tuple{Any}"><code>DFTK.default_wannier_centers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_wannier_centers(n_wannier) -&gt; Any
</code></pre><p>Default random Gaussian guess for maximally-localised wannier functions generated in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.determine_spin_polarization-Tuple{Any}" href="#DFTK.determine_spin_polarization-Tuple{Any}"><code>DFTK.determine_spin_polarization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determine_spin_polarization(magnetic_moments) -&gt; Symbol
</code></pre><p><code>:none</code> if no element has a magnetic moment, else <code>:collinear</code> or <code>:full</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}" href="#DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}"><code>DFTK.diagonalize_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagonalize_all_kblocks(
    eigensolver,
    ham::Hamiltonian,
    nev_per_kpoint::Int64;
    ψguess,
    prec_type,
    interpolate_kpoints,
    tol,
    miniter,
    maxiter,
    n_conv_check
) -&gt; NamedTuple{(:λ, :X, :residual_norms, :n_iter, :converged, :n_matvec), _A} where _A&lt;:Tuple{Vector, Vector, Vector, Vector, Union{Missing, Bool}, Any}
</code></pre><p>Function for diagonalising each <span>$k$</span>-Point blow of ham one step at a time. Some logic for interpolating between <span>$k$</span>-points is used if <code>interpolate_kpoints</code> is true and if no guesses are given. <code>eigensolver</code> is the iterative eigensolver that really does the work, operating on a single <span>$k$</span>-Block. <code>eigensolver</code> should support the API <code>eigensolver(A, X0; prec, tol, maxiter)</code> <code>prec_type</code> should be a function that returns a preconditioner when called as <code>prec(ham, kpt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/eigen/diag.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.diameter-Tuple{AbstractMatrix}" href="#DFTK.diameter-Tuple{AbstractMatrix}"><code>DFTK.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diameter(lattice::AbstractMatrix) -&gt; Any
</code></pre><p>Compute the diameter of the unit cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/structure.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.direct_minimization-Tuple{PlaneWaveBasis}" href="#DFTK.direct_minimization-Tuple{PlaneWaveBasis}"><code>DFTK.direct_minimization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">direct_minimization(
    basis::PlaneWaveBasis;
    kwargs...
) -&gt; NamedTuple{(:ham, :basis, :energies, :converged, :ρ, :ψ, :eigenvalues, :occupation, :εF, :optim_res), _A} where _A&lt;:Tuple{Any, PlaneWaveBasis, Any, Bool, Any, Any, Vector{Any}, Vector, Nothing, Optim.MultivariateOptimizationResults{Optim.LBFGS{DFTK.DMPreconditioner, LineSearches.InitialStatic{Float64}, LineSearches.BackTracking{Float64, Int64}, typeof(DFTK.precondprep!)}, _A, _B, _C, _D, Bool} where {_A, _B, _C, _D}}
</code></pre><p>Computes the ground state by direct minimization. <code>kwargs...</code> are passed to <code>Optim.Options()</code>. Note that the resulting ψ are not necessarily eigenvectors of the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/direct_minimization.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.disable_threading-Tuple{}" href="#DFTK.disable_threading-Tuple{}"><code>DFTK.disable_threading</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disable_threading() -&gt; Union{Nothing, Bool}
</code></pre><p>Convenience function to disable all threading in DFTK and assert that Julia threading is off as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/threading.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.divergence_real-Tuple{Any, Any}" href="#DFTK.divergence_real-Tuple{Any, Any}"><code>DFTK.divergence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divergence_real(operand, basis) -&gt; Any
</code></pre><p>Compute divergence of an operand function, which returns the cartesian x,y,z components in real space when called with the arguments 1 to 3. The divergence is also returned as a real-space array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/xc.jl#L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray, Any}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_ewald(
    lattice::AbstractArray{T},
    charges::AbstractArray,
    positions;
    kwargs...
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Standard computation of energy and forces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/ewald.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_ewald(
    lattice::AbstractArray{T},
    charges,
    positions,
    q,
    ph_disp;
    kwargs...
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Computation for phonons; required to build the dynamical matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/ewald.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_ewald-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_ewald(
    S,
    lattice::AbstractArray{T},
    charges,
    positions,
    q,
    ph_disp;
    η
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Compute the electrostatic energy and forces. The energy is the electrostatic interaction energy per unit cell between point charges in a uniform background of compensating charge to yield net neutrality. The forces is the opposite of the derivative of the energy with respect to <code>positions</code>.</p><p><code>lattice</code> should contain the lattice vectors as columns. <code>charges</code> and <code>positions</code> are the point charges and their positions (as an array of arrays) in fractional coordinates.</p><p>For now this function returns zero energy and force on non-3D systems. Use a pairwise potential term if you want to customise this treatment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/ewald.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 4}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_pairwise(
    lattice::AbstractArray{T},
    symbols,
    positions,
    V,
    params;
    kwargs...
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Standard computation of energy and forces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/pairwise.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 6}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any, 6}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_pairwise(
    lattice::AbstractArray{T},
    symbols,
    positions,
    V,
    params,
    q,
    ph_disp;
    kwargs...
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Computation for phonons; required to build the dynamical matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/pairwise.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 6}}} where T" href="#DFTK.energy_forces_pairwise-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, Vararg{Any, 6}}} where T"><code>DFTK.energy_forces_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_forces_pairwise(
    S,
    lattice::AbstractArray{T},
    symbols,
    positions,
    V,
    params,
    q,
    ph_disp;
    max_radius
) -&gt; NamedTuple{(:energy, :forces), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Compute the pairwise energy and forces. The energy is the interaction energy per unit cell between atomic sites. The forces is the opposite of the derivative of the energy with respect to <code>positions</code>.</p><p><code>lattice</code> should contain the lattice vectors as columns. <code>symbols</code> and <code>positions</code> are the atomic elements and their positions (as an array of arrays) in fractional coordinates. <code>V</code> and <code>params</code> are the pairwise potential and its set of parameters (that depends on pairs of symbols).</p><p>The potential is expected to decrease quickly at infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/pairwise.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.energy_psp_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_psp_correction(
    lattice::AbstractArray{T, 2},
    atoms,
    atom_groups
) -&gt; Any
</code></pre><p>Compute the correction term for properly modelling the interaction of the pseudopotential core with the compensating background charge induced by the <code>Ewald</code> term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/psp_correction.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.enforce_real!-Tuple{Any, PlaneWaveBasis}" href="#DFTK.enforce_real!-Tuple{Any, PlaneWaveBasis}"><code>DFTK.enforce_real!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enforce_real!(
    fourier_coeffs,
    basis::PlaneWaveBasis
) -&gt; AbstractArray
</code></pre><p>Ensure its real-space equivalent of passed Fourier-space representation is entirely real by removing wavevectors <code>G</code> that don&#39;t have a <code>-G</code> counterpart in the basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.estimate_integer_lattice_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_integer_lattice_bounds(
    M::AbstractArray{T, 2},
    δ
) -&gt; Any
estimate_integer_lattice_bounds(
    M::AbstractArray{T, 2},
    δ,
    shift;
    tol
) -&gt; Any
</code></pre><p>Estimate integer bounds for dense space loops from a given inequality ||Mx|| ≤ δ. For 1D and 2D systems the limit will be zero in the auxiliary dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/structure.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_core_fourier-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real" href="#DFTK.eval_psp_density_core_fourier-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real"><code>DFTK.eval_psp_density_core_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_core_fourier(
    _::DFTK.NormConservingPsp,
    _::Real
) -&gt; Real
</code></pre><pre><code class="nohighlight hljs">eval_psp_density_core_fourier(psp, q)</code></pre><p>Evaluate the atomic core charge density in reciprocal space: ρval(q) = ∫<em>{R^3} ρcore(r) e^{-iqr} dr         = 4π ∫</em>{R+} ρcore(r) sin(qr)/qr r^2 dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_core_real-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real" href="#DFTK.eval_psp_density_core_real-Union{Tuple{T}, Tuple{DFTK.NormConservingPsp, T}} where T&lt;:Real"><code>DFTK.eval_psp_density_core_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_core_real(
    _::DFTK.NormConservingPsp,
    _::Real
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">eval_psp_density_core_real(psp, r)</code></pre><p>Evaluate the atomic core charge density in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_valence_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_density_valence_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_density_valence_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_valence_fourier(
    psp::DFTK.NormConservingPsp,
    q::AbstractVector
) -&gt; Real
</code></pre><pre><code class="nohighlight hljs">eval_psp_density_valence_fourier(psp, q)</code></pre><p>Evaluate the atomic valence charge density in reciprocal space: ρval(q) = ∫<em>{R^3} ρval(r) e^{-iqr} dr         = 4π ∫</em>{R+} ρval(r) sin(qr)/qr r^2 dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_density_valence_real-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_density_valence_real-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_density_valence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_density_valence_real(
    psp::DFTK.NormConservingPsp,
    r::AbstractVector
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">eval_psp_density_valence_real(psp, r)</code></pre><p>Evaluate the atomic valence charge density in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_energy_correction" href="#DFTK.eval_psp_energy_correction"><code>DFTK.eval_psp_energy_correction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_psp_energy_correction([T=Float64,] psp, n_electrons)</code></pre><p>Evaluate the energy correction to the Ewald electrostatic interaction energy of one unit cell, which is required compared the Ewald expression for point-like nuclei. <code>n_electrons</code> is the number of electrons per unit cell. This defines the uniform compensating background charge, which is assumed here.</p><p>Notice: The returned result is the <em>energy per unit cell</em> and not the energy per volume. To obtain the latter, the caller needs to divide by the unit cell volume.</p><p>The energy correction is defined as the limit of the Fourier-transform of the local potential as <span>$q \to 0$</span>, using the same correction as in the Fourier-transform of the local potential: <code>math \lim_{q \to 0} 4π N_{\rm elec} ∫_{ℝ_+} (V(r) - C(r)) \frac{\sin(qr)}{qr} r^2 dr + F[C(r)]  = 4π N_{\rm elec} ∫_{ℝ_+} (V(r) + Z/r) r^2 dr</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_fourier(
    psp::DFTK.NormConservingPsp,
    q::AbstractVector
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">eval_psp_local_fourier(psp, q)</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space:</p><p class="math-container">\[\begin{aligned}
V_{\rm loc}(q) &amp;= ∫_{ℝ^3} V_{\rm loc}(r) e^{-iqr} dr \\
               &amp;= 4π ∫_{ℝ_+} V_{\rm loc}(r) \frac{\sin(qr)}{q} r dr
\end{aligned}\]</p><p>In practice, the local potential should be corrected using a Coulomb-like term <span>$C(r) = -Z/r$</span> to remove the long-range tail of <span>$V_{\rm loc}(r)$</span> from the integral:</p><p class="math-container">\[\begin{aligned}
V_{\rm loc}(q) &amp;= ∫_{ℝ^3} (V_{\rm loc}(r) - C(r)) e^{-iq·r} dr + F[C(r)] \\
               &amp;= 4π ∫_{ℝ_+} (V_{\rm loc}(r) + Z/r) \frac{\sin(qr)}{qr} r^2 dr - Z/q^2
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_real(
    psp::DFTK.NormConservingPsp,
    r::AbstractVector
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_projector_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_fourier(
    psp::DFTK.NormConservingPsp,
    q::AbstractVector
)
</code></pre><pre><code class="nohighlight hljs">eval_psp_projector_fourier(psp, i, l, q)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal vector with modulus <code>q</code>:</p><p class="math-container">\[\begin{aligned}
p(q) &amp;= ∫_{ℝ^3} p_{il}(r) e^{-iq·r} dr \\
     &amp;= 4π ∫_{ℝ_+} r^2 p_{il}(r) j_l(qr) dr
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}" href="#DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}"><code>DFTK.eval_psp_projector_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_real(
    psp::DFTK.NormConservingPsp,
    i,
    l,
    r::AbstractVector
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">eval_psp_projector_real(psp, i, l, r)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> in real-space at the vector with modulus <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/NormConservingPsp.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.filled_occupation-Tuple{Any}" href="#DFTK.filled_occupation-Tuple{Any}"><code>DFTK.filled_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filled_occupation(model) -&gt; Int64
</code></pre><p>Maximal occupation of a state (2 for non-spin-polarized electrons, 1 otherwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.find_equivalent_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_equivalent_kpt(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kcoord,
    spin;
    tol
) -&gt; NamedTuple{(:index, :ΔG), _A} where _A&lt;:Tuple{Int64, Any}
</code></pre><p>Find the equivalent index of the coordinate <code>kcoord</code> ∈ ℝ³ in a list <code>kcoords</code> ∈ [-½, ½)³. <code>ΔG</code> is the vector of ℤ³ such that <code>kcoords[index] = kcoord + ΔG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gather_kpts-Tuple{PlaneWaveBasis}" href="#DFTK.gather_kpts-Tuple{PlaneWaveBasis}"><code>DFTK.gather_kpts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gather_kpts(
    basis::PlaneWaveBasis
) -&gt; Union{Nothing, PlaneWaveBasis}
</code></pre><p>Gather the distributed <span>$k$</span>-point data on the master process and return it as a <code>PlaneWaveBasis</code>. On the other (non-master) processes <code>nothing</code> is returned. The returned object should not be used for computations and only for debugging or to extract data for serialisation to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gather_kpts_block!-Union{Tuple{A}, Tuple{Any, PlaneWaveBasis, AbstractVector{A}}} where A" href="#DFTK.gather_kpts_block!-Union{Tuple{A}, Tuple{Any, PlaneWaveBasis, AbstractVector{A}}} where A"><code>DFTK.gather_kpts_block!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gather_kpts_block!(
    dest,
    basis::PlaneWaveBasis,
    kdata::AbstractArray{A, 1}
) -&gt; Any
</code></pre><p>Gather the distributed data of a quantity depending on <code>k</code>-Points on the master process and save it in <code>dest</code> as a dense <code>(size(kdata[1])..., n_kpoints)</code> array. On the other (non-master) processes <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.gaussian_valence_charge_density_fourier-Union{Tuple{T}, Tuple{DFTK.Element, T}} where T&lt;:Real" href="#DFTK.gaussian_valence_charge_density_fourier-Union{Tuple{T}, Tuple{DFTK.Element, T}} where T&lt;:Real"><code>DFTK.gaussian_valence_charge_density_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gaussian_valence_charge_density_fourier(
    el::DFTK.Element,
    q::Real
) -&gt; Real
</code></pre><p>Gaussian valence charge density using Abinit&#39;s coefficient table, in Fourier space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.guess_density" href="#DFTK.guess_density"><code>DFTK.guess_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">guess_density(
    basis::PlaneWaveBasis,
    method::AtomicDensity
) -&gt; Any
guess_density(
    basis::PlaneWaveBasis,
    method::AtomicDensity,
    magnetic_moments;
    n_electrons
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">guess_density(basis::PlaneWaveBasis, method::DensityConstructionMethod,
              magnetic_moments=[]; n_electrons=basis.model.n_electrons)</code></pre><p>Build a superposition of atomic densities (SAD) guess density or a rarndom guess density.</p><p>The guess atomic densities are taken as one of the following depending on the input <code>method</code>:</p><p>-<code>RandomDensity()</code>: A random density, normalized to the number of electrons <code>basis.model.n_electrons</code>. Does not support magnetic moments. -<code>ValenceDensityAuto()</code>: A combination of the <code>ValenceDensityGaussian</code> and <code>ValenceDensityPseudo</code> methods where elements whose pseudopotentials provide numeric valence charge density data use them and elements without use Gaussians. -<code>ValenceDensityGaussian()</code>: Gaussians of length specified by <code>atom_decay_length</code> normalized for the correct number of electrons:</p><p class="math-container">\[\hat{ρ}(G) = Z_{\mathrm{valence}} \exp\left(-(2π \text{length} |G|)^2\right)\]</p><ul><li><code>ValenceDensityPseudo()</code>: Numerical pseudo-atomic valence charge densities from the</li></ul><p>pseudopotentials. Will fail if one or more elements in the system has a pseudopotential that does not have valence charge density data.</p><p>When magnetic moments are provided, construct a symmetry-broken density guess. The magnetic moments should be specified in units of <span>$μ_B$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/density_methods.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}" href="#DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}"><code>DFTK.hamiltonian_with_total_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hamiltonian_with_total_potential(
    ham::Hamiltonian,
    V
) -&gt; Hamiltonian
</code></pre><p>Returns a new Hamiltonian with local potential replaced by the given one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/Hamiltonian.jl#L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.hankel-Union{Tuple{T}, Tuple{AbstractVector, AbstractVector, Integer, T}} where T&lt;:Real" href="#DFTK.hankel-Union{Tuple{T}, Tuple{AbstractVector, AbstractVector, Integer, T}} where T&lt;:Real"><code>DFTK.hankel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hankel(
    r::AbstractVector,
    r2_f::AbstractVector,
    l::Integer,
    q::Real
) -&gt; Real
</code></pre><pre><code class="nohighlight hljs">hankel(r, r2_f, l, q)</code></pre><p>Compute the Hankel transform</p><p class="math-container">\[    H[f] = 4\pi \int_0^\infty r f(r) j_l(qr) r dr.\]</p><p>The integration is performed by trapezoidal quadrature, and the function takes as input the radial grid <code>r</code>, the precomputed quantity r²f(r) <code>r2_f</code>, angular momentum / spherical bessel order <code>l</code>, and the Hankel coordinate <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/hankel.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.has_core_density-Tuple{DFTK.Element}" href="#DFTK.has_core_density-Tuple{DFTK.Element}"><code>DFTK.has_core_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_core_density(_::DFTK.Element) -&gt; Any
</code></pre><p>Check presence of model core charge density (non-linear core correction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}" href="#DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}"><code>DFTK.index_G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_G_vectors(
    fft_size::Tuple,
    G::AbstractVector{&lt;:Integer}
) -&gt; Any
</code></pre><p>Return the index tuple <code>I</code> such that <code>G_vectors(basis)[I] == G</code> or the index <code>i</code> such that <code>G_vectors(basis, kpoint)[i] == G</code>. Returns nothing if outside the range of valid wave vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}" href="#DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}"><code>DFTK.interpolate_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_density(
    ρ_in,
    basis_in::PlaneWaveBasis,
    basis_out::PlaneWaveBasis
) -&gt; Any
</code></pre><p>Interpolate a function expressed in a basis <code>basis_in</code> to a basis <code>basis_out</code>. This interpolation uses a very basic real-space algorithm, and makes a DWIM-y attempt to take into account the fact that <code>basis_out</code> can be a supercell of <code>basis_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/interpolation.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}" href="#DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}"><code>DFTK.interpolate_kpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_kpoint(
    data_in::AbstractVecOrMat,
    basis_in::PlaneWaveBasis,
    kpoint_in::Kpoint,
    basis_out::PlaneWaveBasis,
    kpoint_out::Kpoint
) -&gt; Any
</code></pre><p>Interpolate some data from one <span>$k$</span>-point to another. The interpolation is fast, but not necessarily exact. Intended only to construct guesses for iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/interpolation.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T" href="#DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T"><code>DFTK.irfft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">irfft(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    f_fourier::AbstractArray
) -&gt; Any
</code></pre><p>Perform a real valued iFFT; see <a href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>ifft</code></a>. Note that this function silently drops the imaginary part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.irreducible_kcoords-Tuple{MonkhorstPack, AbstractVector{&lt;:SymOp}}" href="#DFTK.irreducible_kcoords-Tuple{MonkhorstPack, AbstractVector{&lt;:SymOp}}"><code>DFTK.irreducible_kcoords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">irreducible_kcoords(
    kgrid::MonkhorstPack,
    symmetries::AbstractVector{&lt;:SymOp};
    check_symmetry
) -&gt; Union{NamedTuple{(:kcoords, :kweights), Tuple{Vector{StaticArraysCore.SVector{3, Rational{Int64}}}, Vector{Float64}}}, NamedTuple{(:kcoords, :kweights), Tuple{Vector{StaticArraysCore.SVector{3, Float64}}, Vector{Float64}}}}
</code></pre><p>Construct the irreducible wedge given the crystal <code>symmetries</code>. Returns the list of k-point coordinates and the associated weights.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.is_metal-Tuple{Any, Any}" href="#DFTK.is_metal-Tuple{Any, Any}"><code>DFTK.is_metal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_metal(eigenvalues, εF; tol) -&gt; Bool
</code></pre><pre><code class="nohighlight hljs">is_metal(eigenvalues, εF; tol)</code></pre><p>Determine whether the provided bands indicate the material is a metal, i.e. where bands are cut by the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.k_to_equivalent_kpq_permutation-Tuple{PlaneWaveBasis, Any}" href="#DFTK.k_to_equivalent_kpq_permutation-Tuple{PlaneWaveBasis, Any}"><code>DFTK.k_to_equivalent_kpq_permutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">k_to_equivalent_kpq_permutation(
    basis::PlaneWaveBasis,
    qcoord
) -&gt; Any
</code></pre><p>Return the indices of the <code>kpoints</code> shifted by <code>q</code>. That is for each <code>kpoint</code> of the <code>basis</code>: <code>kpoints[ik].coordinate + q</code> is equivalent to <code>kpoints[indices[ik]].coordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kgrid_from_maximal_spacing-Tuple{Any, Any}" href="#DFTK.kgrid_from_maximal_spacing-Tuple{Any, Any}"><code>DFTK.kgrid_from_maximal_spacing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kgrid_from_maximal_spacing(
    lattice,
    spacing;
    kshift
) -&gt; Union{MonkhorstPack, Vector{Int64}}
</code></pre><p>Build a <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> grid to ensure kpoints are at most this spacing apart (in inverse Bohrs). A reasonable spacing is <code>0.13</code> inverse Bohrs (around <span>$2π * 0.04 \AA^{-1}$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}" href="#DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}"><code>DFTK.kgrid_from_minimal_n_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kgrid_from_minimal_n_kpoints(
    lattice,
    n_kpoints::Integer;
    kshift
) -&gt; Union{MonkhorstPack, Vector{Int64}}
</code></pre><p>Selects a <a href="#DFTK.MonkhorstPack"><code>MonkhorstPack</code></a> grid size which ensures that at least a <code>n_kpoints</code> total number of <span>$k$</span>-points are used. The distribution of <span>$k$</span>-points amongst coordinate directions is as uniformly as possible, trying to achieve an identical minimal spacing in all directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D" href="#DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D"><code>DFTK.kpath_get_kcoords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kpath_get_kcoords(
    kinter::Brillouin.KPaths.KPathInterpolant{D}
) -&gt; Any
</code></pre><p>Return kpoint coordinates in reduced coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kpq_equivalent_blochwave_to_kpq-NTuple{4, Any}" href="#DFTK.kpq_equivalent_blochwave_to_kpq-NTuple{4, Any}"><code>DFTK.kpq_equivalent_blochwave_to_kpq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kpq_equivalent_blochwave_to_kpq(
    basis,
    kpt,
    q,
    ψk_plus_q_equivalent
) -&gt; NamedTuple{(:kpt, :ψk), _A} where _A&lt;:Tuple{Kpoint, Any}
</code></pre><p>Create the Fourier expansion of <span>$ψ_{k+q}$</span> from <span>$ψ_{[k+q]}$</span>, where <span>$[k+q]$</span> is in <code>basis.kpoints</code>. while <span>$k+q$</span> may or may not be inside.</p><p>If <span>$ΔG ≔ [k+q] - (k+q)$</span>, then we have that</p><p class="math-container">\[    ∑_G \hat{u}_{[k+q]}(G) e^{i(k+q+G)·r} &amp;= ∑_{G&#39;} \hat{u}_{k+q}(G&#39;-ΔG) e^{i(k+q+ΔG+G&#39;)·r},\]</p><p>hence</p><p class="math-container">\[    u_{k+q}(G) = u_{[k+q]}(G + ΔG).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}" href="#DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}"><code>DFTK.krange_spin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krange_spin(basis::PlaneWaveBasis, spin::Integer) -&gt; Any
</code></pre><p>Return the index range of <span>$k$</span>-points that have a particular spin component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.kwargs_scf_checkpoints-Tuple{DFTK.AbstractBasis}" href="#DFTK.kwargs_scf_checkpoints-Tuple{DFTK.AbstractBasis}"><code>DFTK.kwargs_scf_checkpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kwargs_scf_checkpoints(
    basis::DFTK.AbstractBasis;
    filename,
    callback,
    diagtolalg,
    ρ,
    ψ,
    save_ψ,
    kwargs...
) -&gt; NamedTuple{(:callback, :diagtolalg, :ψ, :ρ), _A} where _A&lt;:Tuple{ComposedFunction{ScfDefaultCallback, ScfSaveCheckpoints}, AdaptiveDiagtol, Any, Any}
</code></pre><p>Transparently handle checkpointing by either returning kwargs for <code>self_consistent_field</code>, which start checkpointing (if no checkpoint file is present) or that continue a checkpointed run (if a checkpoint file can be loaded). <code>filename</code> is the location where the checkpoint is saved, <code>save_ψ</code> determines whether orbitals are saved in the checkpoint as well. The latter is discouraged, since generally slow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/self_consistent_field.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.list_psp" href="#DFTK.list_psp"><code>DFTK.list_psp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">list_psp() -&gt; Any
list_psp(element; family, functional, core) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">list_psp(element; functional, family, core)</code></pre><p>List the pseudopotential files known to DFTK. Allows various ways to restrict the displayed files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(; family=&quot;hgh&quot;)</code></pre><p>will list all HGH-type pseudopotentials and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(; family=&quot;hgh&quot;, functional=&quot;lda&quot;)</code></pre><p>will only list those for LDA (also known as Pade in this context) and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(:O, core=:semicore)</code></pre><p>will list all oxygen semicore pseudopotentials known to DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/list_psp.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.load_psp-Tuple{AbstractString}" href="#DFTK.load_psp-Tuple{AbstractString}"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_psp(
    key::AbstractString;
    kwargs...
) -&gt; Union{PspHgh{Float64}, PspUpf}
</code></pre><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>datadir_psp()</code> and by the <code>key</code>. If the <code>key</code> is a path to a valid file, the extension is used to determine the type of the pseudopotential file format and a respective class is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/load_psp.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.load_scfres" href="#DFTK.load_scfres"><code>DFTK.load_scfres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_scfres(filename::AbstractString) -&gt; Any
load_scfres(
    filename::AbstractString,
    basis;
    skip_hamiltonian,
    strict
) -&gt; Any
</code></pre><p>Load back an <code>scfres</code>, which has previously been stored with <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>. Note the warning in <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>.</p><p>If <code>basis</code> is <code>nothing</code>, the basis is also loaded and reconstructed from the file, in which case <code>architecture=CPU()</code>. If a <code>basis</code> is passed, this one is used, which can be used to continue computation on a slightly different model or to avoid the cost of rebuilding the basis. If the stored basis and the passed basis are inconsistent (e.g. different FFT size, Ecut, k-points etc.) the <code>load_scfres</code> will error out.</p><p>By default the <code>energies</code> and <code>ham</code> (<code>Hamiltonian</code> object) are recomputed. To avoid this, set <code>skip_hamiltonian=true</code>. On errors the routine exits unless <code>strict=false</code> in which case it tries to recover from the file as much data as it can, but then the resulting <code>scfres</code> might not be fully consistent.</p><div class="admonition is-warning"><header class="admonition-header">No compatibility guarantees</header><div class="admonition-body"><p>No guarantees are made with respect to this function at this point. It may change incompatibly between DFTK versions (including patch versions) or stop working / be removed in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scfres.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}" href="#DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}"><code>DFTK.model_DFT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_DFT(
    lattice::AbstractMatrix,
    atoms::Vector{&lt;:DFTK.Element},
    positions::Vector{&lt;:AbstractVector},
    xc::Xc;
    extra_terms,
    kwargs...
) -&gt; Model
</code></pre><p>Build a DFT model from the specified atoms, with the specified functionals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/standard_models.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_LDA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_LDA(
    lattice::AbstractMatrix,
    atoms::Vector{&lt;:DFTK.Element},
    positions::Vector{&lt;:AbstractVector};
    kwargs...
) -&gt; Model
</code></pre><p>Build an LDA model (Perdew &amp; Wang parametrization) from the specified atoms. DOI:10.1103/PhysRevB.45.13244</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/standard_models.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_PBE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_PBE(
    lattice::AbstractMatrix,
    atoms::Vector{&lt;:DFTK.Element},
    positions::Vector{&lt;:AbstractVector};
    kwargs...
) -&gt; Model
</code></pre><p>Build an PBE-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.77.3865</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/standard_models.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_SCAN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_SCAN(
    lattice::AbstractMatrix,
    atoms::Vector{&lt;:DFTK.Element},
    positions::Vector{&lt;:AbstractVector};
    kwargs...
) -&gt; Model
</code></pre><p>Build a SCAN meta-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.115.036402</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/standard_models.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_atomic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_atomic(
    lattice::AbstractMatrix,
    atoms::Vector{&lt;:DFTK.Element},
    positions::Vector{&lt;:AbstractVector};
    extra_terms,
    kinetic_blowup,
    kwargs...
) -&gt; Model
</code></pre><p>Convenience constructor, which builds a standard atomic (kinetic + atomic potential) model. Use <code>extra_terms</code> to add additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/standard_models.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.mpi_nprocs" href="#DFTK.mpi_nprocs"><code>DFTK.mpi_nprocs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_nprocs() -&gt; Int64
mpi_nprocs(comm) -&gt; Int64
</code></pre><p>Number of processors used in MPI. Can be called without ensuring initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/mpi.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.multiply_ψ_by_blochwave-Tuple{PlaneWaveBasis, Any, Any, Any}" href="#DFTK.multiply_ψ_by_blochwave-Tuple{PlaneWaveBasis, Any, Any, Any}"><code>DFTK.multiply_ψ_by_blochwave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiply_ψ_by_blochwave(
    basis::PlaneWaveBasis,
    ψ,
    f_real,
    q
) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">multiply_ψ_by_blochwave(basis::PlaneWaveBasis, ψ, f_real, q)</code></pre><p>Return the Fourier coefficients for the Bloch waves <span>$f^{\rm real}_{q} ψ_{k-q}$</span> in an element of <code>basis.kpoints</code> equivalent to <span>$k-q$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_elec_core-Tuple{DFTK.Element}" href="#DFTK.n_elec_core-Tuple{DFTK.Element}"><code>DFTK.n_elec_core</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_elec_core(el::DFTK.Element) -&gt; Any
</code></pre><p>Return the number of core electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_elec_valence-Tuple{DFTK.Element}" href="#DFTK.n_elec_valence-Tuple{DFTK.Element}"><code>DFTK.n_elec_valence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_elec_valence(el::DFTK.Element) -&gt; Any
</code></pre><p>Return the number of valence electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/elements.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.n_electrons_from_atoms-Tuple{Any}" href="#DFTK.n_electrons_from_atoms-Tuple{Any}"><code>DFTK.n_electrons_from_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_electrons_from_atoms(atoms) -&gt; Any
</code></pre><p>Number of valence electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T" href="#DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T"><code>DFTK.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    ψ0;
    tol,
    tol_cg,
    maxiter,
    callback,
    is_converged
) -&gt; NamedTuple{(:ham, :basis, :energies, :converged, :ρ, :eigenvalues, :occupation, :εF, :n_iter, :ψ, :stage, :algorithm, :runtime_ns), _A} where _A&lt;:Tuple{Hamiltonian, PlaneWaveBasis, Energies, Any, AbstractArray{_A, 4} where _A, Vector{Any}, Vector, Nothing, Int64, Any, Symbol, String, UInt64}
</code></pre><pre><code class="nohighlight hljs">newton(basis::PlaneWaveBasis{T}, ψ0;
       tol=1e-6, tol_cg=tol / 100, maxiter=20, callback=ScfDefaultCallback(),
       is_converged=ScfConvergenceDensity(tol))</code></pre><p>Newton algorithm. Be careful that the starting point needs to be not too far from the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/newton.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.next_compatible_fft_size-Tuple{Int64}" href="#DFTK.next_compatible_fft_size-Tuple{Int64}"><code>DFTK.next_compatible_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_compatible_fft_size(
    size::Int64;
    smallprimes,
    factors
) -&gt; Int64
</code></pre><p>Find the next compatible FFT size Sizes must (a) be a product of small primes only and (b) contain the factors. If smallprimes is empty (a) is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/fft.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.next_density" href="#DFTK.next_density"><code>DFTK.next_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_density(
    ham::Hamiltonian
) -&gt; NamedTuple{(:ψ, :eigenvalues, :occupation, :εF, :ρout, :diagonalization, :n_bands_converge, :occupation_threshold), _A} where _A&lt;:Tuple{Vector, Vector, Any, Number, AbstractArray{_A, 4} where _A, NamedTuple{(:λ, :X, :residual_norms, :n_iter, :converged, :n_matvec), _A} where _A&lt;:Tuple{Vector, Vector, Vector, Vector, Union{Missing, Bool}, Any}, Int64, Float64}
next_density(
    ham::Hamiltonian,
    nbandsalg::DFTK.NbandsAlgorithm
) -&gt; NamedTuple{(:ψ, :eigenvalues, :occupation, :εF, :ρout, :diagonalization, :n_bands_converge, :occupation_threshold), _A} where _A&lt;:Tuple{Vector, Vector, Any, Number, AbstractArray{_A, 4} where _A, NamedTuple{(:λ, :X, :residual_norms, :n_iter, :converged, :n_matvec), _A} where _A&lt;:Tuple{Vector, Vector, Vector, Vector, Union{Missing, Bool}, Any}, Int64, Any}
next_density(
    ham::Hamiltonian,
    nbandsalg::DFTK.NbandsAlgorithm,
    fermialg::AbstractFermiAlgorithm;
    eigensolver,
    ψ,
    eigenvalues,
    occupation,
    kwargs...
) -&gt; NamedTuple{(:ψ, :eigenvalues, :occupation, :εF, :ρout, :diagonalization, :n_bands_converge, :occupation_threshold), _A} where _A&lt;:Tuple{Vector, Vector, Any, Number, AbstractArray{_A, 4} where _A, NamedTuple{(:λ, :X, :residual_norms, :n_iter, :converged, :n_matvec), _A} where _A&lt;:Tuple{Vector, Vector, Vector, Vector, Union{Missing, Bool}, Any}, Int64, Any}
</code></pre><p>Obtain new density ρ by diagonalizing <code>ham</code>. Follows the policy imposed by the <code>bands</code> data structure to determine and adjust the number of bands to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/self_consistent_field.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.norm2-Tuple{Any}" href="#DFTK.norm2-Tuple{Any}"><code>DFTK.norm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm2(G) -&gt; Any
</code></pre><p>Square of the ℓ²-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/norm.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.norm_cplx-Tuple{Any}" href="#DFTK.norm_cplx-Tuple{Any}"><code>DFTK.norm_cplx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_cplx(x) -&gt; Any
</code></pre><p>Complex-analytic extension of <code>LinearAlgebra.norm(x)</code> from real to complex inputs. Needed for phonons as we want to perform a matrix-vector product <code>f&#39;(x)·h</code>, where <code>f</code> is a real-to-real function and <code>h</code> a complex vector. To do this using automatic differentiation, we can extend analytically f to accept complex inputs, then differentiate <code>t -&gt; f(x+t·h)</code>. This will fail if non-analytic functions like norm are used for complex inputs, and therefore we have to redefine it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/norm.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.normalize_kpoint_coordinate-Tuple{Real}" href="#DFTK.normalize_kpoint_coordinate-Tuple{Real}"><code>DFTK.normalize_kpoint_coordinate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_kpoint_coordinate(x::Real) -&gt; Any
</code></pre><p>Bring <span>$k$</span>-point coordinates into the range [-0.5, 0.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Vararg{Any, 5}}" href="#DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Vararg{Any, 5}}"><code>DFTK.overlap_Mmn_k_kpb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap_Mmn_k_kpb(
    basis::PlaneWaveBasis,
    ψ,
    ik,
    ikpb,
    G_shift,
    n_bands
) -&gt; Any
</code></pre><p>Computes the matrix <span>$[M^{k,b}]_{m,n} = \langle u_{m,k} | u_{n,k+b} \rangle$</span> for given <code>k</code>, <code>kpb</code> = <span>$k+b$</span>.</p><p><code>G_shift</code> is the &quot;shifting&quot; vector, correction due to the periodicity conditions imposed on <span>$k \to  ψ_k$</span>. It is non zero if <code>kpb</code> is taken in another unit cell of the reciprocal lattice. We use here that: <span>$u_{n(k + G_{\rm shift})}(r) = e^{-i*\langle G_{\rm shift},r \rangle} u_{nk}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.phonon_modes-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T" href="#DFTK.phonon_modes-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T"><code>DFTK.phonon_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phonon_modes(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    dynmat
) -&gt; NamedTuple{(:frequencies, :vectors), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Solve the eigenproblem for a dynamical matrix: returns the <code>frequencies</code> and eigenvectors (<code>vectors</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/phonon.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.plot_bandstructure" href="#DFTK.plot_bandstructure"><code>DFTK.plot_bandstructure</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute and plot the band structure. Kwargs are like in <a href="#DFTK.compute_bands-Tuple{Any, Brillouin.KPaths.KPath}"><code>compute_bands</code></a>. Requires Plots.jl to be loaded to be defined and working properly. The unit used to plot the bands can be selected using the <code>unit</code> parameter. Like in the rest of DFTK Hartree is used by default. Another standard choices is <code>unit=u&quot;eV&quot;</code> (electron volts).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.plot_dos" href="#DFTK.plot_dos"><code>DFTK.plot_dos</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the density of states over a reasonable range. Requires to load <code>Plots.jl</code> beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/dos.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.psp_local_polynomial" href="#DFTK.psp_local_polynomial"><code>DFTK.psp_local_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psp_local_polynomial(T, psp::PspHgh) -&gt; Any
psp_local_polynomial(T, psp::PspHgh, t) -&gt; Any
</code></pre><p>The local potential of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) / (t^2 exp(t^2 / 2))$</span> where <span>$t = r_\text{loc} q$</span> and <code>Q</code> is a polynomial of at most degree 8. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspHgh.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.psp_projector_polynomial" href="#DFTK.psp_projector_polynomial"><code>DFTK.psp_projector_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">psp_projector_polynomial(T, psp::PspHgh, i, l) -&gt; Any
psp_projector_polynomial(T, psp::PspHgh, i, l, t) -&gt; Any
</code></pre><p>The nonlocal projectors of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) exp(-t^2 / 2)$</span> where <span>$t = r_l q$</span> and <code>Q</code> is a polynomial. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspHgh.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T" href="#DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T"><code>DFTK.qcut_psp_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qcut_psp_local(psp::PspHgh{T}) -&gt; Any
</code></pre><p>Estimate an upper bound for the argument <code>q</code> after which <code>abs(eval_psp_local_fourier(psp, q))</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspHgh.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T" href="#DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T"><code>DFTK.qcut_psp_projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qcut_psp_projector(psp::PspHgh{T}, i, l) -&gt; Any
</code></pre><p>Estimate an upper bound for the argument <code>q</code> after which <code>eval_psp_projector_fourier(psp, q)</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/pseudo/PspHgh.jl#L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.r_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors(
    basis::PlaneWaveBasis
) -&gt; AbstractArray{StaticArraysCore.SVector{3, VT}, 3} where VT&lt;:Real
</code></pre><pre><code class="nohighlight hljs">r_vectors(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in reduced coordinates. By convention, this is in [0,1)^3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors_cart(basis::PlaneWaveBasis) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">r_vectors_cart(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.radial_hydrogenic-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}, Tuple{AbstractVector{T}, Integer, Real}} where T&lt;:Real" href="#DFTK.radial_hydrogenic-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}, Tuple{AbstractVector{T}, Integer, Real}} where T&lt;:Real"><code>DFTK.radial_hydrogenic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radial_hydrogenic(
    r::AbstractArray{T&lt;:Real, 1},
    n::Integer
) -&gt; Any
radial_hydrogenic(
    r::AbstractArray{T&lt;:Real, 1},
    n::Integer,
    α::Real
) -&gt; Any
</code></pre><p>Radial functions from solutions of Hydrogenic Schrödinger equation. Same as Wannier90 user guide Table 3.3.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: radial grid</li><li><code>n</code>: principal quantum number</li><li><code>α</code>: diffusivity, <span>$\frac{Z}/{a}$</span> where <span>$Z$</span> is the atomic number and   <span>$a$</span> is the Bohr radius.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/hydrogenic.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.random_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Integer}} where T" href="#DFTK.random_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Integer}} where T"><code>DFTK.random_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_density(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    n_electrons::Integer
) -&gt; Any
</code></pre><p>Build a random charge density normalized to the provided number of electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/density_methods.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.read_w90_nnkp-Tuple{String}" href="#DFTK.read_w90_nnkp-Tuple{String}"><code>DFTK.read_w90_nnkp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_w90_nnkp(
    fileprefix::String
) -&gt; NamedTuple{(:nntot, :nnkpts), Tuple{Int64, Vector{NamedTuple{(:ik, :ikpb, :G_shift), Tuple{Int64, Int64, Vector{Int64}}}}}}
</code></pre><p>Read the .nnkp file provided by the preprocessing routine of Wannier90 (i.e. &quot;wannier90.x -pp prefix&quot;) Returns:</p><ol><li>the array &#39;nnkpts&#39; of k points, their respective nearest neighbors and associated shifing vectors (non zero if the neighbor is located in another cell).</li><li>the number &#39;nntot&#39; of neighbors per k point.</li></ol><p>TODO: add the possibility to exclude bands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.reducible_kcoords-Tuple{MonkhorstPack}" href="#DFTK.reducible_kcoords-Tuple{MonkhorstPack}"><code>DFTK.reducible_kcoords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducible_kcoords(
    kgrid::MonkhorstPack
) -&gt; NamedTuple{(:kcoords,), Tuple{Vector{StaticArraysCore.SVector{3, Rational{Int64}}}}}
</code></pre><p>Construct the coordinates of the k-points in a (shifted) Monkhorst-Pack grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/bzmesh.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.run_wannier90" href="#DFTK.run_wannier90"><code>DFTK.run_wannier90</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Wannerize the obtained bands using wannier90. By default all converged bands from the <code>scfres</code> are employed (change with <code>n_bands</code> kwargs) and <code>n_wannier = n_bands</code> wannier functions are computed. Random Gaussians are used as guesses by default, can be changed using the <code>projections</code> kwarg. All keyword arguments supported by Wannier90 for the disentanglement may be added as keyword arguments. The function returns the <code>fileprefix</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental feature</header><div class="admonition-body"><p>Currently this is an experimental feature, which has not yet been tested to full depth. The interface is considered unstable and may change incompatibly in the future. Use at your own risk and please report bugs in case you encounter any.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/stubs.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.save_bands-Tuple{AbstractString, NamedTuple}" href="#DFTK.save_bands-Tuple{AbstractString, NamedTuple}"><code>DFTK.save_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_bands(
    filename::AbstractString,
    band_data::NamedTuple;
    save_ψ
)
</code></pre><p>Write the computed bands to a file. On all processes, but the master one the <code>filename</code> is ignored. <code>save_ψ</code> determines whether the wavefunction is also saved or not. Note that this function can be both used on the results of <a href="#DFTK.compute_bands-Tuple{Any, Brillouin.KPaths.KPath}"><code>compute_bands</code></a> and <a href="#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>self_consistent_field</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Changes to data format reserved</header><div class="admonition-body"><p>No guarantees are made with respect to the format of the keys at this point. We may change this incompatibly between DFTK versions (including patch versions). In particular changes with respect to the ψ structure are planned.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/postprocess/band_structure.jl#L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.save_scfres-Tuple{AbstractString, NamedTuple}" href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>DFTK.save_scfres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_scfres(
    filename::AbstractString,
    scfres::NamedTuple;
    save_ψ,
    extra_data,
    compress,
    save_ρ
) -&gt; Any
</code></pre><p>Save an <code>scfres</code> obtained from <code>self_consistent_field</code> to a file. On all processes but the master one the <code>filename</code> is ignored. The format is determined from the file extension. Currently the following file extensions are recognized and supported:</p><ul><li><strong>jld2</strong>: A JLD2 file. Stores the complete state and can be used (with <a href="#DFTK.load_scfres"><code>load_scfres</code></a>) to restart an SCF from a checkpoint or post-process an SCF solution. Note that this file is also a valid HDF5 file, which can thus similarly be read by external non-Julia libraries such as h5py or similar. See <a href="../tricks/scf_checkpoints/#Saving-SCF-results-on-disk-and-SCF-checkpoints">Saving SCF results on disk and SCF checkpoints</a> for details.</li><li><strong>vts</strong>: A VTK file for visualisation e.g. in <a href="https://www.paraview.org/">paraview</a>. Stores the density, spin density, optionally bands and some metadata.</li><li><strong>json</strong>: A JSON file with basic information about the SCF run. Stores for example  the number of iterations, occupations, some information about the basis,  eigenvalues, Fermi level etc.</li></ul><p>Keyword arguments:</p><ul><li><code>save_ψ</code>: Save the orbitals as well (may lead to larger files). This is the default for <code>jld2</code>, but <code>false</code> for all other formats, where this is considerably more expensive.</li><li><code>save_ρ</code>: Save the density as well (may lead to larger files). This is the default for all but <code>json</code>.</li><li><code>extra_data</code>: Additional data to place into the file. The data is just copied like <code>fp[&quot;key&quot;] = value</code>, where <code>fp</code> is a <code>JLD2.JLDFile</code>, <code>WriteVTK.vtk_grid</code> and so on.</li><li><code>compress</code>: Apply compression to array data. Requires the <code>CodecZlib</code> package to be available.</li></ul><div class="admonition is-warning"><header class="admonition-header">Changes to data format reserved</header><div class="admonition-body"><p>No guarantees are made with respect to the format of the keys at this point. We may change this incompatibly between DFTK versions (including patch versions). In particular changes with respect to the ψ structure are planned.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scfres.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scatter_kpts_block-Tuple{PlaneWaveBasis, Union{Nothing, AbstractArray}}" href="#DFTK.scatter_kpts_block-Tuple{PlaneWaveBasis, Union{Nothing, AbstractArray}}"><code>DFTK.scatter_kpts_block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scatter_kpts_block(
    basis::PlaneWaveBasis,
    data::Union{Nothing, AbstractArray}
) -&gt; Any
</code></pre><p>Scatter the data of a quantity depending on <code>k</code>-Points from the master process to the child processes and return it as a Vector{Array}, where the outer vector is a list over all k-points. On non-master processes <code>nothing</code> may be passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L600">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_anderson_solver" href="#DFTK.scf_anderson_solver"><code>DFTK.scf_anderson_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scf_anderson_solver(

) -&gt; DFTK.var&quot;#anderson#693&quot;{DFTK.var&quot;#anderson#692#694&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, Int64}}
scf_anderson_solver(m; kwargs...) -&gt; DFTK.var&quot;#anderson#693&quot;
</code></pre><p>Create a simple anderson-accelerated SCF solver. <code>m</code> specifies the number of steps to keep the history of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_solvers.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_damping_quadratic_model-Tuple{Any, Any}" href="#DFTK.scf_damping_quadratic_model-Tuple{Any, Any}"><code>DFTK.scf_damping_quadratic_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scf_damping_quadratic_model(
    info,
    info_next;
    modeltol
) -&gt; NamedTuple{(:α, :relerror), _A} where _A&lt;:Tuple{Any, Any}
</code></pre><p>Use the two iteration states <code>info</code> and <code>info_next</code> to find a damping value from a quadratic model for the SCF energy. Returns <code>nothing</code> if the constructed model is not considered trustworthy, else returns the suggested damping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/potential_mixing.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scf_damping_solver" href="#DFTK.scf_damping_solver"><code>DFTK.scf_damping_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scf_damping_solver(

) -&gt; DFTK.var&quot;#fp_solver#689&quot;{DFTK.var&quot;#fp_solver#688#690&quot;}
scf_damping_solver(
    β
) -&gt; DFTK.var&quot;#fp_solver#689&quot;{DFTK.var&quot;#fp_solver#688#690&quot;}
</code></pre><p>Create a damped SCF solver updating the density as <code>x = β * x_new + (1 - β) * x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/scf_solvers.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.scfres_to_dict-Tuple{NamedTuple}" href="#DFTK.scfres_to_dict-Tuple{NamedTuple}"><code>DFTK.scfres_to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scfres_to_dict(
    scfres::NamedTuple;
    kwargs...
) -&gt; Dict{String, Any}
</code></pre><p>Convert an <code>scfres</code> to a dictionary representation. Intended to give a condensed set of results and useful metadata for post processing. See also the <a href="#DFTK.todict-Tuple{Energies}"><code>todict</code></a> function for the <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a> and the <a href="#DFTK.PlaneWaveBasis"><code>PlaneWaveBasis</code></a> as well as the <a href="#DFTK.band_data_to_dict-Tuple{NamedTuple}"><code>band_data_to_dict</code></a> functions, which are called by this function and their outputs merged. Only the master process returns meaningful data.</p><p>Some details on the conventions for the returned data:</p><ul><li>ρ: (fft<em>size[1], fft</em>size[2], fft<em>size[3], n</em>spin) array of density on real-space grid.</li><li>energies: Dictionary / subdirectory containing the energy terms</li><li>converged: Has the SCF reached convergence</li><li>norm_Δρ: Most recent change in ρ during an SCF step</li><li>occupation_threshold: Threshold below which orbitals are considered unoccupied</li><li>n<em>bands</em>converge: Number of bands that have been  fully converged numerically.</li><li>n_iter: Number of iterations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/input_output.jl#L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}" href="#DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}"><code>DFTK.select_eigenpairs_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_eigenpairs_all_kblocks(eigres, range) -&gt; Any
</code></pre><p>Function to select a subset of eigenpairs on each <span>$k$</span>-Point. Works on the Tuple returned by <code>diagonalize_all_kblocks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/eigen/diag.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.self_consistent_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">self_consistent_field(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real;
    ρ,
    ψ,
    tol,
    is_converged,
    maxiter,
    mixing,
    damping,
    solver,
    eigensolver,
    diagtolalg,
    nbandsalg,
    fermialg,
    callback,
    compute_consistent_energies,
    response
) -&gt; NamedTuple{(:ham, :basis, :energies, :ρ, :eigenvalues, :occupation, :εF, :ψ, :response, :converged, :occupation_threshold, :α, :n_iter, :n_bands_converge, :diagonalization, :stage, :algorithm, :runtime_ns), _A} where _A&lt;:Tuple{Hamiltonian, PlaneWaveBasis{T, VT} where {T&lt;:ForwardDiff.Dual, VT&lt;:Real}, Energies, Vararg{Any, 15}}
</code></pre><pre><code class="nohighlight hljs">self_consistent_field(basis; [tol, mixing, damping, ρ, ψ])</code></pre><p>Solve the Kohn-Sham equations with a density-based SCF algorithm using damped, preconditioned iterations where <span>$ρ_\text{next} = α P^{-1} (ρ_\text{out} - ρ_\text{in})$</span>.</p><p>Overview of parameters:</p><ul><li><code>ρ</code>:   Initial density</li><li><code>ψ</code>:   Initial orbitals</li><li><code>tol</code>: Tolerance for the density change (<span>$\|ρ_\text{out} - ρ_\text{in}\|$</span>) to flag convergence. Default is <code>1e-6</code>.</li><li><code>is_converged</code>: Convergence control callback. Typical objects passed here are <code>ScfConvergenceDensity(tol)</code> (the default), <code>ScfConvergenceEnergy(tol)</code> or <code>ScfConvergenceForce(tol)</code>.</li><li><code>maxiter</code>: Maximal number of SCF iterations</li><li><code>mixing</code>: Mixing method, which determines the preconditioner <span>$P^{-1}$</span> in the above equation. Typical mixings are <a href="#DFTK.LdosMixing-Tuple{}"><code>LdosMixing</code></a>, <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, <a href="#DFTK.SimpleMixing"><code>SimpleMixing</code></a> or <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Default is <code>LdosMixing()</code></li><li><code>damping</code>: Damping parameter <span>$α$</span> in the above equation. Default is <code>0.8</code>.</li><li><code>nbandsalg</code>: By default DFTK uses <code>nbandsalg=AdaptiveBands(model)</code>, which adaptively determines the number of bands to compute. If you want to influence this algorithm or use a predefined number of bands in each SCF step, pass a <a href="#DFTK.FixedBands"><code>FixedBands</code></a> or <a href="#DFTK.AdaptiveBands"><code>AdaptiveBands</code></a>. Beware that with non-zero temperature, the convergence of the SCF algorithm may be limited by the <code>default_occupation_threshold()</code> parameter. For highly accurate calculations we thus recommend increasing the <code>occupation_threshold</code> of the <code>AdaptiveBands</code>.</li><li><code>callback</code>: Function called at each SCF iteration. Usually takes care of printing the intermediate state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/scf/self_consistent_field.jl#L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.simpson" href="#DFTK.simpson"><code>DFTK.simpson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simpson(x, y)</code></pre><p>Integrate y(x) over x using Simpson&#39;s method quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/quadrature.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.sin2pi-Tuple{Any}" href="#DFTK.sin2pi-Tuple{Any}"><code>DFTK.sin2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sin2pi(x) -&gt; Any
</code></pre><p>Function to compute sin(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/cis2pi.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T" href="#DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T"><code>DFTK.solve_ΩplusK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_ΩplusK(
    basis::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    ψ,
    rhs,
    occupation;
    callback,
    tol
) -&gt; NamedTuple{(:δψ, :converged, :tol, :residual_norm, :n_iter), _A} where _A&lt;:Tuple{Any, Bool, Any, Any, Int64}
</code></pre><pre><code class="nohighlight hljs">solve_ΩplusK(basis::PlaneWaveBasis{T}, ψ, res, occupation;
             tol=1e-10, verbose=false) where {T}</code></pre><p>Return δψ where (Ω+K) δψ = rhs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/hessian.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Vararg{Any, 5}}} where T" href="#DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Vararg{Any, 5}}} where T"><code>DFTK.solve_ΩplusK_split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_ΩplusK_split(
    ham::Hamiltonian,
    ρ::AbstractArray{T},
    ψ,
    occupation,
    εF,
    eigenvalues,
    rhs;
    tol,
    tol_sternheimer,
    verbose,
    occupation_threshold,
    q,
    kwargs...
)
</code></pre><p>Solve the problem <code>(Ω+K) δψ = rhs</code> using a split algorithm, where <code>rhs</code> is typically <code>-δHextψ</code> (the negative matvec of an external perturbation with the SCF orbitals <code>ψ</code>) and <code>δψ</code> is the corresponding total variation in the orbitals <code>ψ</code>. Additionally returns:     - <code>δρ</code>:  Total variation in density)     - <code>δHψ</code>: Total variation in Hamiltonian applied to orbitals     - <code>δeigenvalues</code>: Total variation in eigenvalues     - <code>δVind</code>: Change in potential induced by <code>δρ</code> (the term needed on top of <code>δHextψ</code>       to get <code>δHψ</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/response/hessian.jl#L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T" href="#DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T"><code>DFTK.spglib_standardize_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spglib_standardize_cell(
    lattice::AbstractArray{T},
    atom_groups,
    positions
) -&gt; NamedTuple{(:lattice, :atom_groups, :positions, :magnetic_moments), _A} where _A&lt;:Tuple{Matrix, Any, Any, Vector{StaticArraysCore.SVector{3, Float64}}}
spglib_standardize_cell(
    lattice::AbstractArray{T},
    atom_groups,
    positions,
    magnetic_moments;
    correct_symmetry,
    primitive,
    tol_symmetry
) -&gt; NamedTuple{(:lattice, :atom_groups, :positions, :magnetic_moments), _A} where _A&lt;:Tuple{Matrix, Any, Any, Vector{StaticArraysCore.SVector{3, Float64}}}
</code></pre><p>Returns crystallographic conventional cell according to the International Table of Crystallography Vol A (ITA) in case <code>primitive=false</code>. If <code>primitive=true</code> the primitive lattice is returned in the convention of the reference work of Cracknell, Davies, Miller, and Love (CDML). Of note this has minor differences to the primitive setting choice made in the ITA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/spglib.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T" href="#DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T"><code>DFTK.sphericalbesselj_fast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sphericalbesselj_fast(l::Integer, x) -&gt; Any
</code></pre><pre><code class="nohighlight hljs">sphericalbesselj_fast(l::Integer, x::Number)</code></pre><p>Returns the spherical Bessel function of the first kind j<em>l(x). Consistent with https://en.wikipedia.org/wiki/Bessel</em>function#Spherical<em>Bessel</em>functions and with <code>SpecialFunctions.sphericalbesselj</code>. Specialized for integer <code>0 &lt;= l &lt;= 5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/spherical_bessels.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.spin_components-Tuple{Symbol}" href="#DFTK.spin_components-Tuple{Symbol}"><code>DFTK.spin_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spin_components(
    spin_polarization::Symbol
) -&gt; Union{Bool, Tuple{Symbol}, Tuple{Symbol, Symbol}}
</code></pre><p>Explicit spin components of the KS orbitals and the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Model.jl#L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.split_evenly-Tuple{Any, Any}" href="#DFTK.split_evenly-Tuple{Any, Any}"><code>DFTK.split_evenly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_evenly(itr, N) -&gt; Any
</code></pre><p>Split an iterable evenly into N chunks, which will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/split_evenly.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.standardize_atoms" href="#DFTK.standardize_atoms"><code>DFTK.standardize_atoms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standardize_atoms(
    lattice,
    atoms,
    positions
) -&gt; NamedTuple{(:lattice, :atoms, :positions, :magnetic_moments), _A} where _A&lt;:Tuple{Matrix, Any, Any, Vector{StaticArraysCore.SVector{3, Float64}}}
standardize_atoms(
    lattice,
    atoms,
    positions,
    magnetic_moments;
    kwargs...
) -&gt; NamedTuple{(:lattice, :atoms, :positions, :magnetic_moments), _A} where _A&lt;:Tuple{Matrix, Any, Any, Vector{StaticArraysCore.SVector{3, Float64}}}
</code></pre><p>Apply various standardisations to a lattice and a list of atoms. It uses spglib to detect symmetries (within <code>tol_symmetry</code>), then cleans up the lattice according to the symmetries (unless <code>correct_symmetry</code> is <code>false</code>) and returns the resulting standard lattice and atoms. If <code>primitive</code> is <code>true</code> (default) the primitive unit cell is returned, else the conventional unit cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_kgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetries_preserving_kgrid(symmetries, kcoords) -&gt; Any
</code></pre><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete BZ grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_rgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetries_preserving_rgrid(symmetries, fft_size) -&gt; Any
</code></pre><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete real-space grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_forces-Tuple{Model, Any}" href="#DFTK.symmetrize_forces-Tuple{Model, Any}"><code>DFTK.symmetrize_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize_forces(model::Model, forces; symmetries)
</code></pre><p>Symmetrize the forces in <em>reduced coordinates</em>, forces given as an array forces[iel][α,i]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_stresses-Tuple{Model, Any}" href="#DFTK.symmetrize_stresses-Tuple{Model, Any}"><code>DFTK.symmetrize_stresses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize_stresses(model::Model, stresses; symmetries)
</code></pre><p>Symmetrize the stress tensor, given as a Matrix in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetrize_ρ-Union{Tuple{T}, Tuple{Any, AbstractArray{T}}} where T" href="#DFTK.symmetrize_ρ-Union{Tuple{T}, Tuple{Any, AbstractArray{T}}} where T"><code>DFTK.symmetrize_ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetrize_ρ(
    basis,
    ρ::AbstractArray{T};
    symmetries,
    do_lowpass
) -&gt; Any
</code></pre><p>Symmetrize a density by applying all the basis (by default) symmetries and forming the average.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetry_operations" href="#DFTK.symmetry_operations"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmetry_operations(
    lattice,
    atoms,
    positions
) -&gt; Union{Vector{SymOp{Bool}}, Vector{SymOp{Float64}}}
symmetry_operations(
    lattice,
    atoms,
    positions,
    magnetic_moments;
    tol_symmetry,
    check_symmetry
) -&gt; Union{Vector{SymOp{Bool}}, Vector{SymOp{Float64}}}
</code></pre><p>Return the symmetries given an atomic structure with optionally designated magnetic moments on each of the atoms. The symmetries are determined using spglib.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.symmetry_operations-Tuple{Integer}" href="#DFTK.symmetry_operations-Tuple{Integer}"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symmetry_operations(
    hall_number::Integer
) -&gt; Vector{SymOp{Float64}}
</code></pre><p>Return the Symmetry operations given a <code>hall_number</code>.</p><p>This function allows to directly access to the space group operations in the <code>spglib</code> database. To specify the space group type with a specific choice, <code>hall_number</code> is used.</p><p>The definition of <code>hall_number</code> is found at <a href="https://spglib.readthedocs.io/en/latest/dataset.html#dataset-spg-get-dataset-spacegroup-type">Space group type</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}" href="#DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}"><code>DFTK.synchronize_device</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synchronize_device(_::DFTK.AbstractArchitecture)
</code></pre><p>Synchronize data and finish all operations on the execution stream of the device. This needs to be called explicitly before a task finishes (e.g. in an <code>@spawn</code> block).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/architecture.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.to_cpu-Tuple{AbstractArray}" href="#DFTK.to_cpu-Tuple{AbstractArray}"><code>DFTK.to_cpu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_cpu(x::AbstractArray) -&gt; Array
</code></pre><p>Transfer an array from a device (typically a GPU) to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/architecture.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.to_device-Tuple{DFTK.CPU, Any}" href="#DFTK.to_device-Tuple{DFTK.CPU, Any}"><code>DFTK.to_device</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_device(_::DFTK.CPU, x) -&gt; Any
</code></pre><p>Transfer an array to a particular device (typically a GPU)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/architecture.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.todict-Tuple{Energies}" href="#DFTK.todict-Tuple{Energies}"><code>DFTK.todict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">todict(energies::Energies) -&gt; Dict
</code></pre><p>Convert an <code>Energies</code> struct to a dictionary representation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Energies.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.todict-Tuple{Model}" href="#DFTK.todict-Tuple{Model}"><code>DFTK.todict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">todict(model::Model) -&gt; Dict{String, Any}
</code></pre><p>Convert a <code>Model</code> struct to a dictionary representation. Intended to give a condensed set of useful metadata to post-processing scripts or for storing computational results (e.g. bands, bloch waves etc.).</p><p>Some details on the conventions for the returned data:</p><ul><li>lattice, recip_lattice: Always a zero-padded 3x3 matrix, independent on the actual dimension</li><li>atomic<em>positions, atomic</em>positions_cart: Atom positions in fractional or cartesian coordinates, respectively.</li><li>atomic_symbols: Atomic symbols if known.</li><li>terms: Some rough information on the terms used for the computation.</li><li>n_electrons: Number of electrons, may be missing if εF is fixed instead</li><li>εF: Fixed Fermi level to use, may be missing if n_electronis is specified instead.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/input_output.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.todict-Tuple{PlaneWaveBasis}" href="#DFTK.todict-Tuple{PlaneWaveBasis}"><code>DFTK.todict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">todict(basis::PlaneWaveBasis) -&gt; Dict{String, Any}
</code></pre><p>Convert a <code>PlaneWaveBasis</code> struct to a dictionary representation. Intended to give a condensed set of useful metadata to post-processing scripts or for storing computational results (e.g. bands, bloch waves etc.). As such the function is lossy and might not keep all data consistently. Returns the same result on all MPI processors. See also the <a href="#DFTK.todict-Tuple{Energies}"><code>todict</code></a> function for the <code>Model</code>, which is called from this one to merge the data of both outputs.</p><p>Some details on the conventions for the returned data:</p><ul><li>dvol: Volume element for real-space integration</li><li>variational: Is the k-point specific basis (for ψ) variationally consistent with the basis for ρ.</li><li>kweights: Weights for the k-points, summing to 1.0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/input_output.jl#L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.total_local_potential-Tuple{Hamiltonian}" href="#DFTK.total_local_potential-Tuple{Hamiltonian}"><code>DFTK.total_local_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_local_potential(ham::Hamiltonian) -&gt; Any
</code></pre><p>Get the total local potential of the given Hamiltonian, in real space in the spin components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/terms/Hamiltonian.jl#L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.transfer_blochwave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_blochwave(
    ψ_in,
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real
) -&gt; Any
</code></pre><p>Transfer Bloch wave between two basis sets. Limited feature set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}" href="#DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_blochwave_kpt(
    ψk_in,
    basis::PlaneWaveBasis,
    kpt_in,
    kpt_out,
    ΔG
) -&gt; Any
</code></pre><p>Transfer an array <code>ψk_in</code> expanded on <code>kpt_in</code>, and produce <span>$ψ(r) e^{i ΔG·r}$</span> expanded on <code>kpt_out</code>. It is mostly useful for phonons. Beware: <code>ψk_out</code> can lose information if the shift <code>ΔG</code> is large or if the <code>G_vectors</code> differ between <code>k</code>-points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_blochwave_kpt(
    ψk_in,
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_in::Kpoint,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_out::Kpoint
) -&gt; Any
</code></pre><p>Transfer an array <code>ψk</code> defined on basis<em>in <span>$k$</span>-point kpt</em>in to basis<em>out <span>$k$</span>-point kpt</em>out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_density-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.transfer_density-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.transfer_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_density(
    ρ_in,
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real
) -&gt; Any
</code></pre><p>Transfer density (in real space) between two basis sets.</p><p>This function is fast by transferring only the Fourier coefficients from the small basis to the big basis.</p><p>Note that this implies that for even-sized small FFT grids doing the transfer small -&gt; big -&gt; small is not an identity (as the small basis has an unmatched Fourier component and the identity <span>$c_G = c_{-G}^\ast$</span> does not fully hold).</p><p>Note further that for the direction big -&gt; small employing this function does not give the same answer as using first <code>transfer_blochwave</code> and then <code>compute_density</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_mapping-Tuple{PlaneWaveBasis, PlaneWaveBasis}" href="#DFTK.transfer_mapping-Tuple{PlaneWaveBasis, PlaneWaveBasis}"><code>DFTK.transfer_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_mapping(
    basis_in::PlaneWaveBasis,
    basis_out::PlaneWaveBasis
) -&gt; Base.Iterators.Zip{Tuple{Array{CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}, 3}, Array{CartesianIndices{3, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}}, 3}}}
</code></pre><p>Compute the index mapping between the global grids of two bases. Returns an iterator of 8 pairs <code>(block_in, block_out)</code>. Iterated over these pairs <code>x_out_fourier[block_out, :] = x_in_fourier[block_in, :]</code> does the transfer from the Fourier coefficients <code>x_in_fourier</code> (defined on <code>basis_in</code>) to <code>x_out_fourier</code> (defined on <code>basis_out</code>, equally provided as Fourier coefficients).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transfer_mapping(
    basis_in::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_in::Kpoint,
    basis_out::PlaneWaveBasis{T, VT} where VT&lt;:Real,
    kpt_out::Kpoint
) -&gt; Tuple{Any, Any}
</code></pre><p>Compute the index mapping between two bases. Returns two arrays <code>idcs_in</code> and <code>idcs_out</code> such that <code>ψkout[idcs_out] = ψkin[idcs_in]</code> does the transfer from <code>ψkin</code> (defined on <code>basis_in</code> and <code>kpt_in</code>) to <code>ψkout</code> (defined on <code>basis_out</code> and <code>kpt_out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/transfer.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.trapezoidal" href="#DFTK.trapezoidal"><code>DFTK.trapezoidal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trapezoidal(x, y)</code></pre><p>Integrate y(x) over x using trapezoidal method quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/quadrature.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.unfold_bz-Tuple{PlaneWaveBasis}" href="#DFTK.unfold_bz-Tuple{PlaneWaveBasis}"><code>DFTK.unfold_bz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unfold_bz(basis::PlaneWaveBasis) -&gt; PlaneWaveBasis
</code></pre><p>&quot; Convert a <code>basis</code> into one that doesn&#39;t use BZ symmetry. This is mainly useful for debug purposes (e.g. in cases we don&#39;t want to bother thinking about symmetries).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/symmetry.jl#L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.versioninfo" href="#DFTK.versioninfo"><code>DFTK.versioninfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">versioninfo()
versioninfo(io::IO)
</code></pre><pre><code class="nohighlight hljs">DFTK.versioninfo([io::IO=stdout])</code></pre><p>Summary of version and configuration of DFTK and its key dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/versioninfo.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}" href="#DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}"><code>DFTK.weighted_ksum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted_ksum(basis::PlaneWaveBasis, array) -&gt; Any
</code></pre><p>Sum an array over kpoints, taking weights into account</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/PlaneWaveBasis.jl#L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.write_w90_eig-Tuple{String, Any}" href="#DFTK.write_w90_eig-Tuple{String, Any}"><code>DFTK.write_w90_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90_eig(fileprefix::String, eigenvalues; n_bands)
</code></pre><p>Write the eigenvalues in a format readable by Wannier90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}" href="#DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}"><code>DFTK.write_w90_win</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90_win(
    fileprefix::String,
    basis::PlaneWaveBasis;
    bands_plot,
    wannier_plot,
    kwargs...
)
</code></pre><p>Write a win file at the indicated prefix. Parameters to Wannier90 can be added as kwargs: e.g. <code>num_iter=500</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.write_wannier90_files-Tuple{Any, Any}" href="#DFTK.write_wannier90_files-Tuple{Any, Any}"><code>DFTK.write_wannier90_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_wannier90_files(
    preprocess_call,
    scfres;
    n_bands,
    n_wannier,
    projections,
    fileprefix,
    wannier_plot,
    kwargs...
)
</code></pre><p>Shared file writing code for Wannier.jl and Wannier90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/external/wannier_shared.jl#L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T" href="#DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T"><code>DFTK.ylm_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ylm_real(
    l::Integer,
    m::Integer,
    rvec::AbstractArray{T, 1}
) -&gt; Any
</code></pre><p>Returns the (l,m) real spherical harmonic Y<em>lm(r). Consistent with https://en.wikipedia.org/wiki/Table</em>of<em>spherical</em>harmonics#Real<em>spherical</em>harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/spherical_harmonics.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.zeros_like" href="#DFTK.zeros_like"><code>DFTK.zeros_like</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeros_like(X::AbstractArray) -&gt; Any
zeros_like(
    X::AbstractArray,
    T::Type,
    dims::Integer...
) -&gt; Any
</code></pre><p>Create an array of same &quot;array type&quot; as X filled with zeros, minimizing the number of allocations. This unifies CPU and GPU code, as the output will always be on the same device as the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/zeros_like.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.@timing-Tuple" href="#DFTK.@timing-Tuple"><code>DFTK.@timing</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Shortened version of the <code>@timeit</code> macro from <code>TimerOutputs</code>, which writes to the DFTK timer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/common/timer.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.A-Tuple{Any, Any}" href="#DFTK.Smearing.A-Tuple{Any, Any}"><code>DFTK.Smearing.A</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>A</code> term in the Hermite delta expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L113-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.H-Tuple{Any, Any}" href="#DFTK.Smearing.H-Tuple{Any, Any}"><code>DFTK.Smearing.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard Hermite function using physicist&#39;s convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Entropy. Note that this is a function of the energy <code>x</code>, not of <code>occupation(x)</code>. This function satisfies s&#39; = x f&#39; (see https://www.vasp.at/vasp-workshop/k-points.pdf p. 12 and https://arxiv.org/pdf/1805.07144.pdf p. 18.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation" href="#DFTK.Smearing.occupation"><code>DFTK.Smearing.occupation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">occupation(S::SmearingFunction, x)</code></pre><p>Occupation at <code>x</code>, where in practice <code>x = (ε - εF) / temperature</code>. If temperature is zero, <code>(ε-εF)/temperature  = ±∞</code>. The occupation function is required to give 1 and 0 respectively in these cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.occupation_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Derivative of the occupation function, approximation to minus the delta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Vararg{Any, 4}}" href="#DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Vararg{Any, 4}}"><code>DFTK.Smearing.occupation_divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(f(x) - f(y))/(x - y), computed stably in the case where x and y are close</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/e5e801b367dcafe3a867598b32097cf47bb949e4/src/Smearing.jl#L31-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer/gpu_computations/">« GPU computations</a><a class="docs-footer-nextpage" href="../publications/">Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 26 December 2023 11:28">Tuesday 26 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
