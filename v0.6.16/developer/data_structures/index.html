<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data structures · DFTK.jl</title><meta name="title" content="Data structures · DFTK.jl"/><meta property="og:title" content="Data structures · DFTK.jl"/><meta property="twitter:title" content="Data structures · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/developer/data_structures/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/developer/data_structures/"/><link rel="canonical" href="https://docs.dftk.org/stable/developer/data_structures/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/installation/">Installation</a></li><li><a class="tocitem" href="../../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/periodic_problems/">Problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../../guide/introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../../examples/dielectric/">Eigenvalues of the dielectric matrix</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../examples/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../setup/">Developer setup</a></li><li><a class="tocitem" href="../conventions/">Notation and conventions</a></li><li class="is-active"><a class="tocitem" href>Data structures</a><ul class="internal"><li><a class="tocitem" href="#Model-datastructure"><span><code>Model</code> datastructure</span></a></li><li><a class="tocitem" href="#PlaneWaveBasis-and-plane-wave-discretisations"><span><code>PlaneWaveBasis</code> and plane-wave discretisations</span></a></li><li><a class="tocitem" href="#Accessing-Bloch-waves-and-densities"><span>Accessing Bloch waves and densities</span></a></li></ul></li><li><a class="tocitem" href="../useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../gpu_computations/">GPU computations</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li class="is-active"><a href>Data structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data structures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/developer/data_structures.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h1><p>In this section we assume a calculation of silicon LDA model in the setup described in <a href="../../guide/tutorial/#Tutorial">Tutorial</a>.</p><h2 id="Model-datastructure"><a class="docs-heading-anchor" href="#Model-datastructure"><code>Model</code> datastructure</a><a id="Model-datastructure-1"></a><a class="docs-heading-anchor-permalink" href="#Model-datastructure" title="Permalink"></a></h2><p>The physical model to be solved is defined by the <code>Model</code> datastructure. It contains the unit cell, number of electrons, atoms, type of spin polarization and temperature. Each atom has an atomic type (<code>Element</code>) specifying the number of valence electrons and the potential (or pseudopotential) it creates with respect to the electrons. The <code>Model</code> structure also contains the list of energy terms defining the energy functional to be minimised during the SCF. For the silicon example above, we used an LDA model, which consists of the following terms<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>:</p><pre><code class="language-julia hljs">typeof.(model.term_types)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7-element Vector{DataType}:
 Kinetic{BlowupIdentity}
 AtomicLocal
 AtomicNonlocal
 Ewald
 PspCorrection
 Hartree
 Xc</code></pre><p>DFTK computes energies for all terms of the model individually, which are available in <code>scfres.energies</code>:</p><pre><code class="language-julia hljs">scfres.energies</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Energy breakdown (in Ha):
    Kinetic             3.1739292 
    AtomicLocal         -2.1467743
    AtomicNonlocal      1.5858692 
    Ewald               -8.4004648
    PspCorrection       -0.2948928
    Hartree             0.5586681 
    Xc                  -2.4031997

    total               -7.926865084245</code></pre><p>For now the following energy terms are available in DFTK:</p><ul><li>Kinetic energy</li><li>Local potential energy, either given by analytic potentials or specified by the type of atoms.</li><li>Nonlocal potential energy, for norm-conserving pseudopotentials</li><li>Nuclei energies (Ewald or pseudopotential correction)</li><li>Hartree energy</li><li>Exchange-correlation energy</li><li>Power nonlinearities (useful for Gross-Pitaevskii type models)</li><li>Magnetic field energy</li><li>Entropy term</li></ul><p>Custom types can be added if needed. For examples see the definition of the above terms in the <a href="https://dftk.org/tree/master/src/terms"><code>src/terms</code></a> directory.</p><p>By mixing and matching these terms, the user can create custom models not limited to DFT. Convenience constructors are provided for common cases:</p><ul><li><code>model_LDA</code>: LDA model using the <a href="https://doi.org/10.1103/PhysRevB.54.1703">Teter parametrisation</a></li><li><code>model_DFT</code>: Assemble a DFT model using  any of the LDA or GGA functionals of the  <a href="https://tddft.org/programs/libxc/functionals/">libxc</a> library,  for example:  <code>model_DFT(lattice, atoms, positions, [:gga_x_pbe, :gga_c_pbe])  model_DFT(lattice, atoms, positions, :lda_xc_teter93)</code>  where the latter is equivalent to <code>model_LDA</code>.  Specifying no functional is the reduced Hartree-Fock model:  <code>model_DFT(lattice, atoms, positions, [])</code></li><li><code>model_atomic</code>: A linear model, which contains no electron-electron interaction (neither Hartree nor XC term).</li></ul><h2 id="PlaneWaveBasis-and-plane-wave-discretisations"><a class="docs-heading-anchor" href="#PlaneWaveBasis-and-plane-wave-discretisations"><code>PlaneWaveBasis</code> and plane-wave discretisations</a><a id="PlaneWaveBasis-and-plane-wave-discretisations-1"></a><a class="docs-heading-anchor-permalink" href="#PlaneWaveBasis-and-plane-wave-discretisations" title="Permalink"></a></h2><p>The <code>PlaneWaveBasis</code> datastructure handles the discretization of a given <code>Model</code> in a plane-wave basis. In plane-wave methods the discretization is twofold: Once the <span>$k$</span>-point grid, which determines the sampling <em>inside</em> the Brillouin zone and on top of that a finite plane-wave grid to discretise the lattice-periodic functions. The former aspect is controlled by the <code>kgrid</code> argument of <code>PlaneWaveBasis</code>, the latter is controlled by the cutoff energy parameter <code>Ecut</code>:</p><pre><code class="language-julia hljs">PlaneWaveBasis(model; Ecut, kgrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PlaneWaveBasis discretization:
    architecture         : DFTK.CPU()
    num. mpi processes   : 1
    num. julia threads   : 1
    num. blas  threads   : 2
    num. fft   threads   : 1

    Ecut                 : 15.0 Ha
    fft_size             : (30, 30, 30), 27000 total points
    kgrid                : MonkhorstPack([4, 4, 4])
    num.   red. kpoints  : 64
    num. irred. kpoints  : 8

    Discretized Model(lda_x+lda_c_pw, 3D):
        lattice (in Bohr)    : [0         , 5.13      , 5.13      ]
                               [5.13      , 0         , 5.13      ]
                               [5.13      , 5.13      , 0         ]
        unit cell volume     : 270.01 Bohr³
    
        atoms                : Si₂
        atom potentials      : ElementPsp(Si; psp=&quot;hgh/lda/si-q4&quot;)
                               ElementPsp(Si; psp=&quot;hgh/lda/si-q4&quot;)
    
        num. electrons       : 8
        spin polarization    : none
        temperature          : 0 Ha
    
        terms                : Kinetic()
                               AtomicLocal()
                               AtomicNonlocal()
                               Ewald(nothing)
                               PspCorrection()
                               Hartree()
                               Xc(lda_x, lda_c_pw)</code></pre><p>The <code>PlaneWaveBasis</code> by default uses symmetry to reduce the number of <code>k</code>-points explicitly treated. For details see <a href="../symmetries/#Crystal-symmetries">Crystal symmetries</a>.</p><p>As mentioned, the periodic parts of Bloch waves are expanded in a set of normalized plane waves <span>$e_G$</span>:</p><p class="math-container">\[\begin{aligned}
  \psi_{k}(x) &amp;= e^{i k \cdot x} u_{k}(x)\\
  &amp;= \sum_{G \in \mathcal R^{*}} c_{G}  e^{i  k \cdot  x} e_{G}(x)
\end{aligned}\]</p><p>where <span>$\mathcal R^*$</span> is the set of reciprocal lattice vectors. The <span>$c_{{G}}$</span> are <span>$\ell^{2}$</span>-normalized. The summation is truncated to a &quot;spherical&quot;, <span>$k$</span>-dependent basis set</p><p class="math-container">\[  S_{k} = \left\{G \in \mathcal R^{*} \,\middle|\,
          \frac 1 2 |k+ G|^{2} \le E_\text{cut}\right\}\]</p><p>where <span>$E_\text{cut}$</span> is the cutoff energy.</p><p>Densities involve terms like <span>$|\psi_{k}|^{2} = |u_{k}|^{2}$</span> and therefore products <span>$e_{-{G}} e_{{G}&#39;}$</span> for <span>${G}, {G}&#39;$</span> in <span>$S_{k}$</span>. To represent these we use a &quot;cubic&quot;, <span>$k$</span>-independent basis set large enough to contain the set <span>$\{{G}-G&#39; \,|\, G, G&#39; \in S_{k}\}$</span>. We can obtain the coefficients of densities on the <span>$e_{G}$</span> basis by a convolution, which can be performed efficiently with FFTs (see <a href="../../api/#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>ifft</code></a> and <a href="../../api/#AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}"><code>fft</code></a> functions). Potentials are discretized on this same set.</p><p>The normalization conventions used in the code is that quantities stored in reciprocal space are coefficients in the <span>$e_{G}$</span> basis, and quantities stored in real space use real physical values. This means for instance that wavefunctions in the real space grid are normalized as <span>$\frac{|\Omega|}{N} \sum_{r} |\psi(r)|^{2} = 1$</span> where <span>$N$</span> is the number of grid points.</p><p>For example let us check the normalization of the first eigenfunction at the first <span>$k$</span>-point in reciprocal space:</p><pre><code class="language-julia hljs">ψtest = scfres.ψ[1][:, 1]
sum(abs2.(ψtest))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.000000000000002</code></pre><p>We now perform an IFFT to get ψ in real space. The <span>$k$</span>-point has to be passed because ψ is expressed on the <span>$k$</span>-dependent basis. Again the function is normalised:</p><pre><code class="language-julia hljs">ψreal = ifft(basis, basis.kpoints[1], ψtest)
sum(abs2.(ψreal)) * basis.dvol</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0000000000000018</code></pre><p>The list of <span>$k$</span> points of the basis can be obtained with <code>basis.kpoints</code>.</p><pre><code class="language-julia hljs">basis.kpoints</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Kpoint{Float64, Vector{StaticArraysCore.SVector{3, Int64}}}}:
 KPoint([     0,      0,      0], spin = 1, num. G vectors =   725)
 KPoint([  0.25,      0,      0], spin = 1, num. G vectors =   754)
 KPoint([  -0.5,      0,      0], spin = 1, num. G vectors =   754)
 KPoint([  0.25,   0.25,      0], spin = 1, num. G vectors =   729)
 KPoint([  -0.5,   0.25,      0], spin = 1, num. G vectors =   748)
 KPoint([ -0.25,   0.25,      0], spin = 1, num. G vectors =   754)
 KPoint([  -0.5,   -0.5,      0], spin = 1, num. G vectors =   740)
 KPoint([ -0.25,   -0.5,   0.25], spin = 1, num. G vectors =   744)</code></pre><p>The <span>$G$</span> vectors of the &quot;spherical&quot;, <span>$k$</span>-dependent grid can be obtained with <code>G_vectors</code>:</p><pre><code class="language-julia hljs">[length(G_vectors(basis, kpoint)) for kpoint in basis.kpoints]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Int64}:
 725
 754
 754
 729
 748
 754
 740
 744</code></pre><pre><code class="language-julia hljs">ik = 1
G_vectors(basis, basis.kpoints[ik])[1:4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{StaticArraysCore.SVector{3, Int64}}:
 [0, 0, 0]
 [1, 0, 0]
 [2, 0, 0]
 [3, 0, 0]</code></pre><p>The list of <span>$G$</span> vectors (Fourier modes) of the &quot;cubic&quot;, <span>$k$</span>-independent basis set can be obtained similarly with <code>G_vectors(basis)</code>.</p><pre><code class="language-julia hljs">length(G_vectors(basis)), prod(basis.fft_size)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(27000, 27000)</code></pre><pre><code class="language-julia hljs">collect(G_vectors(basis))[1:4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{StaticArraysCore.SVector{3, Int64}}:
 [0, 0, 0]
 [1, 0, 0]
 [2, 0, 0]
 [3, 0, 0]</code></pre><p>Analogously the list of <span>$r$</span> vectors (real-space grid) can be obtained with <code>r_vectors(basis)</code>:</p><pre><code class="language-julia hljs">length(r_vectors(basis))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">27000</code></pre><pre><code class="language-julia hljs">collect(r_vectors(basis))[1:4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{StaticArraysCore.SVector{3, Float64}}:
 [0.0, 0.0, 0.0]
 [0.03333333333333333, 0.0, 0.0]
 [0.06666666666666667, 0.0, 0.0]
 [0.1, 0.0, 0.0]</code></pre><h2 id="Accessing-Bloch-waves-and-densities"><a class="docs-heading-anchor" href="#Accessing-Bloch-waves-and-densities">Accessing Bloch waves and densities</a><a id="Accessing-Bloch-waves-and-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Bloch-waves-and-densities" title="Permalink"></a></h2><p>Wavefunctions are stored in an array <code>scfres.ψ</code> as <code>ψ[ik][iG, iband]</code> where <code>ik</code> is the index of the <span>$k$</span>-point (in <code>basis.kpoints</code>), <code>iG</code> is the index of the plane wave (in <code>G_vectors(basis, basis.kpoints[ik])</code>) and <code>iband</code> is the index of the band. Densities are stored in real space, as a 4-dimensional array (the third being the spin component).</p><pre><code class="language-julia hljs">rvecs = collect(r_vectors(basis))[:, 1, 1]  # slice along the x axis
x = [r[1] for r in rvecs]                   # only keep the x coordinate
plot(x, scfres.ρ[:, 1, 1, 1], label=&quot;&quot;, xlabel=&quot;x&quot;, ylabel=&quot;ρ&quot;, marker=2)</code></pre><img src="478441a8.svg" alt="Example block output"/><pre><code class="language-julia hljs">G_energies = [sum(abs2.(model.recip_lattice * G)) ./ 2 for G in G_vectors(basis)][:]
scatter(G_energies, abs.(fft(basis, scfres.ρ)[:]);
        yscale=:log10, ylims=(1e-12, 1), label=&quot;&quot;, xlabel=&quot;Energy&quot;, ylabel=&quot;|ρ|&quot;)</code></pre><img src="4b37fa93.svg" alt="Example block output"/><p>Note that the density has no components on wavevectors above a certain energy, because the wavefunctions are limited to <span>$\frac 1 2|k+G|^2 ≤ E_{\rm cut}$</span>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>If you are not familiar with Julia syntax, <code>typeof.(model.term_types)</code> is equivalent to <code>[typeof(t) for t in model.term_types]</code>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conventions/">« Notation and conventions</a><a class="docs-footer-nextpage" href="../useful_formulas/">Useful formulas »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 26 December 2023 11:28">Tuesday 26 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
