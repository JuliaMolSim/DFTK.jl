<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Comparing discretization techniques · DFTK.jl</title><meta name="title" content="Comparing discretization techniques · DFTK.jl"/><meta property="og:title" content="Comparing discretization techniques · DFTK.jl"/><meta property="twitter:title" content="Comparing discretization techniques · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/guide/discretisation/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/guide/discretisation/"/><link rel="canonical" href="https://docs.dftk.org/stable/guide/discretisation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../periodic_problems/">Periodic problems and plane-wave discretisations</a></li><li class="is-active"><a class="tocitem" href>Comparing discretization techniques</a><ul class="internal"><li><a class="tocitem" href="#Finite-differences"><span>Finite differences</span></a></li><li><a class="tocitem" href="#Plane-waves-method"><span>Plane waves method</span></a></li><li><a class="tocitem" href="#Using-DFTK"><span>Using DFTK</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#The-DFTK-Hamiltonian"><span>The DFTK Hamiltonian</span></a></li><li><a class="tocitem" href="#Solutions"><span>Solutions</span></a></li></ul></li><li><a class="tocitem" href="../atomic_chains/">Modelling atomic chains</a></li><li><a class="tocitem" href="../density_functional_theory/">Introduction to density-functional theory</a></li><li><a class="tocitem" href="../self_consistent_field/">Self-consistent field methods</a></li><li><a class="tocitem" href="../../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../examples/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li><li><a class="tocitem" href="../../tricks/compute_clusters/">Using DFTK on compute clusters</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li><li><a class="tocitem" href="../../examples/analysing_scf_convergence/">Analysing SCF convergence</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../../developer/setup/">Developer setup</a></li><li><a class="tocitem" href="../../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../../developer/style_guide/">Developer&#39;s style guide</a></li><li><a class="tocitem" href="../../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../../developer/gpu_computations/">GPU computations</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Background</a></li><li class="is-active"><a href>Comparing discretization techniques</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Comparing discretization techniques</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/guide/discretisation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Comparing-discretization-techniques"><a class="docs-heading-anchor" href="#Comparing-discretization-techniques">Comparing discretization techniques</a><a id="Comparing-discretization-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Comparing-discretization-techniques" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/JuliaMolSim/DFTK.jl/gh-pages?filepath=v0.6.19/guide/discretisation.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/JuliaMolSim/DFTK.jl/blob/gh-pages/v0.6.19/guide/discretisation.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In <a href="../periodic_problems/#periodic-problems">Periodic problems and plane-wave discretisations</a> we saw how simple 1D problems can be modelled using plane-wave basis sets. This example invites you to work out some details on these aspects yourself using a number of exercises. The solutions are given at the bottom of the page.</p><p>For this example we consider the discretization of</p><p class="math-container">\[   H = - \frac12 Δ + V(x) \quad \text{with $V(x) = \cos(x)$}\]</p><p>on <span>$[0, 2π]$</span> with periodic boundary conditions. The <span>$\cos(x)$</span> takes the role of a lattice-periodic potential. We will be interested in the smallest eigenvalues of this discretized Hamiltonian. Of note the boundary condition matters: The spectrum we will get is different from e.g. the spectrum of <span>$H$</span> on <span>$\mathbb{R}$</span>.</p><h2 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h2><p>We approximate functions <span>$ψ$</span> on <span>$[0, 2\pi]$</span> by their values at grid points <span>$x_k = 2\pi \frac{k}{N}$</span>, <span>$k=1, \dots, N$</span>. The boundary conditions are imposed by <span>$ψ(x_0) = ψ(x_N), ψ(x_{N+1}) = ψ(x_0)$</span>. We then have</p><p class="math-container">\[   \big(Hψ\big)(x_k) \approx \frac 1 2 \frac{-ψ_{k-1} + 2 ψ_k - ψ_{k+1}}{2 δx^2}
   + V(x_k) ψ(x_k)\]</p><p>with <span>$δx = \frac{2π}{N}$</span>.</p><p>This can be put in matrix form in the following way:</p><pre><code class="language-julia hljs"># Finite differences Hamiltonian -1/2 Delta + V on [0, 2pi] with periodic bc.
# Pass it a function V.
using LinearAlgebra

function build_finite_differences_matrix(Vfunction, N::Integer)
    δx = 2π/N

    # Finite-difference approximation to -½Δ
    T = 1/(2δx^2) * Tridiagonal(-ones(N-1), 2ones(N), -ones(N-1))
    # The type Tridiagonal is efficient, but to establish the periodic boundary conditions
    # we need to add elements not on the three diagonals, so convert to dense matrix
    T = Matrix(T)
    T[1, N] = T[N, 1] = -1 / (2δx^2)

    # Finite-difference approximation to potential: We collect all coordinates ...
    x_coords = [k * δx for k=1:N]
    V = Diagonal(Vfunction.(x_coords))  # ... and evaluate V on each of the x_coords

    T + V
end;</code></pre><div class="admonition is-success"><header class="admonition-header">Exercise 1</header><div class="admonition-body"><p>Show that the finite-difference approximation of -½Δ is indeed an approximation of the second derivative. Obtain an estimate of the first eigenvalue of <span>$H$</span>. <em>Hint:</em> Take a look at the <code>eigen</code> function from <code>LinearAlgebra</code>.</p></div></div><h2 id="Plane-waves-method"><a class="docs-heading-anchor" href="#Plane-waves-method">Plane waves method</a><a id="Plane-waves-method-1"></a><a class="docs-heading-anchor-permalink" href="#Plane-waves-method" title="Permalink"></a></h2><p>In this method, we expand states on the basis</p><p class="math-container">\[   e_G(x) = \frac{1}{\sqrt{2\pi}} e^{iGx} \qquad \text{for $G=-N,\dots,N$}.\]</p><div class="admonition is-success"><header class="admonition-header">Exercise 2</header><div class="admonition-body"><p>Show that</p><p class="math-container">\[   \langle e_G, e_{G&#39;}\rangle = ∫_0^{2π} e_G(x) e_{G&#39;}(x) d x = δ_{G, G&#39;}\]</p><p>and (assuming <span>$V(x) = \cos(x)$</span>)</p><p class="math-container">\[   \langle e_G, H e_{G&#39;}\rangle = \frac 1 2 \left(|G|^2 \delta_{G,G&#39;} + \delta_{G, G&#39;+1} + \delta_{G, G&#39;-1}\right).\]</p><p>What happens for a more general <span>$V(x)$</span>?</p></div></div><div class="admonition is-success"><header class="admonition-header">Exercise 3</header><div class="admonition-body"><p>Code this and check the first eigenvalue agrees with the finite-difference case. Compare accuracies at various basis set sizes <span>$N$</span>.</p></div></div><h2 id="Using-DFTK"><a class="docs-heading-anchor" href="#Using-DFTK">Using DFTK</a><a id="Using-DFTK-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DFTK" title="Permalink"></a></h2><p>We now use DFTK to do the same plane-wave discretisation in this 1D system. To deal with a 1D case we use a 3D lattice with two lattice vectors set to zero.</p><pre><code class="language-julia hljs">using DFTK
a = 2π
lattice = a .* [[1 0 0.]; [0 0 0]; [0 0 0]];</code></pre><p>Define Hamiltonian: Kinetic + Potential</p><pre><code class="language-julia hljs">terms = [Kinetic(),
         ExternalFromReal(r -&gt; cos(r[1]))]  # r is a vector of size 3
model = Model(lattice; n_electrons=1, terms, spin_polarization=:spinless);  # One spinless electron</code></pre><p>Ecut defines the number of plane waves by selecting all those <span>$G$</span>, which satisfy the relationship <span>$½ |G|^2 ≤ \text{Ecut}$</span>.</p><pre><code class="language-julia hljs">Ecut = 500
basis = PlaneWaveBasis(model; Ecut, kgrid=(1, 1, 1))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PlaneWaveBasis discretization:
    architecture         : DFTK.CPU()
    num. mpi processes   : 1
    num. julia threads   : 1
    num. blas  threads   : 2
    num. fft   threads   : 1

    Ecut                 : 500.0 Ha
    fft_size             : (135, 1, 1), 135 total points
    kgrid                : MonkhorstPack([1, 1, 1])
    num.   red. kpoints  : 1
    num. irred. kpoints  : 1

    Discretized Model(custom, 1D):
        lattice (in Bohr)    : [6.28319   , 0         , 0         ]
                               [0         , 0         , 0         ]
                               [0         , 0         , 0         ]
        unit cell volume     : 6.2832 Bohr
    
        num. electrons       : 1
        spin polarization    : spinless
        temperature          : 0 Ha
    
        terms                : Kinetic()
                               ExternalFromReal(Main.var&quot;#3#4&quot;())</code></pre><p>We now seek the ground state. To better separate the two steps (SCF outer loop and diagonalization inner loop), we set the diagtol (the tolerance of the eigensolver) to a small value.</p><pre><code class="language-julia hljs">diagtolalg = AdaptiveDiagtol(; diagtol_max=1e-8, diagtol_first=1e-8)
scfres = self_consistent_field(basis; tol=1e-4, diagtolalg)
scfres.energies</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Energy breakdown (in Ha):
    Kinetic             0.2090845 
    ExternalFromReal    -0.7441493

    total               -0.535064852288</code></pre><p>On this simple linear (non-interacting) model, the SCF converges in one step. The ground state energy of is simply the lowest eigenvalue; it should match the smallest eigenvalue of <span>$H$</span> computed above.</p><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>We can also get the first eigenvector (in the plane wave basis) and plot it</p><pre><code class="language-julia hljs">using Plots

ψ_fourier = scfres.ψ[1][:, 1];    # first k-point, all G components, first eigenvector
# Transform the wave function to real space
ψ = ifft(basis, basis.kpoints[1], ψ_fourier)[:, 1, 1]
# Eigenvectors are only defined up to a phase. We fix it by imposing that psi(0) is real
ψ /= (ψ[1] / abs(ψ[1]))
plot(real(ψ); label=&quot;&quot;)</code></pre><img src="f84bdd36.svg" alt="Example block output"/><p>Again this should match with the result above.</p><p><strong>Exercise 4:</strong> Look at the Fourier coefficients of <span>$\psi$</span> (<span>$\psi$</span>_fourier) and compare with the result above.</p><h2 id="The-DFTK-Hamiltonian"><a class="docs-heading-anchor" href="#The-DFTK-Hamiltonian">The DFTK Hamiltonian</a><a id="The-DFTK-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#The-DFTK-Hamiltonian" title="Permalink"></a></h2><p>We can ask DFTK for the Hamiltonian</p><pre><code class="language-julia hljs">E, ham = energy_hamiltonian(basis, scfres.ψ, scfres.occupation; ρ=scfres.ρ)
H = ham.blocks[1]
typeof(H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DFTK.DftHamiltonianBlock</code></pre><p>This is an opaque data structure, which encodes the Hamiltonian. What can we do with it?</p><pre><code class="language-julia hljs">using InteractiveUtils
methodswith(typeof(H), supertypes=true)</code></pre>9-element Vector{Method}:<ul><li> Array(block::<b>HamiltonianBlock</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L74" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:74</a><li> *(H::<b>HamiltonianBlock</b>, ψ) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L62" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:62</a><li> (Matrix)(block::<b>HamiltonianBlock</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L75" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:75</a><li> eltype(block::<b>HamiltonianBlock</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L63" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:63</a><li> size(block::<b>HamiltonianBlock</b>, i::<b>Integer</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L64" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:64</a><li> size(block::<b>HamiltonianBlock</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/terms/Hamiltonian.jl#L65" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/terms/Hamiltonian.jl:65</a><li> mul!(Hψ::<b>AbstractArray</b>, H::<b>DFTK.DftHamiltonianBlock</b>, ψ::<b>AbstractArray</b>) in DFTK at <a href="file:///home/runner/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl" target="_blank">/home/runner/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:230</a><li> PreconditionerNone(::<b>HamiltonianBlock</b>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/eigen/preconditioners.jl#L21" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/eigen/preconditioners.jl:21</a><li> PreconditionerTPA(ham::<b>HamiltonianBlock</b>; <i>kwargs...</i>) in DFTK at <a href="https://github.com/JuliaMolSim/DFTK.jl/tree/445970f5b9189b2c527385ebb24224a3289dec7b//src/eigen/preconditioners.jl#L45" target="_blank">/home/runner/work/DFTK.jl/DFTK.jl/src/eigen/preconditioners.jl:45</a></ul><p>This defines a number of methods. For instance, it can be used as a linear operator:</p><pre><code class="language-julia hljs">H * DFTK.random_orbitals(basis, basis.kpoints[1], 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">63×1 Matrix{ComplexF64}:
  0.08850946567064152 + 0.021385680388499813im
  0.08893316969333047 + 0.024851810500206573im
  0.15029554364765027 + 0.07611846242076661im
  -0.7118210487877756 - 0.08205535590550457im
   -1.100934486157015 - 0.5180797524069599im
  -3.3707384685115755 - 2.746970537655698im
   0.5086979696403797 + 1.425409741409736im
  -3.2037491302909897 + 3.272229409650207im
 -0.20355573371600033 + 6.144654327162291im
   7.7205559235051355 - 1.9063415511283628im
                      ⋮
   5.5547074041958036 - 1.34821749223096im
  -0.4333451841936238 + 0.4960358130179822im
   3.1590340448074117 - 4.538882557963048im
   0.7957291544788444 - 1.2070968151519466im
   1.5810714619527642 - 0.932534890934508im
  0.09425943036526939 - 0.4963306616081152im
  -0.4120972336235175 + 0.0424977881182214im
 -0.18127423391091008 + 0.17744734974077933im
 -0.04455291106953063 + 0.03635409526145292im</code></pre><p>We can also get its full matrix representation:</p><pre><code class="language-julia hljs">Array(H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">63×63 Matrix{ComplexF64}:
  -3.5247e-17+0.0im          …           0.5-4.87133e-17im
          0.5-4.87133e-17im      1.93395e-17+1.19856e-17im
  1.93395e-17+1.19856e-17im     -1.76211e-18+3.43427e-18im
 -1.76211e-18+3.43427e-18im     -5.27235e-18-1.56473e-17im
 -5.27235e-18-1.56473e-17im      1.48093e-17-1.93685e-17im
  1.48093e-17-1.93685e-17im  …   8.85398e-18+4.44201e-18im
  8.85398e-18+4.44201e-18im     -6.82427e-18+6.26594e-18im
 -6.82427e-18+6.26594e-18im       6.5791e-18+9.27972e-18im
   6.5791e-18+9.27972e-18im       1.9934e-18+3.73282e-18im
   1.9934e-18+3.73282e-18im      2.96007e-18-6.58852e-18im
             ⋮               ⋱  
   1.9934e-18-3.73282e-18im      1.84038e-17+2.28001e-19im
  1.84038e-17+2.28001e-19im  …  -6.82427e-18-6.26594e-18im
 -6.82427e-18-6.26594e-18im      8.85398e-18-4.44201e-18im
  8.85398e-18-4.44201e-18im      1.48093e-17+1.93685e-17im
  1.48093e-17+1.93685e-17im     -5.27235e-18+1.56473e-17im
 -5.27235e-18+1.56473e-17im     -1.76211e-18-3.43427e-18im
 -1.76211e-18-3.43427e-18im  …   1.93395e-17-1.19856e-17im
  1.93395e-17-1.19856e-17im              0.5+6.88035e-17im
          0.5+6.88035e-17im              0.5+0.0im</code></pre><div class="admonition is-success"><header class="admonition-header">Exercise 5</header><div class="admonition-body"><p>Compare this matrix with the one you obtained previously, get its eigenvectors and eigenvalues. Try to guess the ordering of <span>$G$</span>-vectors in DFTK.</p></div></div><div class="admonition is-success"><header class="admonition-header">Exercise 6</header><div class="admonition-body"><p>Increase the size of the problem, and compare the time spent by DFTK&#39;s internal diagonalization algorithms to a full diagonalization of <code>Array(H)</code>. <em>Hint:</em> The <code>@time</code> macro is handy for this task.</p></div></div><h2 id="Solutions"><a class="docs-heading-anchor" href="#Solutions">Solutions</a><a id="Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Solutions" title="Permalink"></a></h2><h3 id="Exercise-1"><a class="docs-heading-anchor" href="#Exercise-1">Exercise 1</a><a id="Exercise-1-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-1" title="Permalink"></a></h3><p>If we consider a function <span>$f : [0, 2π] → \mathbb{R}$</span>, to first order</p><p class="math-container">\[f(x + δx) = f(x) + δx f&#39;(x) + O(δx^2)\]</p><p>therefore after rearrangement</p><p class="math-container">\[f&#39;(x) = \frac{f(x + δx) - f(x)}{δx} + O(δx).\]</p><p>Similarly</p><p class="math-container">\[f&#39;&#39;(x) = \frac{f&#39;(x + δx) - f&#39;(x)}{δx} + O(δx),\]</p><p>such that overall</p><p class="math-container">\[f&#39;&#39;(x) \simeq \frac{f(x + 2δx) - f(x + δx) - f(x + δx) + f(x)}{δx^2}
       = \frac{f(x + 2δx) - 2f(x + δx) f(x)}{δx^2}\]</p><p>In finite differences we consider a stick basis of vectors</p><p class="math-container">\[\left\{ e_i = (0, …, 0, \underbrace{δx}_\text{$i$-th position}, 0, …, 0)
        \middle| i = 1, … N \right\}.\]</p><p>Keeping in mind the periodic boundary conditions (i.e. <span>$e_0 = e_N$</span>) projecting the Hamiltonian <span>$H$</span> onto this basis thus yields the proposed structure.</p><div class="admonition is-info"><header class="admonition-header">TODO More details</header><div class="admonition-body"><p>More details needed</p></div></div><p>We start off with <span>$N = 500$</span> to obtain</p><pre><code class="language-julia hljs">Hfd = build_finite_differences_matrix(cos, 100)
L, V = eigen(Hfd)
L[1:5]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 -0.5351640695081414
  0.3429576842587494
  0.8532206682511969
  2.053679933442362
  2.078512110605267</code></pre><p>This is already pretty accurate (to about 4 digits) as can be estimated looking at the following convergence plot:</p><pre><code class="language-julia hljs">using Plots
function fconv(N)
    L, V = eigen(build_finite_differences_matrix(cos, N))
    first(L)
end
Nrange = 10:10:100
plot(Nrange, abs.(fconv.(Nrange) .- fconv(200)); yaxis=:log, legend=false)</code></pre><img src="2dc63b48.svg" alt="Example block output"/><h3 id="Exercise-2"><a class="docs-heading-anchor" href="#Exercise-2">Exercise 2</a><a id="Exercise-2-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-2" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>This solution has not yet been written. Any help with a PR is appreciated.</p></div></div><h3 id="Exercise-3"><a class="docs-heading-anchor" href="#Exercise-3">Exercise 3</a><a id="Exercise-3-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-3" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>This solution has not yet been written. Any help with a PR is appreciated.</p></div></div><h3 id="Exercise-4"><a class="docs-heading-anchor" href="#Exercise-4">Exercise 4</a><a id="Exercise-4-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-4" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>This solution has not yet been written. Any help with a PR is appreciated.</p></div></div><h3 id="Exercise-5"><a class="docs-heading-anchor" href="#Exercise-5">Exercise 5</a><a id="Exercise-5-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-5" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>This solution has not yet been written. Any help with a PR is appreciated.</p></div></div><h3 id="Exercise-6"><a class="docs-heading-anchor" href="#Exercise-6">Exercise 6</a><a id="Exercise-6-1"></a><a class="docs-heading-anchor-permalink" href="#Exercise-6" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>This solution has not yet been written. Any help with a PR is appreciated.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../periodic_problems/">« Periodic problems and plane-wave discretisations</a><a class="docs-footer-nextpage" href="../atomic_chains/">Modelling atomic chains »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 9 May 2024 20:05">Thursday 9 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
