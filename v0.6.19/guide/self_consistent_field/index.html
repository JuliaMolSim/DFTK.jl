<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Self-consistent field methods · DFTK.jl</title><meta name="title" content="Self-consistent field methods · DFTK.jl"/><meta property="og:title" content="Self-consistent field methods · DFTK.jl"/><meta property="twitter:title" content="Self-consistent field methods · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/guide/self_consistent_field/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/guide/self_consistent_field/"/><link rel="canonical" href="https://docs.dftk.org/stable/guide/self_consistent_field/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../periodic_problems/">Periodic problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../discretisation/">Comparing discretization techniques</a></li><li><a class="tocitem" href="../atomic_chains/">Modelling atomic chains</a></li><li><a class="tocitem" href="../density_functional_theory/">Introduction to density-functional theory</a></li><li class="is-active"><a class="tocitem" href>Self-consistent field methods</a><ul class="internal"><li><a class="tocitem" href="#SCF-convergence-analysis"><span>SCF convergence analysis</span></a></li><li><a class="tocitem" href="#Making-an-SCF-converge"><span>Making an SCF converge</span></a></li><li><a class="tocitem" href="#Damped-iterations"><span>Damped iterations</span></a></li><li><a class="tocitem" href="#Acceleration-techniques"><span>Acceleration techniques</span></a></li><li><a class="tocitem" href="#Metals-and-charge-sloshing"><span>Metals and charge sloshing</span></a></li><li><a class="tocitem" href="#Preconditioning-strategies-(mixing-methods)"><span>Preconditioning strategies (mixing methods)</span></a></li><li><a class="tocitem" href="#Preconditioned-SCF-methods-in-practice"><span>Preconditioned SCF methods in practice</span></a></li></ul></li><li><a class="tocitem" href="../../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../examples/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li><li><a class="tocitem" href="../../tricks/compute_clusters/">Using DFTK on compute clusters</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li><li><a class="tocitem" href="../../examples/analysing_scf_convergence/">Analysing SCF convergence</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../../developer/setup/">Developer setup</a></li><li><a class="tocitem" href="../../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../../developer/style_guide/">Developer&#39;s style guide</a></li><li><a class="tocitem" href="../../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../../developer/gpu_computations/">GPU computations</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Background</a></li><li class="is-active"><a href>Self-consistent field methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Self-consistent field methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/guide/self_consistent_field.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Self-consistent-field-methods"><a class="docs-heading-anchor" href="#Self-consistent-field-methods">Self-consistent field methods</a><a id="Self-consistent-field-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Self-consistent-field-methods" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/JuliaMolSim/DFTK.jl/gh-pages?filepath=v0.6.19/guide/self_consistent_field.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/JuliaMolSim/DFTK.jl/blob/gh-pages/v0.6.19/guide/self_consistent_field.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In the <a href="../density_functional_theory/#Introduction-to-density-functional-theory">Introduction to density-functional theory</a> we concluded that the non-linear eigenvalue problem underlying DFT can be written as the fixed-point problem</p><p class="math-container">\[\rho = D(V(\rho)),\]</p><p>where <span>$V$</span> is the potential depending on the density <span>$\rho$</span> and <span>$D(V)$</span> is the potential-to-density map, that is the construction of the DFT Hamiltonian <span>$H(ρ) = -\frac12 Δ + V(ρ)$</span>, followed its diagonalisation to obtain its eigenpairs <span>$(\varepsilon_{k i}, \psi_{ki})$</span> and from these a new density</p><p class="math-container">\[\rho(r) = \sum_i f\left(\varepsilon_{i}\right) \, \psi_{ki}(r) \, \psi_{ki}^\ast(r)\]</p><p>with the Fermi level in the occupation function <span>$f$</span> chosen such that the number of electrons is conserved.</p><p>In this chapter we will investigate the convergence properties of density-mixing SCF algorithms, that is <strong>damped, preconditioned fixed-point iterations</strong></p><p class="math-container">\[\rho_{n+1} = \rho_n + \alpha P^{-1} (D(V(\rho_n)) - \rho_n),\]</p><p>where</p><ul><li><span>$\alpha$</span> is a damping parameter, typically chosen between <span>$0$</span> and <span>$1$</span>.</li><li><span>$P^{-1}$</span> is a preconditioner, which aims to improve convergence (details discussed further down).</li><li>the iterations start from an initial guess <span>$\rho_0$</span>.</li></ul><p>Our presentation follows <sup class="footnote-reference"><a id="citeref-HL2021" href="#footnote-HL2021">[HL2021]</a></sup>, where more details can be found.</p><h2 id="SCF-convergence-analysis"><a class="docs-heading-anchor" href="#SCF-convergence-analysis">SCF convergence analysis</a><a id="SCF-convergence-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#SCF-convergence-analysis" title="Permalink"></a></h2><p>We investigate the convergence properties of damped, preconditioned iterations, in order to understand the choices for the preconditioning stratege <span>$P^{-1}$</span> as well as the damping parameter <span>$\alpha$</span> to be made.</p><p>Near the fixed point <span>$\rho_\ast = D(V(\rho_\ast))$</span> the error <span>$e_n = \rho_n - \rho_\ast$</span> is small and we can expand to first order:</p><p class="math-container">\[\begin{align*}
D(V(\rho_\ast + e_n)) &amp;\simeq D\left[V(\rho_\ast) + V&#39;|_{\rho_\ast} e_n\right] \\
&amp;\simeq D(V(\rho_\ast)) + D&#39;|_{V(\rho_\ast)} V&#39;|_{\rho_\ast} e_n\\
&amp;= \rho_\ast + D&#39;|_{V(\rho_\ast)} V&#39;|_{\rho_\ast} e_n
\end{align*}\]</p><p>The derivatives <span>$D&#39;$</span> and <span>$V&#39;$</span> are again important quantities and are given special symbols:</p><ul><li>Hartree-exchange-correlation <strong>kernel</strong> <span>$K = V&#39;$</span></li><li>Independent-particle <strong>susceptibility</strong> <span>$\chi_0 = D&#39;$</span></li></ul><p>where for simplicity it has been dropped that these quantities are evaluated at the fixed-point,  i.e. at <span>$\rho_\ast$</span> and <span>$V(\rho_\ast)$</span>, respectively.</p><p>The above expansion allows to relate the <strong>error between SCF iterations</strong> (near the fixed point):</p><p class="math-container">\[\begin{align*}
e_{n+1} = \rho_{n+1} - \rho_\ast
&amp;= \rho_{n} - \rho_\ast + \alpha P^{-1} [D(V(\rho_\ast + e_n)) - \rho_n] \\
&amp;\simeq \rho_{n} - \rho_\ast + \alpha P^{-1} [\rho_\ast + \chi_0 K e_n - \rho_n] \\
&amp;= e_n - \alpha P^{-1} [1 - \chi_0 K] e_n.
\end{align*}\]</p><p>Introducing the <strong>dielectric matrix</strong> adjoint</p><p class="math-container">\[\varepsilon^\dagger = [1 - \chi_0 K]\]</p><p>leads to the final relationship</p><p class="math-container">\[e_{n+1} \simeq [1 - \alpha P^{-1} \varepsilon^\dagger] e_n = [1 - \alpha P^{-1} \varepsilon^\dagger]^n e_0\]</p><p>with <span>$e_0$</span> being the initial error. The SCF Jacobian is <span>$1 - \alpha P^{-1} \varepsilon^\dagger.$</span></p><p>In other words:</p><p class="math-container">\[\text{SCF converges} \qquad \Leftrightarrow \qquad \text{eigenvalues of $1 - \alpha P^{-1} \varepsilon^\dagger$ are between $-1$ and $1$}\]</p><p>This implies that the <strong>convergence</strong> properties of an SCF are related to <span>$\varepsilon$</span>, the dielectric operator, which <strong>depends on</strong> the <strong>dielectric properties</strong> of the system under study.</p><p>In other words it depends on the conduction and screening properties, i.e. whether the material is an insulator, a semiconductor, a metal etc.</p><h2 id="Making-an-SCF-converge"><a class="docs-heading-anchor" href="#Making-an-SCF-converge">Making an SCF converge</a><a id="Making-an-SCF-converge-1"></a><a class="docs-heading-anchor-permalink" href="#Making-an-SCF-converge" title="Permalink"></a></h2><p>It turns out that for the largest chunk of cases the eigenvalues of <span>$\varepsilon^\dagger$</span> are positive. Moreover near a local minimiser <span>$\varepsilon^\dagger$</span> always has non-degative spectrum.</p><p>To make the SCF converge one can therefore:</p><ul><li>Choose <span>$\alpha$</span> small enough. Even for <span>$P = I$</span> this always works, but convergence can be painfully slow. (see e.g. the proof in <sup class="footnote-reference"><a id="citeref-HL2022" href="#footnote-HL2022">[HL2022]</a></sup>)</li><li>Find a good <span>$P^{-1} \simeq (\varepsilon^\dagger)^{-1}$</span>. Then the eigenvalues of <span>$(P^{-1} \varepsilon^\dagger)$</span> are close to 1, <span>$\alpha \simeq 1$</span> is a good choice and the SCF converges in few steps. Hooray!</li><li>The optimal <span>$\alpha$</span> and the optimal rate of convergence are directly related to the eigenvalues of <span>$P^{-1} \varepsilon^\dagger$</span>. Denoting by <span>$\lambda_\text{min} &gt; 0$</span> and <span>$\lambda_\text{max}$</span> the smallest and largest eigenvalues of <span>$P^{-1} \varepsilon^\dagger$</span>, then the optimal damping is<p class="math-container">\[ \alpha = \frac{2}{\lambda_\text{min} + \lambda_\text{max}}\]</p>and the rate of convergence is (for large <span>$\kappa$</span>)<p class="math-container">\[r \simeq 1 - \frac{2}{\kappa}\]</p>where the (spectral) condition number<p class="math-container">\[\kappa = \frac{\lambda_\text{max}}{\lambda_\text{min}}.\]</p>Thus the smaller the condition number, the better the convergence.</li></ul><p><strong>Note:</strong> If the preconditioner is very bad, the eigenvalues of <span>$(P^{-1} \varepsilon^\dagger)$</span> might even be worse than <span>$\varepsilon^\dagger$</span>, such that convergence is actually hampered by the preconditioner.</p><h2 id="Damped-iterations"><a class="docs-heading-anchor" href="#Damped-iterations">Damped iterations</a><a id="Damped-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Damped-iterations" title="Permalink"></a></h2><p>We start our practical investigation of typical SCF algorithms using the most simple case of <span>$P=I$</span> and <span>$α = 1$</span>, i.e. the fixed-point iterations</p><p class="math-container">\[\rho_{n+1} = F(\rho_n),\]</p><p>where thus the density is just sent through the SCF step function <span>$F(\rho) = D(V(ρ))$</span> over and over again, starting from a hopefully good initial guess <span>$\rho_0$</span> until two successive densities differ by less than a desired threshold.</p><p>DFTK automatically provides a reasonable guess density as well as function to evaluate <span>$F(ρ)$</span>, such that we only need to take care of the iterations themselves. In the language of DFTK this algorithm is written as:</p><pre><code class="language-julia hljs">using DFTK
using LinearAlgebra
function fixed_point_iteration(F, ρ₀, maxiter; tol)
    # F:        The SCF step function
    # ρ₀:       The initial guess density
    # maxiter:  The maximal number of iterations to be performed
    # tol:      The selected convergence tolerance

    ρ  = ρ₀
    Fρ = F(ρ)
    for n = 1:maxiter
        # If change less than tolerance, break iterations:
        if norm(Fρ - ρ) &lt; tol
            break
        end
        ρ  = Fρ
        Fρ = F(ρ)
    end

    # Return some stuff DFTK needs ...
    (fixpoint=ρ, converged=norm(Fρ-ρ) &lt; tol)
end;</code></pre><p>To test this algorithm we use the following simple setting, which builds and discretises a PBE model for an aluminium supercell.</p><pre><code class="language-julia hljs">using ASEconvert
using LazyArtifacts

function aluminium_setup(repeat=1; Ecut=13.0, kgrid=[2, 2, 2])
    ase_Al = ase.build.bulk(&quot;Al&quot;; cubic=true) * pytuple((repeat, 1, 1))
    system = attach_psp(pyconvert(AbstractSystem, ase_Al);
                        Al=artifact&quot;pd_nc_sr_pbe_standard_0.4.1_upf/Al.upf&quot;)
    model = model_PBE(system; temperature=1e-3, symmetries=false)
    PlaneWaveBasis(model; Ecut, kgrid)
end;</code></pre><p>Now use this setup together with the <code>fixed_point_iteration</code> solver above within an SCF. Note that the <code>damping</code> and <code>mixing</code> parameters are needed here to disable some DFTK defaults we don&#39;t want to use just yet.</p><pre><code class="language-julia hljs">self_consistent_field(aluminium_setup(1); solver=fixed_point_iteration, damping=1.0,
                                          maxiter=30, mixing=SimpleMixing());</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">n     Energy            log10(ΔE)   log10(Δρ)   Diag   Δtime
---   ---------------   ---------   ---------   ----   ------
  1   -9.186736111004                   -1.09    6.9    365ms
  2   -9.187698887776       -3.02       -2.39    1.9    172ms
  3   -9.187880804843       -3.74       -2.83    7.0    296ms
  4   -9.187828132962   +   -4.28       -2.37    2.5    175ms
  5   -9.187326174249   +   -3.30       -1.89    3.1    214ms
  6   -9.184465726274   +   -2.54       -1.48    4.1    267ms
  7   -9.177218409240   +   -2.14       -1.22    5.1    333ms
  8   -9.163960511916   +   -1.88       -1.06    5.5    333ms
  9   -9.140993426679   +   -1.64       -0.94    5.8    359ms
 10   -9.105439403785   +   -1.45       -0.82    9.0    414ms
 11   -9.045000601201   +   -1.22       -0.71    7.4    399ms
 12   -8.833673685422   +   -0.68       -0.55    6.6    383ms
 13   -8.480281033356   +   -0.45       -0.38   10.6    480ms
 14   -8.048630408256   +   -0.36       -0.26    9.1    489ms
 15   -7.383167741681   +   -0.18       -0.16   10.8    539ms
 16   -7.299028514591   +   -1.08       -0.11   10.2    506ms
 17   -6.814023033964   +   -0.31       -0.08   11.1    556ms
 18   -7.080769536029       -0.57       -0.07   10.1    535ms
 19   -6.639616678038   +   -0.36       -0.06   11.1    572ms
 20   -6.895884178014       -0.59       -0.05   10.4    586ms
 21   -6.528809167230   +   -0.44       -0.05   10.4    545ms
 22   -6.816312671353       -0.54       -0.04   10.5    572ms
 23   -6.484580934310   +   -0.48       -0.04   10.4    545ms
 24   -6.717735503628       -0.63       -0.04   10.1    553ms
 25   -6.462056933248   +   -0.59       -0.04   10.2    545ms
 26   -6.715847434861       -0.60       -0.04   10.8    598ms
 27   -6.478190057408   +   -0.62       -0.04   11.6    569ms
 28   -6.746125907832       -0.57       -0.04   12.9    625ms
 29   -6.504494071324   +   -0.62       -0.04   12.4    591ms
 30   -6.754167248060       -0.60       -0.04   12.9    637ms
 31   -6.519565807209   +   -0.63       -0.04   12.0    590ms
<span class="sgr33"><span class="sgr1">┌ Warning: </span></span>SCF not converged.
<span class="sgr33"><span class="sgr1">└ </span></span><span class="sgr90">@ DFTK ~/work/DFTK.jl/DFTK.jl/src/scf/scf_callbacks.jl:60</span></code></pre><p>As can be observed this algorithm is not very good and in fact even fails to converge albeit we are only looking at a very simple system.</p><p>This is a known limitation of this algorithm, which is indeed why in practice one at least includes the damping parameter <span>$\alpha$</span> (with values usually between <span>$0$</span> and <span>$1$</span>). One now iterates as follows:</p><p class="math-container">\[\rho_{n+1} = \rho_{n} + \alpha (F(\rho_n) - \rho_n)\]</p><div class="admonition is-success"><header class="admonition-header">Exercise 1</header><div class="admonition-body"><p>Modify <code>fixed_point_iteration</code> such that it supports this <em>damped</em> fixed-point iteration. In other words implement damping <em>inside</em> your algorithm and not by changing the <code>damping</code> parameter of the <code>self_consistent_field</code> function driving the SCF.</p><p>Using your algorithm try different values for <span>$\alpha$</span> between <span>$0$</span> and <span>$1$</span> and estimate roughly the <span>$\alpha$</span> which gives fastest convergence. For which <span>$\alpha$</span> do you observe no convergence at all?</p></div></div><h2 id="Acceleration-techniques"><a class="docs-heading-anchor" href="#Acceleration-techniques">Acceleration techniques</a><a id="Acceleration-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Acceleration-techniques" title="Permalink"></a></h2><p>Before moving on to cases with <span>$P \neq I$</span> we will briefly consider an orthogonal strategy leading to faster SCF convergence, namely acceleration techniques. Our discussion will focus on <strong>Anderson acceleration</strong>. In this approach one exploits that the update <span>$R(\rho) = F(\rho) - \rho$</span> is also the residual of the fixed-point problem <span>$F(\rho) = \rho$</span>, i.e. how far away we are from the fixed-point density. A good next density <span>$\rho_{n+1}$</span> therefore should be found by minimising an approximation for <span>$R(\rho_{n+1})$</span>. Assuming the SCF was linear in the density (which it is not), a good idea is to find a linear combination of residuals</p><p class="math-container">\[\min_{\beta_i} \left\| \sum_i \beta_i R(\rho_i) \right\|^2\]</p><p>which has the smallest possible norm and to use these coefficients <span>$\beta_i$</span> to extrapolate the next density</p><p class="math-container">\[\rho_{n+1} =  \sum_i \beta_i (\rho_i + \alpha R(\rho_i))\]</p><p>where you notice the &quot;standard&quot; damped fixed-point iteration in the summed terms.</p><p>This simple idea has been rediscovered a few times in different communities with only minor variations to the theme. This makes Anderson acceleration variably known as e.g. Anderson mixing, Pulay mixing or direct inversion of the iterative subspace (DIIS). The mathematical analysis of such methods is not yet exhaustive, see <a href="http://dx.doi.org/10.1051/m2an/2021069">M. Chupin, M. Dupuy, G. Legendre, É. Séré. <em>Math. Model. Num. Anal.</em> <strong>55</strong> 2785 (2021) DOI: 10.1051/m2an/2021069</a> for a recent paper providing a good review of the state of the art.</p><p>A key result has been obtained by <a href="https://doi.org/10.1137/10078356X">Walker and Ni</a>, namely the equivalence of Anderson to the GMRES algorithm for linear problems. Based on this analysis Anderson-accelerated SCF procedures Anderson can be expected to inherit the GMRES convergence properties near a fixed point, resulting in a rate of convergence of</p><p class="math-container">\[r \simeq 1 - \frac{2}{\sqrt{\kappa}}.\]</p><p>In terms of an algorithm Anderson iteration is</p><pre><code class="language-julia hljs">function anderson_iteration(F, ρ₀, maxiter; tol)
    # F:        The SCF step function
    # ρ₀:       The initial guess density
    # maxiter:  The maximal number of iterations to be performed
    # tol:      The selected convergence tolerance

    converged = false
    ρ  = ρ₀
    ρs = []
    Rs = []
    for n = 1:maxiter
        Fρ = F(ρ)
        Rρ = Fρ - ρ
        converged = norm(Rρ) &lt; tol
        converged &amp;&amp; break

        ρnext = vec(ρ) .+ vec(Rρ)
        if !isempty(Rs)
            M = hcat(Rs...) .- vec(Rρ)
            βs = -(M \ vec(Rρ))

            for (iβ, β) in enumerate(βs)
                ρnext .+= β .* (ρs[iβ] .- vec(ρ) .+ Rs[iβ] .- vec(Rρ))
            end
        end

        push!(ρs, vec(ρ))
        push!(Rs, vec(Rρ))
        ρ = reshape(ρnext, size(ρ₀)...)
    end

    # Return some stuff DFTK needs ...
    (fixpoint=ρ, converged=converged)
end;</code></pre><p>To work with this algorithm we will use DFTK&#39;s intrinsic mechanism to choose a damping. The syntax for this is</p><pre><code class="language-julia hljs">repeat = 1
self_consistent_field(aluminium_setup(repeat);
                      solver=anderson_iteration,
                      damping=0.8, maxiter=40,
                      mixing=SimpleMixing());</code></pre><p>to choose a damping of <span>$\alpha = 0.8$</span> and run for at most <code>maxiter</code> iterations.</p><div class="admonition is-success"><header class="admonition-header">Exercise 2</header><div class="admonition-body"><p>Based on this Anderson implementation verify (by making a few experiments) that the algorithm converges for <code>repeat=1</code> for any <span>$0 &lt; \alpha \leq 2$</span>. You may now use the <code>damping</code> parameter for changing the value <span>$\alpha$</span> used by the SCF. State the number of iterations and runtimes you observe.</p></div></div><div class="admonition is-success"><header class="admonition-header">Exercise 3</header><div class="admonition-body"><p>Pick <span>$\alpha = 0.8$</span> and make the problem harder by increasing <code>repeat</code> (e.g. <code>2</code>, <code>4</code>, <code>6</code>, <code>8</code>). Can you make Anderson fail to converge? What do you notice in terms of the number of iterations and runtimes?</p></div></div><p>DFTK actually employs a numerically more stable Anderson acceleration implementation by default if the <code>solver</code> keyword argument is not provided to <code>self_consistent_field</code>. For practical calculations this should be used instead of a custom version.</p><h2 id="Metals-and-charge-sloshing"><a class="docs-heading-anchor" href="#Metals-and-charge-sloshing">Metals and charge sloshing</a><a id="Metals-and-charge-sloshing-1"></a><a class="docs-heading-anchor-permalink" href="#Metals-and-charge-sloshing" title="Permalink"></a></h2><p>Anderson allows us to push the boundary for SCF methods, but for larger or more challenging systems it is not fully sufficient. The next ingredient for a stable SCF procedure is based on the insight that the convergence properties of an SCF provably depend on the dielectric properties of materials, which is simulated. Amongst others this is to say that insulators (like glass), semiconductors (like silicon) or metals (like aluminium) have rather differing SCF behaviours. As a result the ideal SCF procedure should be slightly different for each material.</p><p>To investigate this further theoretically Recall the definition <span>$\varepsilon^\dagger = 1 - \chi_0 K$</span>. The Hartree-exchange-correlation kernel can be further decomposed into</p><p class="math-container">\[K = v_c + K_\text{xc},\]</p><p>where <span>$v_c$</span> is the classical Coulomb kernel we introduced previously and <span>$K_\text{xc} = d^2 E_\text{xc}(\rho)$</span> is the Hessian of the exchange-correlation energy functional.</p><p>For well-behaved systems the smallest eigenvalue of <span>$\varepsilon^\dagger$</span> is around <span>$1$</span> while the largest eigenvalue is of order <span>$10$</span> (or less). Due to a number of instabilities in the modelled systems either the smallest eigenvalue can decrease or the largest eigenvalue can increase, thus giving a larker condition number <span>$\kappa$</span> and worse convergence. For a detailed discussion, see Section 2 of <sup class="footnote-reference"><a id="citeref-HL2021" href="#footnote-HL2021">[HL2021]</a></sup>.</p><p>In this discussion we will restrict ourselves to a single source of instabilities, namely the one due to the long range divergence of the Coulomb kernel <span>$v_c$</span>. Indeed, if <span>$\hat{\rho}(q)$</span> are the Fourier coefficients of the density, then</p><p class="math-container">\[\widehat{(v_c \rho)}(q) = \frac{4\pi \hat{\rho}(q)}{|q|^2},\]</p><p>which diverges for small <span>$q$</span> (long wavelength). If this divergence is not compensated by <span>$\chi_0$</span>, this can manifest in large eigenvalues of <span>$\varepsilon^\dagger$</span>. (Note that <span>$\chi_0$</span> is a non-positive operator and <span>$K_\text{xc}$</span> has usually little influence on the large eigenmodes of <span>$\varepsilon^\dagger$</span>.)</p><p>For <strong>metals</strong> it turns out that <span>$\chi_0$</span> is approximately constant in the long-wavelength limit (<span>$q \to 0$</span>), namely the negative density of states <span>$D$</span> (per volume) at the Fermi level:</p><p class="math-container">\[\lim_{q\to0} \chi_0(q) \simeq -D.\]</p><p>Therefore as one treats larger and larger metallic systems, smaller wavelengths <span>$q$</span> become accessible in the discretised problem, which causes <span>$\lambda_\text{max}$</span> to increase –- in theory quadratically with system size. This phaenomenon, known as <strong>charge sloshing</strong> makes it difficult to treat large metallic systems without proper preconditioning.</p><p>In contrast for <strong>insulators</strong> and <strong>semiconductors</strong> a good approximation of <span>$\chi_0(q)$</span> for small <span>$q$</span> is <span>$-q^T \sigma_0 q$</span>, where <span>$\sigma_0$</span> is a material-dependent symmetric positive matrix. Therefore the <span>$1/q^2$</span> instability is compensated and treating larger cells is less difficult.</p><h2 id="Preconditioning-strategies-(mixing-methods)"><a class="docs-heading-anchor" href="#Preconditioning-strategies-(mixing-methods)">Preconditioning strategies (mixing methods)</a><a id="Preconditioning-strategies-(mixing-methods)-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioning-strategies-(mixing-methods)" title="Permalink"></a></h2><p>The natural approach to deal with the large-wavelength instabilities mentioned in the previous section, is to develop an approximate dielectric model <span>$P \simeq \varepsilon^\dagger$</span>, which can be used to compensate the large eigenvalues of <span>$\varepsilon^\dagger$</span>, i.e. such that <span>$P^{-1} \varepsilon^\dagger$</span> keeps a manageable condition number <span>$\kappa$</span> and thus a fast SCF convergence.</p><p>To simplify the discussion we will employ the so-called <strong>random-phase approximation</strong>, where we set <span>$K \simeq v_c$</span>, i.e. <span>$\varepsilon^\dagger = 1 - \chi_0 v_c$</span>. This approximatiion is justified for analysing the large-wavelength limit, where <span>$v_c$</span> dominates over <span>$K$</span>.</p><h3 id="Bulk-dielectric-models"><a class="docs-heading-anchor" href="#Bulk-dielectric-models">Bulk dielectric models</a><a id="Bulk-dielectric-models-1"></a><a class="docs-heading-anchor-permalink" href="#Bulk-dielectric-models" title="Permalink"></a></h3><p>The most practical strategy is to directly propose analytical expressions directly for <span>$P^{-1}$</span>. The rationale is that these are fast to evaluate and their cost can thus be neglected in an SCF. For <strong>bulk materials</strong> this is feasible building on the justified approximation to ignore lattice-scale details. Mathematically one may (a) take the <span>$q\to0$</span> limit and (b) model <span>$\chi_0$</span> as a translation-independent operator. Such operators (compare to the Kinetic energy) are diagonal in Fourier space and are fully characterised by their Fourier multiplier <span>$\chi_0(q)$</span>. Since <span>$v_c$</span> is also translation-independent, this implies that the resulting model for the dielectric operator <span>$P \simeq \varepsilon^\dagger$</span> is translation-independent and its inverse can be directly computed as <span>$P^{-1}(q) = \frac{1}{P(q)}$</span> enabling an analytical computation of the inverse of the preconditioner from a dielectric model.</p><p>For <strong>metals</strong> the observation <span>$\lim_{q\to0} \chi_0(q) \simeq -D$</span> directly leads to the <strong>Kerker preconditioner</strong></p><p class="math-container">\[P_\text{Kerker}^{-1}(q) = \left( 1 - \frac{4\pi -D}{|q|^2} \right)^{-1} = \frac{|q|^2}{|q|^2 + 4\pi D}.\]</p><p>The Kerker preconditioner is available in DFTK as <code>KerkerMixing</code> and <code>KerkerDosMixing</code> (which automatically determines the density of states from the current orbitals and occupations).</p><p>For <strong>semiconductors</strong> and <strong>insulators</strong> one can identify <span>$\varepsilon_r = \varepsilon(q = 0) = 1 + 4\pi \sigma_0$</span> (in the case of isotropic <span>$\sigma_0$</span>), where <span>$\varepsilon_r$</span> can be interpreted as the macroscopic electronic dielectric constant. From this limit for long wavelengths a number of empirical models for <span>$\chi_0(q)$</span> and <span>$\varepsilon^\dagger(q)$</span> have been proposed in the literature. A simple, two-parameter model is</p><p class="math-container">\[P_\text{Dielectric}^{-1}(q) = \frac{\varepsilon_r + (\varepsilon_r-1) \frac{|q|^2}{k_\text{TF}^2}}{1 + (\varepsilon_r-1) \frac{|q|^2}{k_\text{TF}^2}},\]</p><p>where <span>$k_\text{TF}$</span> is another parameter. This model is available in DFTK as <code>DielectricMixing</code>.</p><p>Below is a sketch of the three models using the appropriate setups for aluminium (a metal), gallium arsenide (a semiconductor, <span>$\varepsilon_r = 14.9$</span>) and silica (an insulator, <span>$\varepsilon_r = 1.5$</span>) for comparison:</p><pre><code class="language-julia hljs">using Plots

χ0_metal(q, kTF=1) = -kTF^2 / 4π
χ0_dielectric(q, εr, C₀=1-εr, kTF=1) = C₀*q^2 / (4π * (1 - C₀*q^2/kTF^2))
χ0_GaAs(q) = χ0_dielectric(q, 14.9)
χ0_SiO2(q) = χ0_dielectric(q, 1.5)
ε(χ0, q) = (1 - 4π/q^2 * χ0(q))

p = plot(xlims=(1e-2, 1.5), ylims=(0, 16), xlabel=&quot;q&quot;, ylabel=&quot;ε(q)&quot;, lw=4)
plot!(p, x -&gt; ε(χ0_metal, x), label=&quot;aluminium (Al)&quot;)
plot!(p, x -&gt; ε(χ0_GaAs, x),  label=&quot;gallium arsenide (GaAs)&quot;, ls=:dash)
plot!(p, x -&gt; ε(χ0_SiO2, x),  label=&quot;silica (SiO₂)&quot;, ls=:dashdot)</code></pre><img src="8232d261.svg" alt="Example block output"/><p>As expected from this discussion, for insulators <span>$P = I$</span> (no preconditioner) is sufficient, while for the two other cases, an appropriate preconditioner is needed to ensure good convergence properties for large systems.</p><p>Here we show the results for three large bulk systems (40 unit cells) of the three materials:</p><table><tr><th style="text-align: center">Aluminium (a metal)</th><th style="text-align: center">Gallium arsenide (a semiconductor)</th><th style="text-align: center">Silica (an insulator)</th></tr><tr><td style="text-align: center">&lt;img src=&quot;Al<em>repeat</em>40.png&quot; width=300 /&gt;</td><td style="text-align: center">&lt;img src=&quot;GaAs<em>repeat</em>40.png&quot; width=300 /&gt;</td><td style="text-align: center">&lt;img src=&quot;SiO2<em>repeat</em>39.png&quot; width=300 /&gt;</td></tr></table><h3 id="Susceptibility-models-and-LDOS-preconditioner"><a class="docs-heading-anchor" href="#Susceptibility-models-and-LDOS-preconditioner">Susceptibility models and LDOS preconditioner</a><a id="Susceptibility-models-and-LDOS-preconditioner-1"></a><a class="docs-heading-anchor-permalink" href="#Susceptibility-models-and-LDOS-preconditioner" title="Permalink"></a></h3><p>While the bulk preconditioning models mentioned above are a good step forward, they have two key disadvantages:</p><ol><li>Since the preconditioner models (especially between metals and insulators) are rather distinct, the preconditioner needs to match the modelled material to ensure fast convergence for large systems. In other words one needs to know <strong>a priori</strong> what material one is modelling.</li><li>Being by nature bulk models, they miss important applications featuring inhomogeneous systems, such as catalytic surfaces, metal clusters etc.</li></ol><p>In order to overcome the second point it is important to realise that we need to give up on the translational independence of <span>$\chi_0$</span>, i.e. we no longer are able to compute <span>$P^{-1}(q)$</span> by <span>$1/P(q)$</span>. Our strategy will therefore be to construct more sophisticated approximations to <span>$\chi_0$</span>, denoted by <span>$\widetilde{\chi_0}$</span>. The preconditioned density <span>$x_n = P^{-1} \rho_n = (1 - \widetilde{\chi_0} v_c)^{-1}$</span> is then obtained by solving</p><p class="math-container">\[(1 - \widetilde{\chi_0} v_c) x_n = \rho_n\]</p><p>iteratively for <span>$x_n$</span> using GMRES.</p><p>Note that <span>$\chi_0(r, r&#39;)$</span> has unit-cell internal fluctuations, but is overall diagonal dominant</p><p>&lt;img src=&quot;chi0.png&quot; width=400 /&gt;</p><p>Starting from the Adler-Wiser formula</p><p class="math-container">\[\begin{align*}
   \chi_0(\vec{r}, \vec{r}&#39;)
     &amp;= \sum_{n, m} \frac{f_\text{FD}(\varepsilon_n) - f_\text{FD}(\varepsilon_m)}{\varepsilon_n - \varepsilon_m}                \psi_n(\vec{r}) \psi_m^\ast(\vec{r})
        \psi_m(\vec{r}&#39;) \psi_n^\ast(\vec{r}&#39;)%\\
\end{align*}\]</p><p>we want to capture the large-scale variations from <span>$\rho_n$</span> to <span>$\rho_{n+1}$</span> to counteract the charge-sloshing. Set <span>$V = v_c \rho_n$</span> and assume <span>$\vec{r} \mapsto \chi_0(\vec{r}, \vec{r}&#39;)$</span> to be more localised around <span>$\vec{r}&#39;$</span> than <span>$V(\vec{r}&#39;)$</span>. Then apply <em>row-sum mass lumping</em> to homogenise the operator:</p><p class="math-container">\[\begin{align*}
  \int \chi_0(\vec{r}, \vec{r}&#39;) V(\vec{r}&#39;) d\vec{r}&#39;
    &amp;\simeq V(\vec{r})\int \chi_0(\vec{r}, \vec{r}&#39;) d\vec{r}&#39;\\
    &amp;= V(\vec{r}) \sum_{n, m} \frac{f(\varepsilon_n) - f(\varepsilon_m)}
                  {\varepsilon_n - \varepsilon_m}
                  \psi_n(\vec{r}) \psi_m^\ast(\vec{r}) \delta_{mn}\\
    &amp;= V(\vec{r}) \sum_n f&#39;(\varepsilon_n) |\psi_n(\vec{r})|^2\\
    &amp;= V(\vec{r}) \cdot \Big(- \text{LDOS}(\vec{r}) \Big)
\end{align*}\]</p><p>Overall we thus approximate</p><p class="math-container">\[\chi_0(r, r&#39;) \simeq - \text{LDOS}(r) \, \delta(r, r&#39;)\]</p><p>Note that this approach yields a generic framework, where further terms (capturing other physics of <span>$\chi_0$</span>) could be easily employed on top of the <span>$-\text{LDOS}$</span> term.</p><p>To conclude this chapter we show some results for mixed systems featuring various combinations of metals, insulators and semiconductors. In the table both the number of iterations as well as the condition number is shown. Cases where the condition number does not more than double as the system size is doubled are coloured.</p><p>&lt;img src=&quot;ldos_table.png&quot; width=&quot;700px&quot; /&gt;</p><p>For the two metal-insulator systems, exemplary convergence curves are shown below:</p><table><tr><th style="text-align: center">Aluminium + Vacuum</th><th style="text-align: center">Aluminium + Silica</th></tr><tr><td style="text-align: center">&lt;img src=&quot;alvac.png&quot; width=400 /&gt;</td><td style="text-align: center">&lt;img src=&quot;alsio2.png&quot; width=400 /&gt;</td></tr><tr><td style="text-align: center">&lt;img src=&quot;AlVac<em>repeat</em>20.png&quot; width=400 /&gt;</td><td style="text-align: center">&lt;img src=&quot;AlSiO2H<em>repeat</em>20.png&quot; width=400 /&gt;</td></tr></table><p>The LDOS preconditioning strategy is available in DFTK as <code>LdosMixing</code>. Since it is parameter-free and applicable to a wide range of systems (any mixture of insulator and metals), it is used by default in DFTK.</p><h2 id="Preconditioned-SCF-methods-in-practice"><a class="docs-heading-anchor" href="#Preconditioned-SCF-methods-in-practice">Preconditioned SCF methods in practice</a><a id="Preconditioned-SCF-methods-in-practice-1"></a><a class="docs-heading-anchor-permalink" href="#Preconditioned-SCF-methods-in-practice" title="Permalink"></a></h2><p>We return to our aluminium setting produced by <code>aluminium_setup</code>. In this case we are dealing with a prototypical metal, such that <code>KerkerMixing</code> is indeed appropriate. We will thus employ it as the preconditioner <span>$P$</span> in the setting</p><p class="math-container">\[rho_{n+1} = \rho_n + \alpha P^{-1} (D(V(\rho_n)) - \rho_n),\]</p><p>In DFTK this is done by running an SCF as follows:</p><pre><code class="language-julia hljs">self_consistent_field(basis; damping=0.8, mixing=KerkerMixing());</code></pre><p>If you wonder about the use of Anderson acceleration in this context: It can simply be re-introduced by replacing the previous definition of <span>$R$</span> by <span>$R(\rho) = P^{-1} (F(\rho_n) - \rho_n)$</span>. Again DFTK does exactly this by default if no other <code>solver</code> is passed to <code>self_consistent_field</code>.</p><div class="admonition is-success"><header class="admonition-header">Exercise 4</header><div class="admonition-body"><p>Try the Anderson-accelerated and <code>KerkerMixing</code>-preconditioned setup for different values of <code>repeat</code> in <code>aluminium_setup</code> and check the number of iterations needed. Other mixings DFTK has to offer are <code>DielectricMixing</code> (best for semiconductors), <code>SimpleMixing</code> (which is <span>$P = I$</span>, i.e. no preconditioner at all, best for insulators) or <code>LdosMixing</code> (self-adapting, suitable for both metals <em>or</em> insulators <em>or</em> inhomogeneous mixtures). Note that <code>LdosMixing</code> is the default in DFTK (i.e. used if the <code>mixing</code> parameter is <em>not</em> supplied to <code>self_consistent_field</code>. Try these mixings (<code>SimpleMixing</code>, <code>DielectricMixing</code>, <code>LdosMixing</code> and <code>KerkerMixing</code>) and summarise your findings.</p></div></div><p>You should notice that choosing a preconditioner matching the material under study aids a fast SCF convergence, but that sometimes being off does not seem to do much harm for our case. For larger values of <code>repeat</code> (beyond what you can probably effort on your laptop) this is no longer true and one needs to be very careful in selecting the right preconditioner. See for example the investigation in <sup class="footnote-reference"><a id="citeref-HL2021" href="#footnote-HL2021">[HL2021]</a></sup>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HL2021"><a class="tag is-link" href="#citeref-HL2021">HL2021</a>M. Herbst, A. Levitt. <em>J. Phys.: Condens. Matter</em> <strong>33</strong> 085503 (2021) DOI: <a href="http://dx.doi.org/10.1088/1361-648x/abcbdb">10.1088/1361-648x/abcbdb</a></li><li class="footnote" id="footnote-HL2022"><a class="tag is-link" href="#citeref-HL2022">HL2022</a>M. Herbst, A. Levitt <em>J. Comp. Phys.</em> <strong>459</strong> 111127 (2022). DOI <a href="http://dx.doi.org/10.1016/j.jcp.2022.111127">10.1016/j.jcp.2022.111127</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../density_functional_theory/">« Introduction to density-functional theory</a><a class="docs-footer-nextpage" href="../../school2022/">DFTK School 2022 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 9 May 2024 20:05">Thursday 9 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
