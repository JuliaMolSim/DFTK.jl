<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · DFTK.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.dftk.org/stable/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DFTK.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../guide/installation/">Installation</a></li><li><a class="tocitem" href="../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../guide/periodic_problems/">Problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../guide/introductory_resources/">Introductory resources</a></li><li><a class="tocitem" href="../school2022/">DFTK School 2022</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../examples/dielectric/">Eigenvalues of the dielectric matrix</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../examples/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../examples/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../examples/wannier90/">Wannierization using Wannier90</a></li></ul></li><li><span class="tocitem">Tipps and tricks</span><ul><li><a class="tocitem" href="../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../examples/compare_solvers/">Comparison of DFT solvers</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../developer/gpu_computations/">GPU computations</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This page provides a plain list of all documented functions, structs, modules and macros in DFTK. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.</p><article class="docstring"><header><a class="docstring-binding" id="DFTK.DFTK" href="#DFTK.DFTK"><code>DFTK.DFTK</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DFTK –- The density-functional toolkit. Provides functionality for experimenting with plane-wave density-functional theory algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/DFTK.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DFTK_DATADIR" href="#DFTK.DFTK_DATADIR"><code>DFTK.DFTK_DATADIR</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>The default search location for Pseudopotential data files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/constants.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.timer" href="#DFTK.timer"><code>DFTK.timer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>TimerOutput object used to store DFTK timings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/timer.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AbstractArchitecture" href="#DFTK.AbstractArchitecture"><code>DFTK.AbstractArchitecture</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for architectures supported by DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/architecture.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AdaptiveBands" href="#DFTK.AdaptiveBands"><code>DFTK.AdaptiveBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dynamically adapt number of bands to be converged to ensure that the orbitals of lowest occupation are occupied to at most <code>occupation_threshold</code>. To obtain rapid convergence of the eigensolver a gap between the eigenvalues of the last occupied orbital and the last computed (but not converged) orbital of <code>gap_min</code> is ensured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/nbands_algorithm.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Applyχ0Model" href="#DFTK.Applyχ0Model"><code>DFTK.Applyχ0Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Full χ0 application, optionally dropping terms or disabling Sternheimer. All keyword arguments passed to <a href="#DFTK.apply_χ0-NTuple{6, Any}"><code>apply_χ0</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/chi0models.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AtomicLocal" href="#DFTK.AtomicLocal"><code>DFTK.AtomicLocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Atomic local potential defined by <code>model.atoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/local.jl#L67-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AtomicNonlocal" href="#DFTK.AtomicNonlocal"><code>DFTK.AtomicNonlocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal term coming from norm-conserving pseudopotentials in Kleinmann-Bylander form. <span>$\text{Energy} = \sum_a \sum_{ij} \sum_{n} f_n &lt;ψ_n|p_{ai}&gt; D_{ij} &lt;p_{aj}|ψ_n&gt;.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/nonlocal.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.BlowupAbinit" href="#DFTK.BlowupAbinit"><code>DFTK.BlowupAbinit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as used in Abinit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/kinetic.jl#L94-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.BlowupCHV" href="#DFTK.BlowupCHV"><code>DFTK.BlowupCHV</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Blow-up function as proposed in https://arxiv.org/abs/2210.00442 The blow-up order of the function is fixed to ensure C^2 regularity of the energies bands away from crossings and Lipschitz continuity at crossings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/kinetic.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.BlowupIdentity" href="#DFTK.BlowupIdentity"><code>DFTK.BlowupIdentity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default blow-up corresponding to the standard kinetic energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/kinetic.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DielectricMixing" href="#DFTK.DielectricMixing"><code>DFTK.DielectricMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We use a simplification of the Resta model DOI 10.1103/physrevb.16.2717 and set <span>$χ_0(q) = \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)}$</span> where <span>$C_0 = 1 - ε_r$</span> with <span>$ε_r$</span> being the macroscopic relative permittivity. We neglect <span>$K_\text{xc}$</span>, such that <span>$J^{-1} ≈ \frac{k_{TF}^2 - C_0 G^2}{ε_r k_{TF}^2 - C_0 G^2}$</span></p><p>By default it assumes a relative permittivity of 10 (similar to Silicon). <code>εr == 1</code> is equal to <code>SimpleMixing</code> and <code>εr == Inf</code> to <code>KerkerMixing</code>. The mixing is applied to <span>$ρ$</span> and <span>$ρ_\text{spin}$</span> in the same way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DielectricModel" href="#DFTK.DielectricModel"><code>DFTK.DielectricModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A localised dielectric model for <span>$χ_0$</span>:</p><p class="math-container">\[\sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <code>L(r)</code> is a real-space localization function and otherwise the same conventions are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/chi0models.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DivAgradOperator" href="#DFTK.DivAgradOperator"><code>DFTK.DivAgradOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal &quot;divAgrad&quot; operator <span>$-½ ∇ ⋅ (A ∇)$</span> where <span>$A$</span> is a scalar field on the real-space grid. The <span>$-½$</span> is included, such that this operator is a generalisation of the kinetic energy operator (which is obtained for <span>$A=1$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementCohenBergstresser-Tuple{Any}" href="#DFTK.ElementCohenBergstresser-Tuple{Any}"><code>DFTK.ElementCohenBergstresser</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element where the interaction with electrons is modelled as in <a href="https://doi.org/10.1103/PhysRev.141.789">CohenBergstresser1966</a>. Only the homonuclear lattices of the diamond structure are implemented (i.e. Si, Ge, Sn).</p><p><code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementCoulomb-Tuple{Any}" href="#DFTK.ElementCoulomb-Tuple{Any}"><code>DFTK.ElementCoulomb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a bare Coulomb potential (for all-electron calculations) <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementGaussian-Tuple{Any, Any}" href="#DFTK.ElementGaussian-Tuple{Any, Any}"><code>DFTK.ElementGaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a Gaussian potential. Symbol is non-mandatory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L176-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementPsp-Tuple{Any}" href="#DFTK.ElementPsp-Tuple{Any}"><code>DFTK.ElementPsp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a pseudopotential model. <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Energies" href="#DFTK.Energies"><code>DFTK.Energies</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple struct to contain a vector of energies, and utilities to print them in a nice format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Energies.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Entropy" href="#DFTK.Entropy"><code>DFTK.Entropy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Entropy term -TS, where S is the electronic entropy. Turns the energy E into the free energy F=E-TS. This is in particular useful because the free energy, not the energy, is minimized at self-consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/entropy.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Ewald" href="#DFTK.Ewald"><code>DFTK.Ewald</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Ewald term: electrostatic energy per unit cell of the array of point charges defined by <code>model.atoms</code> in a uniform background of compensating charge yielding net neutrality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/ewald.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ExternalFromFourier" href="#DFTK.ExternalFromFourier"><code>DFTK.ExternalFromFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from the (unnormalized) Fourier coefficients <code>V(G)</code> G is passed in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/local.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ExternalFromReal" href="#DFTK.ExternalFromReal"><code>DFTK.ExternalFromReal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from an analytic function <code>V</code> (in cartesian coordinates). No low-pass filtering is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/local.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.FermiTwoStage" href="#DFTK.FermiTwoStage"><code>DFTK.FermiTwoStage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Two-stage Fermi level finding algorithm starting from a Gaussian-smearing guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/occupation.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.FixedBands" href="#DFTK.FixedBands"><code>DFTK.FixedBands</code></a> — <span class="docstring-category">Type</span></header><section><div><p>In each SCF step converge exactly <code>n_bands_converge</code>, computing along the way exactly <code>n_bands_compute</code> (usually a few more to ease convergence in systems with small gaps).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/nbands_algorithm.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.FourierMultiplication" href="#DFTK.FourierMultiplication"><code>DFTK.FourierMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Fourier space multiplication, like a kinetic energy term: (Hψ)(G) = multiplier(G) ψ(G)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray" href="#DFTK.GPU-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AbstractArray"><code>DFTK.GPU</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a particular GPU architecture by passing the ArrayType</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/architecture.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Hartree" href="#DFTK.Hartree"><code>DFTK.Hartree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Hartree term: for a decaying potential V the energy would be</p><p>1/2 ∫ρ(x)ρ(y)V(x-y) dxdy</p><p>with the integral on x in the unit cell and of y in the whole space. For the Coulomb potential with periodic boundary conditions, this is rather</p><p>1/2 ∫ρ(x)ρ(y) G(x-y) dx dy</p><p>where G is the Green&#39;s function of the periodic Laplacian with zero mean (-Δ G = sum<em>{R} 4π δ</em>R, integral of G zero on a unit cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/hartree.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.KerkerDosMixing" href="#DFTK.KerkerDosMixing"><code>DFTK.KerkerDosMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The same as <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, but the Thomas-Fermi wavevector is computed from the current density of states at the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L93-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.KerkerMixing" href="#DFTK.KerkerMixing"><code>DFTK.KerkerMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kerker mixing: <span>$J^{-1} ≈ \frac{|G|^2}{k_{TF}^2 + |G|^2}$</span> where <span>$k_{TF}$</span> is the Thomas-Fermi wave vector. For spin-polarized calculations by default the spin density is not preconditioned. Unless a non-default value for <span>$ΔDOS_Ω$</span> is specified. This value should roughly be the expected difference in density of states (per unit volume) between spin-up and spin-down.</p><p>Notes:</p><ul><li>Abinit calls <span>$1/k_{TF}$</span> the dielectric screening length (parameter <em>dielng</em>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Kinetic" href="#DFTK.Kinetic"><code>DFTK.Kinetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kinetic energy: 1/2 sum<em>n f</em>n ∫ |∇ψn|^2 * blowup(-i∇Ψ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/kinetic.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Kpoint" href="#DFTK.Kpoint"><code>DFTK.Kpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discretization information for <span>$k$</span>-point-dependent quantities such as orbitals. More generally, a <span>$k$</span>-point is a block of the Hamiltonian; eg collinear spin is treated by doubling the number of kpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LazyHcat" href="#DFTK.LazyHcat"><code>DFTK.LazyHcat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple wrapper to represent a matrix formed by the concatenation of column blocks: it is mostly equivalent to hcat, but doesn&#39;t allocate the full matrix. LazyHcat only supports a few multiplication routines: furthermore, a multiplication involving this structure will always yield a plain array (and not a LazyHcat structure). LazyHcat is a lightweight subset of BlockArrays.jl&#39;s functionalities, but has the advantage to be able to store GPU Arrays (BlockArrays is heavily built on Julia&#39;s CPU Array).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/eigen/lobpcg_hyper_impl.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LdosModel" href="#DFTK.LdosModel"><code>DFTK.LdosModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents the LDOS-based <span>$χ_0$</span> model</p><p class="math-container">\[χ_0(r, r&#39;) = (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states and <span>$D$</span> the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/chi0models.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}" href="#DFTK.LibxcDensities-Tuple{Any, Integer, Any, Any}"><code>DFTK.LibxcDensities</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute density in real space and its derivatives starting from ρ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/xc.jl#L211-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LocalNonlinearity" href="#DFTK.LocalNonlinearity"><code>DFTK.LocalNonlinearity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Local nonlinearity, with energy ∫f(ρ) where ρ is the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/local_nonlinearity.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Magnetic" href="#DFTK.Magnetic"><code>DFTK.Magnetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic term <span>$A⋅(-i∇)$</span>. It is assumed (but not checked) that <span>$∇⋅A = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/magnetic.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.MagneticFieldOperator" href="#DFTK.MagneticFieldOperator"><code>DFTK.MagneticFieldOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic field operator A⋅(-i∇).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L109-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Model-Tuple{AtomsBase.AbstractSystem}" href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(system::AbstractSystem; kwargs...)</code></pre><p>AtomsBase-compatible Model constructor. Sets structural information (<code>atoms</code>, <code>positions</code>, <code>lattice</code>, <code>n_electrons</code> etc.) from the passed <code>system</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}}, Tuple{AbstractMatrix{T}, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(lattice, atoms, positions; n_electrons, magnetic_moments, terms, temperature,
      smearing, spin_polarization, symmetries)</code></pre><p>Creates the physical specification of a model (without any discretization information).</p><p><code>n_electrons</code> is taken from <code>atoms</code> if not specified.</p><p><code>spin_polarization</code> is :none by default (paired electrons) unless any of the elements has a non-zero initial magnetic moment. In this case the spin_polarization will be :collinear.</p><p><code>magnetic_moments</code> is only used to determine the symmetry and the <code>spin_polarization</code>; it is not stored inside the datastructure.</p><p><code>smearing</code> is Fermi-Dirac if <code>temperature</code> is non-zero, none otherwise</p><p>The <code>symmetries</code> kwarg allows (a) to pass <code>true</code> / <code>false</code> to enable / disable the automatic determination of lattice symmetries or (b) to pass an explicit list of symmetry operations to use for lowering the computational effort. The default behaviour is equal to <code>true</code>, namely that the code checks the specified model in form of the Hamiltonian <code>terms</code>, <code>lattice</code>, <code>atoms</code> and <code>magnetic_moments</code> parameters and from these automatically determines a set of symmetries it can safely use. If you want to pass custom symmetry operations (e.g. a reduced or extended set) use the <code>symmetry_operations</code> function. Notice that this may lead to wrong results if e.g. the external potential breaks some of the passed symmetries. Use <code>false</code> to turn off symmetries completely.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L67-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NbandsAlgorithm" href="#DFTK.NbandsAlgorithm"><code>DFTK.NbandsAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NbandsAlgorithm subtypes determine how many bands to compute and converge in each SCF step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/nbands_algorithm.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NonlocalOperator" href="#DFTK.NonlocalOperator"><code>DFTK.NonlocalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal operator in Fourier space in Kleinman-Bylander format, defined by its projectors P matrix and coupling terms D: Hψ = PDP&#39; ψ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NoopOperator" href="#DFTK.NoopOperator"><code>DFTK.NoopOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Noop operation: don&#39;t do anything. Useful for energy terms that don&#39;t depend on the orbitals at all (eg nuclei-nuclei interaction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PairwisePotential-Tuple{Any, Any}" href="#DFTK.PairwisePotential-Tuple{Any, Any}"><code>DFTK.PairwisePotential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pairwise terms: Pairwise potential between nuclei, e.g., Van der Waals potentials, such as Lennard—Jones terms. The potential is dependent on the distance between to atomic positions and the pairwise atomic types: For a distance <code>d</code> between to atoms <code>A</code> and <code>B</code>, the potential is <code>V(d, params[(A, B)])</code>. The parameters <code>max_radius</code> is of <code>100</code> by default, and gives the maximum distance (in Cartesian coordinates) between nuclei for which we consider interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/pairwise.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A plane-wave discretized <code>Model</code>. Normalization conventions:</p><ul><li>Things that are expressed in the G basis are normalized so that if <span>$x$</span> is the vector, then the actual function is <span>$\sum_G x_G e_G$</span> with <span>$e_G(x) = e^{iG x} / \sqrt(\Omega)$</span>, where <span>$\Omega$</span> is the unit cell volume. This is so that, eg <span>$norm(ψ) = 1$</span> gives the correct normalization. This also holds for the density and the potentials.</li><li>Quantities expressed on the real-space grid are in actual values.</li></ul><p><code>ifft</code> and <code>fft</code> convert between these representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L30-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{Model}" href="#DFTK.PlaneWaveBasis-Tuple{Model}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a <code>PlaneWaveBasis</code> using the kinetic energy cutoff <code>Ecut</code> and a Monkhorst-Pack <span>$k$</span>-point grid. The MP grid can either be specified directly with <code>kgrid</code> providing the number of points in each dimension and <code>kshift</code> the shift (0 or 1/2 in each direction). If not specified a grid is generated using <code>kgrid_from_minimal_spacing</code> with a minimal spacing of <code>2π * 0.022</code> per Bohr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L321-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, AbstractVector, AbstractVector}" href="#DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis, AbstractVector, AbstractVector}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a new basis identical to <code>basis</code>, but with a custom set of kpoints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L337-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PreconditionerNone" href="#DFTK.PreconditionerNone"><code>DFTK.PreconditionerNone</code></a> — <span class="docstring-category">Type</span></header><section><div><p>No preconditioning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/eigen/preconditioners.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PreconditionerTPA" href="#DFTK.PreconditionerTPA"><code>DFTK.PreconditionerTPA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(simplified version of) Tetter-Payne-Allan preconditioning ↑ M.P. Teter, M.C. Payne and D.C. Allan, Phys. Rev. B 40, 12255 (1989).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/eigen/preconditioners.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PspCorrection" href="#DFTK.PspCorrection"><code>DFTK.PspCorrection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pseudopotential correction energy. TODO discuss the need for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/psp_correction.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PspHgh-Tuple{Any}" href="#DFTK.PspHgh-Tuple{Any}"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspHgh(path[, identifier, description])</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998) from file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspHgh.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PspUpf-Tuple{Any}" href="#DFTK.PspUpf-Tuple{Any}"><code>DFTK.PspUpf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PspUpf(path[, identifier])</code></pre><p>Construct a Unified Pseudopotential Format pseudopotential from file.</p><p>Does not support:</p><ul><li>Non-linear core correction</li><li>Fully-realtivistic / spin-orbit pseudos</li><li>Bare Coulomb / all-electron potentials</li><li>Semilocal potentials</li><li>Ultrasoft potentials</li><li>Projector-augmented wave potentials</li><li>GIPAW reconstruction data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RealFourierOperator" href="#DFTK.RealFourierOperator"><code>DFTK.RealFourierOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Linear operators that act on tuples (real, fourier) The main entry point is <code>apply!(out, op, in)</code> which performs the operation out += op*in where out and in are named tuples (real, fourier) They also implement mul! and Matrix(op) for exploratory use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RealSpaceMultiplication" href="#DFTK.RealSpaceMultiplication"><code>DFTK.RealSpaceMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Real space multiplication by a potential: (Hψ)(r) = V(r) ψ(r)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/operators.jl#L47-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.SimpleMixing" href="#DFTK.SimpleMixing"><code>DFTK.SimpleMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple mixing: <span>$J^{-1} ≈ 1$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.TermNoop" href="#DFTK.TermNoop"><code>DFTK.TermNoop</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with a constant zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/terms.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Xc" href="#DFTK.Xc"><code>DFTK.Xc</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Exchange-correlation term, defined by a list of functionals and usually evaluated through libxc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/xc.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.χ0Mixing" href="#DFTK.χ0Mixing"><code>DFTK.χ0Mixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Generic mixing function using a model for the susceptibility composed of the sum of the <code>χ0terms</code>. For valid <code>χ0terms</code> See the subtypes of <code>χ0Model</code>. The dielectric model is solved in real space using a GMRES. Either the full kernel (<code>RPA=false</code>) or only the Hartree kernel (<code>RPA=true</code>) are employed. <code>verbose=true</code> lets the GMRES run in verbose mode (useful for debugging).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.fft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.fft!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>fft!</code>. NOTE: If <code>kpt</code> is given, not only <code>f_fourier</code> but also <code>f_real</code> is overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}" href="#AbstractFFTs.fft-Union{Tuple{U}, Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray{U}}} where {T, U}"><code>AbstractFFTs.fft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_real)</code></pre><p>Perform an FFT to obtain the Fourier representation of <code>f_real</code>. If <code>kpt</code> is given, the coefficients are truncated to the k-dependent spherical basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}" href="#AbstractFFTs.ifft!-Tuple{AbstractArray{T, 3} where T, PlaneWaveBasis, AbstractArray{T, 3} where T}"><code>AbstractFFTs.ifft!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>ifft</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}" href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>AbstractFFTs.ifft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ifft(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_fourier)</code></pre><p>Perform an iFFT to obtain the quantity defined by <code>f_fourier</code> defined on the k-dependent spherical basis set (if <code>kpt</code> is given) or the k-independent cubic (if it is not) on the real-space grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtomsBase.atomic_symbol-Tuple{DFTK.Element}" href="#AtomsBase.atomic_symbol-Tuple{DFTK.Element}"><code>AtomsBase.atomic_symbol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Chemical symbol corresponding to an element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtomsBase.atomic_system" href="#AtomsBase.atomic_system"><code>AtomsBase.atomic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">atomic_system(model::DFTK.Model, magnetic_moments=[])
atomic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/atomsbase.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AtomsBase.periodic_system" href="#AtomsBase.periodic_system"><code>AtomsBase.periodic_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">periodic_system(model::DFTK.Model, magnetic_moments=[])
periodic_system(lattice, atoms, positions, magnetic_moments=[])</code></pre><p>Construct an AtomsBase atomic system from a DFTK <code>model</code> and associated magnetic moments or from the usual <code>lattice</code>, <code>atoms</code> and <code>positions</code> list used in DFTK plus magnetic moments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/atomsbase.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Brillouin.KPaths.irrfbz_path-Tuple{Any}" href="#Brillouin.KPaths.irrfbz_path-Tuple{Any}"><code>Brillouin.KPaths.irrfbz_path</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract the high-symmetry <span>$k$</span>-point path corresponding to the passed <code>model</code> using <code>Brillouin</code>. Uses the conventions described in the reference work by Cracknell, Davies, Miller, and Love (CDML). Of note, this has minor differences to the <span>$k$</span>-path reference (<a href="https://doi.org/10.1016/j.commatsci.2016.10.015">Y. Himuma et. al. Comput. Mater. Sci. <strong>128</strong>, 140 (2017)</a>) underlying the path-choices of <code>Brillouin.jl</code>, specifically for oA and mC Bravais types.</p><p>If the cell is a supercell of a smaller primitive cell, the standard <span>$k$</span>-path of the associated primitive cell is returned. So, the high-symmetry <span>$k$</span> points are those of the primitive cell Brillouin zone, not those of the supercell Brillouin zone.</p><p>The <code>dim</code> argument allows to artificially truncate the dimension of the employed model, e.g. allowing to plot a 2D bandstructure of a 3D model (useful for example for plotting band structures of sheets with <code>dim=2</code>).</p><p>Due to lacking support in <code>Spglib.jl</code> for two-dimensional lattices it is (a) assumed that <code>model.lattice</code> is a <em>conventional</em> lattice and (b) required to pass the space group number using the <code>sgnum</code> keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/band_structure.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.CROP" href="#DFTK.CROP"><code>DFTK.CROP</code></a> — <span class="docstring-category">Function</span></header><section><div><p>CROP-accelerated root-finding iteration for <code>f</code>, starting from <code>x0</code> and keeping a history of <code>m</code> steps. Optionally <code>warming</code> specifies the number of non-accelerated steps to perform for warming up the history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_solvers.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors(basis::PlaneWaveBasis)
G_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of wave vectors <span>$G$</span> in reduced (integer) coordinates of a <code>basis</code> or a <span>$k$</span>-point <code>kpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L374-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}" href="#DFTK.G_vectors-Tuple{Union{Tuple, AbstractVector}}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors([architecture=AbstractArchitecture], fft_size::Tuple)</code></pre><p>The wave vectors <code>G</code> in reduced (integer) coordinates for a cubic basis set of given sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.G_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.G_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_vectors_cart(basis::PlaneWaveBasis)
G_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G$</span> vectors of a given <code>basis</code> or <code>kpt</code>, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L386-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L399-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_cart-Tuple{PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Gplusk_vectors_cart(basis::PlaneWaveBasis, kpt::Kpoint)</code></pre><p>The list of <span>$G + k$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}" href="#DFTK.Gplusk_vectors_in_supercell-Tuple{PlaneWaveBasis, PlaneWaveBasis, Kpoint}"><code>DFTK.Gplusk_vectors_in_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maps all <span>$k+G$</span> vectors of an given basis as <span>$G$</span> vectors of the supercell basis, in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/supercell.jl#L63-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.HybridMixing-Tuple{}" href="#DFTK.HybridMixing-Tuple{}"><code>DFTK.HybridMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D) \\
    &amp;+ \sqrt{L(x)} \text{IFFT} \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} \text{FFT} \sqrt{L(x)}
\end{aligned}\]</p><p>where <span>$C_0 = 1 - ε_r$</span>, <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states and the same convention for parameters are used as in <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Additionally there is the real-space localization function <code>L(r)</code>. For details see Herbst, Levitt 2020 arXiv:2009.01665</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L146-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.IncreaseMixingTemperature-Tuple{}" href="#DFTK.IncreaseMixingTemperature-Tuple{}"><code>DFTK.IncreaseMixingTemperature</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Increase the temperature used for computing the SCF preconditioners. Initially the temperature is increased by a <code>factor</code>, which is then smoothly lowered towards the temperature used within the model as the SCF converges. Once the density change is below <code>above_ρdiff</code> the mixing temperature is equal to the model temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LdosMixing-Tuple{}" href="#DFTK.LdosMixing-Tuple{}"><code>DFTK.LdosMixing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The model for the susceptibility is</p><p class="math-container">\[\begin{aligned}
    χ_0(r, r&#39;) &amp;= (-D_\text{loc}(r) δ(r, r&#39;) + D_\text{loc}(r) D_\text{loc}(r&#39;) / D)
\end{aligned}\]</p><p>where <span>$D_\text{loc}$</span> is the local density of states, <span>$D$</span> is the density of states. For details see Herbst, Levitt 2020 arXiv:2009.01665.</p><p>Important <code>kwargs</code> passed on to <a href="#DFTK.χ0Mixing"><code>χ0Mixing</code></a></p><ul><li><code>RPA</code>: Is the random-phase approximation used for the kernel (i.e. only Hartree kernel is used and not XC kernel)</li><li><code>verbose</code>: Run the GMRES in verbose mode.</li><li><code>reltol</code>: Relative tolerance for GMRES</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/mixing.jl#L174-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfAcceptImprovingStep-Tuple{}" href="#DFTK.ScfAcceptImprovingStep-Tuple{}"><code>DFTK.ScfAcceptImprovingStep</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Accept a step if the energy is at most increasing by <code>max_energy</code> and the residual is at most <code>max_relative_residual</code> times the residual in the previous step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/potential_mixing.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfConvergenceDensity-Tuple{Any}" href="#DFTK.ScfConvergenceDensity-Tuple{Any}"><code>DFTK.ScfConvergenceDensity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence by using the L2Norm of the change between input density and unpreconditioned output density (ρout)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfConvergenceEnergy-Tuple{Any}" href="#DFTK.ScfConvergenceEnergy-Tuple{Any}"><code>DFTK.ScfConvergenceEnergy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence as soon as total energy change drops below tolerance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L91-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfConvergenceForce-Tuple{Any}" href="#DFTK.ScfConvergenceForce-Tuple{Any}"><code>DFTK.ScfConvergenceForce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence on the change in cartesian force between two iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfDefaultCallback-Tuple{}" href="#DFTK.ScfDefaultCallback-Tuple{}"><code>DFTK.ScfDefaultCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default callback function for <code>self_consistent_field</code> and <code>newton</code>, which prints a convergence table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfDiagtol-Tuple{}" href="#DFTK.ScfDiagtol-Tuple{}"><code>DFTK.ScfDiagtol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the tolerance used for the next diagonalization. This function takes <span>$|ρnext - ρin|$</span> and multiplies it with <code>ratio_ρdiff</code> to get the next <code>diagtol</code>, ensuring additionally that the returned value is between <code>diagtol_min</code> and <code>diagtol_max</code> and never increases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfPlotTrace" href="#DFTK.ScfPlotTrace"><code>DFTK.ScfPlotTrace</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the trace of an SCF, i.e. the absolute error of the total energy at each iteration versus the converged energy in a semilog plot. By default a new plot canvas is generated, but an existing one can be passed and reused along with <code>kwargs</code> for the call to <code>plot!</code>. Requires Plots to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfSaveCheckpoints" href="#DFTK.ScfSaveCheckpoints"><code>DFTK.ScfSaveCheckpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Adds simplistic checkpointing to a DFTK self-consistent field calculation. Requires JLD2 to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_callbacks.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_K-Tuple{PlaneWaveBasis, Any, Any, Any, Any}" href="#DFTK.apply_K-Tuple{PlaneWaveBasis, Any, Any, Any, Any}"><code>DFTK.apply_K</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_K(basis::PlaneWaveBasis, δψ, ψ, ρ, occupation)</code></pre><p>Compute the application of K defined at ψ to δψ. ρ is the density issued from ψ. δψ also generates a δρ, computed with <code>compute_δρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/hessian.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}" href="#DFTK.apply_kernel-Tuple{PlaneWaveBasis, Any}"><code>DFTK.apply_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_kernel(basis::PlaneWaveBasis, δρ; kwargs...)</code></pre><p>Computes the potential response to a perturbation δρ in real space, as a 4D (i,j,k,σ) array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/terms.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any, AbstractVecOrMat}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a symmetry operation to eigenvectors <code>ψk</code> at a given <code>kpoint</code> to obtain an equivalent point in [-0.5, 0.5)^3 and associated eigenvectors (expressed in the basis of the new <span>$k$</span>-point).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_symop-Tuple{SymOp, Any, Any}" href="#DFTK.apply_symop-Tuple{SymOp, Any, Any}"><code>DFTK.apply_symop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a symmetry operation to a density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L151-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}" href="#DFTK.apply_Ω-Tuple{Any, Any, Hamiltonian, Any}"><code>DFTK.apply_Ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_Ω(δψ, ψ, H::Hamiltonian, Λ)</code></pre><p>Compute the application of Ω defined at ψ to δψ. H is the Hamiltonian computed from ψ and Λ is the set of Rayleigh coefficients ψk&#39; * Hk * ψk at each k-point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/hessian.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_χ0-NTuple{6, Any}" href="#DFTK.apply_χ0-NTuple{6, Any}"><code>DFTK.apply_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the density variation δρ corresponding to a potential variation δV.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/chi0.jl#L371-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.atom_decay_length-Tuple{Any, Any}" href="#DFTK.atom_decay_length-Tuple{Any, Any}"><code>DFTK.atom_decay_length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the lengthscale of the valence density for an atom with <code>n_elec_core</code> core and <code>n_elec_valence</code> valence electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/guess_density.jl#L129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}" href="#DFTK.attach_psp-Tuple{AtomsBase.AbstractSystem, AbstractDict{Symbol, String}}"><code>DFTK.attach_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">attach_psp(system::AbstractSystem, pspmap::AbstractDict{Symbol,String})
attach_psp(system::AbstractSystem; psps::String...)</code></pre><p>Return a new system with the <code>pseudopotential</code> property of all atoms set according to the passed <code>pspmap</code>, which maps from the atomic symbol to a pseudopotential identifier. Alternatively the mapping from atomic symbol to pseudopotential identifier can also be passed as keyword arguments. An empty string can be used to denote elements where the full Coulomb potential should be employed.</p><p><strong>Examples</strong></p><p>Select pseudopotentials for all silicon and oxygen atoms in the system.</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Dict(:Si =&gt; &quot;hgh/lda/si-q4&quot;, :O =&gt; &quot;hgh/lda/o-q6&quot;)</code></pre><p>Same thing but using the kwargs syntax:</p><pre><code class="language-julia-repl hljs">julia&gt; attach_psp(system, Si=&quot;hgh/lda/si-q4&quot;, O=&quot;hgh/lda/o-q6&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/attach_psp.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}" href="#DFTK.build_fft_plans!-Tuple{Array{ComplexF64}}"><code>DFTK.build_fft_plans!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plan a FFT of type <code>T</code> and size <code>fft_size</code>, spending some time on finding an optimal algorithm. (Inplace, out-of-place) x (forward, backward) FFT plans are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L255-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_form_factors-Tuple{Any, Array}" href="#DFTK.build_form_factors-Tuple{Any, Array}"><code>DFTK.build_form_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build form factors (Fourier transforms of projectors) for an atom centered at 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/nonlocal.jl#L182-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T" href="#DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, Any, Any}} where T"><code>DFTK.build_projection_vectors_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build projection vectors for a atoms array generated by term_nonlocal</p><p>H<em>at  = sum</em>ij Cij |pi&gt; &lt;pj| H<em>per = sum</em>R sum<em>ij Cij |pi(x-R)&gt; &lt;pj(x-R)|       = sum</em>R sum_ij Cij |pi(x-R)&gt; &lt;pj(x-R)|</p><p>&lt;e<em>kG&#39;|H</em>per|e<em>kG&gt; = ...                    = 1/Ω sum</em>ij Cij pihat(k+G&#39;) pjhat(k+G)^*</p><p>where pihat(q) = ∫_R^3 pi(r) e^{-iqr} dr</p><p>We store 1/√Ω pihat(k+G) in proj_vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/nonlocal.jl#L132-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.bzmesh_ir_wedge-Tuple{Any, Any}" href="#DFTK.bzmesh_ir_wedge-Tuple{Any, Any}"><code>DFTK.bzmesh_ir_wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> bzmesh_ir_wedge(kgrid_size, symmetries; kshift=[0, 0, 0])</code></pre><p>Construct the irreducible wedge of a uniform Brillouin zone mesh for sampling <span>$k$</span>-points, given the crystal symmetries <code>symmetries</code>. Returns the list of irreducible <span>$k$</span>-point (fractional) coordinates, the associated weights and the new <code>symmetries</code> compatible with the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.bzmesh_uniform-Tuple{Any}" href="#DFTK.bzmesh_uniform-Tuple{Any}"><code>DFTK.bzmesh_uniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bzmesh_uniform(kgrid_size; kshift=[0, 0, 0])</code></pre><p>Construct a (shifted) uniform Brillouin zone mesh for sampling the <span>$k$</span>-points. Returns all <span>$k$</span>-point coordinates, appropriate weights and the identity SymOp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cell_to_supercell-Tuple{NamedTuple}" href="#DFTK.cell_to_supercell-Tuple{NamedTuple}"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transpose all data from a given self-consistent-field result from unit cell to supercell conventions. The parameters to adapt are the following:</p><ul><li><span>$basis_supercell$</span> and <span>$ψ_supercell$</span> are computed by the routines above.</li><li>The supercell occupations vector is the concatenation of all input occupations vectors.</li><li>The supercell density is computed with supercell occupations and <span>$ψ_supercell$</span>.</li><li>Supercell energies are the multiplication of input energies by the number of unit cells in the supercell.</li></ul><p>Other parameters stay untouched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/supercell.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cell_to_supercell-Tuple{PlaneWaveBasis}" href="#DFTK.cell_to_supercell-Tuple{PlaneWaveBasis}"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a plane-wave basis whose unit cell is the supercell associated to an input basis <span>$kgrid$</span>. All other parameters are modified so that the respective physical systems associated to both basis are equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/supercell.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real" href="#DFTK.cell_to_supercell-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T&lt;:Real"><code>DFTK.cell_to_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Re-organize Bloch waves computed in a given basis as Bloch waves of the associated supercell basis. The output <span>$ψ_supercell$</span> have a single component at <span>$Γ$</span>-point, such that <span>$ψ_supercell[Γ][:, k+n]$</span> contains <span>$ψ[k][:, n]$</span>, within normalization on the supercell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/supercell.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T" href="#DFTK.cg!-Union{Tuple{T}, Tuple{AbstractVector{T}, LinearMaps.LinearMap{T}, AbstractVector{T}}} where T"><code>DFTK.cg!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implementation of the conjugate gradient method which allows for preconditioning and projection operations along iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/cg.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.charge_ionic-Tuple{DFTK.Element}" href="#DFTK.charge_ionic-Tuple{DFTK.Element}"><code>DFTK.charge_ionic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total ionic charge of an atom type (nuclear charge - core electrons)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.charge_nuclear-Tuple{DFTK.Element}" href="#DFTK.charge_nuclear-Tuple{DFTK.Element}"><code>DFTK.charge_nuclear</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total nuclear charge of an atom type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cis2pi-Tuple{Any}" href="#DFTK.cis2pi-Tuple{Any}"><code>DFTK.cis2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute exp(2π i x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/cis2pi.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_Ak_gaussian_guess-Tuple{PlaneWaveBasis, Any, Any, Any, Any}" href="#DFTK.compute_Ak_gaussian_guess-Tuple{PlaneWaveBasis, Any, Any, Any, Any}"><code>DFTK.compute_Ak_gaussian_guess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the matrix <span>$[A_k]_{m,n} = \langle ψ_m^k | g^{\text{per}}_n \rangle$</span></p><p><span>$g^{per}_n$</span> are periodized gaussians whose respective centers are given as an  (num_bands,1) array [ [center 1], ... ].</p><p>Centers are to be given in lattice coordinates and G_vectors in reduced coordinates. The dot product is computed in the Fourier space.</p><p>Given an orbital <span>$g_n$</span>, the periodized orbital is defined by :  <span>$g^{per}_n =  \sum\limits_{R \in {\rm lattice}} g_n( \cdot - R)$</span>. The  Fourier coefficient of <span>$g^{per}_n$</span> at any G is given by the value of the Fourier transform of <span>$g_n$</span> in G.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_current-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_current</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the <em>probability</em> (not charge) current, ∑ fn Im(ψn* ∇ψn)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/current.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_density-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_density(basis::PlaneWaveBasis, ψ::AbstractVector, occupation::AbstractVector)</code></pre><p>Compute the density for a wave function <code>ψ</code> discretized on the plane-wave grid <code>basis</code>, where the individual k-points are occupied according to <code>occupation</code>. <code>ψ</code> should be one coefficient matrix per <span>$k$</span>-point. It is possible to ask only for occupations higher than a certain level to be computed by using an optional <code>occupation_threshold</code>. By default all occupation numbers are considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/densities.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_dos-Tuple{Any, Any, Any}" href="#DFTK.compute_dos-Tuple{Any, Any, Any}"><code>DFTK.compute_dos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Total density of states at energy ε</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/dos.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T" href="#DFTK.compute_fft_size-Union{Tuple{T}, Tuple{Model{T}, Any}, Tuple{Model{T}, Any, Any}} where T"><code>DFTK.compute_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the minimal grid size for the cubic basis set to be able to represent product of orbitals (with the default <code>supersampling=2</code>).</p><p>Optionally optimize the grid afterwards for the FFT procedure by ensuring factorization into small primes.</p><p>The function will determine the smallest parallelepiped containing the wave vectors  <span>$|G|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span>. For an exact representation of the density resulting from wave functions represented in the spherical basis sets, <code>supersampling</code> should be at least <code>2</code>.</p><p>If <code>factors</code> is not empty, ensure that the resulting fft_size contains all the factors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L140-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_forces-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the forces of an obtained SCF solution. Returns the forces wrt. the fractional lattice vectors. To get cartesian forces use <a href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>compute_forces_cart</code></a>. Returns a list of lists of forces (as SVector{3}) in the same order as the <code>atoms</code> and <code>positions</code> in the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/forces.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}" href="#DFTK.compute_forces_cart-Tuple{PlaneWaveBasis, Any, Any}"><code>DFTK.compute_forces_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the cartesian forces of an obtained SCF solution in Hartree / Bohr. Returns a list of lists of forces <code>[[force for atom in positions] for (element, positions) in atoms]</code> which has the same structure as the <code>atoms</code> object passed to the underlying <a href="#DFTK.Model-Tuple{AtomsBase.AbstractSystem}"><code>Model</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/forces.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_inverse_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the inverse of the lattice. Takes special care of 1D or 2D cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/structure.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.compute_kernel-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.compute_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_kernel(basis::PlaneWaveBasis; kwargs...)</code></pre><p>Computes a matrix representation of the full response kernel (derivative of potential with respect to density) in real space. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks</p><p class="math-container">\[\left(\begin{array}{cc}
    K_{αα} &amp; K_{αβ}\\
    K_{βα} &amp; K_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/terms.jl#L64-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.compute_ldos-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.compute_ldos</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local density of states, in real space. <code>weight_threshold</code> is a threshold to screen away small contributions to the LDOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/dos.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, Number}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute occupation given eigenvalues and Fermi level</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/occupation.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T" href="#DFTK.compute_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractVector, AbstractFermiAlgorithm}} where T"><code>DFTK.compute_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute occupation and Fermi level given eigenvalues and using <code>fermialg</code>. The <code>tol_n_elec</code> gives the accuracy on the electron count which should be at least achieved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/occupation.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#DFTK.compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>DFTK.compute_recip_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the reciprocal lattice. We use the convention that the reciprocal lattice is the set of G vectors such that G ⋅ R ∈ 2π ℤ for all R in the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/structure.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_stresses_cart-Tuple{Any}" href="#DFTK.compute_stresses_cart-Tuple{Any}"><code>DFTK.compute_stresses_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the stresses (= 1/Vol dE/d(M*lattice), taken at M=I) of an obtained SCF solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/stresses.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a sparse matrix that maps quantities given on <code>basis_in</code> and <code>kpt_in</code> to quantities on <code>basis_out</code> and <code>kpt_out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L39-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.compute_transfer_matrix-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.compute_transfer_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a list of sparse matrices (one per <span>$k$</span>-point) that map quantities given in the <code>basis_in</code> basis to quantities given in the <code>basis_out</code> basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L49-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_unit_cell_volume-Tuple{Any}" href="#DFTK.compute_unit_cell_volume-Tuple{Any}"><code>DFTK.compute_unit_cell_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute unit cell volume volume. In case of 1D or 2D case, the volume is the length/surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/structure.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, Any, Any, T, Any, Any}} where T" href="#DFTK.compute_δocc!-Union{Tuple{T}, Tuple{Any, Any, Any, T, Any, Any}} where T"><code>DFTK.compute_δocc!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the derivatives of the occupations (and of the Fermi level). The derivatives of the occupations are in-place stored in δocc. The tuple (; δocc, δεF) is returned. It is assumed the passed <code>δocc</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/chi0.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_δψ!-NTuple{7, Any}" href="#DFTK.compute_δψ!-NTuple{7, Any}"><code>DFTK.compute_δψ!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform in-place computations of the derivatives of the wave functions by solving a Sternheimer equation for each <code>k</code>-points. It is assumed the passed <code>δψ</code> are initialised to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/chi0.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_χ0-Tuple{Any}" href="#DFTK.compute_χ0-Tuple{Any}"><code>DFTK.compute_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the independent-particle susceptibility. Will blow up for large systems. For non-spin-polarized calculations the matrix dimension is <code>prod(basis.fft_size)</code> × <code>prod(basis.fft_size)</code> and for collinear spin-polarized cases it is <code>2prod(basis.fft_size)</code> × <code>2prod(basis.fft_size)</code>. In this case the matrix has effectively 4 blocks, which are:</p><p class="math-container">\[\left(\begin{array}{cc}
    (χ_0)_{αα}  &amp; (χ_0)_{αβ} \\
    (χ_0)_{βα}  &amp; (χ_0)_{ββ}
\end{array}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/chi0.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.cos2pi-Tuple{Any}" href="#DFTK.cos2pi-Tuple{Any}"><code>DFTK.cos2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute cos(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/cis2pi.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{Any, Any}" href="#DFTK.count_n_proj-Tuple{Any, Any}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psps, psp_positions)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code> and for all atoms in the system, including angular parts from -m:m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp, l)</code></pre><p>Number of projector functions for angular momentum <code>l</code>, including angular parts from -m:m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj(psp)</code></pre><p>Number of projector functions for all angular momenta up to <code>psp.lmax</code>, including angular parts from -m:m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp, Integer}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(psp, l)</code></pre><p>Number of projector radial functions at angular momentum <code>l</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}" href="#DFTK.count_n_proj_radial-Tuple{DFTK.NormConservingPsp}"><code>DFTK.count_n_proj_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_n_proj_radial(psp)</code></pre><p>Number of projector radial functions at all angular momenta up to <code>psp.lmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.create_supercell-NTuple{4, Any}" href="#DFTK.create_supercell-NTuple{4, Any}"><code>DFTK.create_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a supercell of size <code>supercell_size</code> from a unit cell described by its <code>lattice</code>, <code>atoms</code> and their <code>positions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/supercell.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.datadir_psp-Tuple{}" href="#DFTK.datadir_psp-Tuple{}"><code>DFTK.datadir_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the data directory with pseudopotential files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/load_psp.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}" href="#DFTK.default_fermialg-Tuple{DFTK.Smearing.SmearingFunction}"><code>DFTK.default_fermialg</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default selection of a Fermi level determination algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/occupation.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.default_spin_polarization-Tuple{Any}" href="#DFTK.default_spin_polarization-Tuple{Any}"><code>DFTK.default_spin_polarization</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>:none</code> if no element has a magnetic moment, else <code>:collinear</code> or <code>:full</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L213-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.default_symmetries-NTuple{6, Any}" href="#DFTK.default_symmetries-NTuple{6, Any}"><code>DFTK.default_symmetries</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default logic to determine the symmetry operations to be used in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L225-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.default_wannier_centres-Tuple{Any}" href="#DFTK.default_wannier_centres-Tuple{Any}"><code>DFTK.default_wannier_centres</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default random Gaussian guess for maximally-localised wannier functions generated in reduced coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L243-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}" href="#DFTK.diagonalize_all_kblocks-Tuple{Any, Hamiltonian, Int64}"><code>DFTK.diagonalize_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function for diagonalising each <span>$k$</span>-Point blow of ham one step at a time. Some logic for interpolating between <span>$k$</span>-points is used if <code>interpolate_kpoints</code> is true and if no guesses are given. <code>eigensolver</code> is the iterative eigensolver that really does the work, operating on a single <span>$k$</span>-Block. <code>eigensolver</code> should support the API <code>eigensolver(A, X0; prec, tol, maxiter)</code> <code>prec_type</code> should be a function that returns a preconditioner when called as <code>prec(ham, kpt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/eigen/diag.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.diameter-Tuple{AbstractMatrix}" href="#DFTK.diameter-Tuple{AbstractMatrix}"><code>DFTK.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the diameter of the unit cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/structure.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.direct_minimization-Tuple{PlaneWaveBasis}" href="#DFTK.direct_minimization-Tuple{PlaneWaveBasis}"><code>DFTK.direct_minimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the ground state by direct minimization. <code>kwargs...</code> are passed to <code>Optim.Options()</code>. Note that the resulting ψ are not necessarily eigenvectors of the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/direct_minimization.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.disable_threading-Tuple{}" href="#DFTK.disable_threading-Tuple{}"><code>DFTK.disable_threading</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience function to disable all threading in DFTK and assert that Julia threading is off as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/threading.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.divergence_real-Tuple{Any, Any}" href="#DFTK.divergence_real-Tuple{Any, Any}"><code>DFTK.divergence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute divergence of an operand function, which returns the cartesian x,y,z components in real space when called with the arguments 1 to 3. The divergence is also returned as a real-space array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/xc.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.energy_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T" href="#DFTK.energy_ewald-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}} where T"><code>DFTK.energy_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the electrostatic interaction energy per unit cell between point charges in a uniform background of compensating charge to yield net neutrality.<code>lattice</code> should contain the lattice vectors as columns. <code>charges</code> and <code>positions</code> are the point charges and their positions (as an array of arrays) in fractional coordinates. If <code>forces</code> is not nothing, minus the derivatives of the energy with respect to <code>positions</code> is computed.</p><p>For now this function returns zero energy and force on non-3D systems. Use a pairwise potential term if you want to customise this treatment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/ewald.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.energy_pairwise-Union{Tuple{T}, Tuple{Model{T}, Any, Any}} where T" href="#DFTK.energy_pairwise-Union{Tuple{T}, Tuple{Model{T}, Any, Any}} where T"><code>DFTK.energy_pairwise</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the pairwise interaction energy per unit cell between atomic sites. If <code>forces</code> is not nothing, minus the derivatives of the energy with respect to <code>positions</code> is computed. The potential is expected to decrease quickly at infinity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/pairwise.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.energy_psp_correction-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.energy_psp_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the correction term for properly modelling the interaction of the pseudopotential core with the compensating background charge induced by the <code>Ewald</code> term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/psp_correction.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.enforce_real!-Tuple{Any, Any}" href="#DFTK.enforce_real!-Tuple{Any, Any}"><code>DFTK.enforce_real!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Ensure its real-space equivalent of passed Fourier-space representation is entirely real by removing wavevectors <code>G</code> that don&#39;t have a <code>-G</code> counterpart in the basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L344-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T" href="#DFTK.estimate_integer_lattice_bounds-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}, Tuple{AbstractMatrix{T}, Any, Any}} where T"><code>DFTK.estimate_integer_lattice_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate integer bounds for dense space loops from a given inequality ||Mx|| ≤ δ. For 1D and 2D systems the limit will be zero in the auxiliary dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/structure.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_energy_correction" href="#DFTK.eval_psp_energy_correction"><code>DFTK.eval_psp_energy_correction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_psp_energy_correction([T=Float64,] psp, n_electrons)</code></pre><p>Evaluate the energy correction to the Ewald electrostatic interaction energy of one unit cell, which is required compared the Ewald expression for point-like nuclei. <code>n_electrons</code> is the number of electrons per unit cell. This defines the uniform compensating background charge, which is assumed here.</p><p>Notice: The returned result is the <em>energy per unit cell</em> and not the energy per volume. To obtain the latter, the caller needs to divide by the unit cell volume.</p><p>The energy correction is defined as the limit of the Fourier-transform of the local potential as q -&gt; 0, using the same correction as in the Fourier-transform of the local potential: lim{q-&gt;0} 4π Nelec ∫{R+} (V(r) - C(r)) sin(qr)/qr r^2 dr + F[C(r)] = 4π Nelec ∫{R+} (V(r) + Z/r) r^2 dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_energy_correction-Tuple{Any, PspUpf, Any}" href="#DFTK.eval_psp_energy_correction-Tuple{Any, PspUpf, Any}"><code>DFTK.eval_psp_energy_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_energy_correction(T::Type, psp::PspUpf, n_electrons::Number)</code></pre><p>For UPFs, the integral is transformed to the following sum: 4π Nelec Σ{i} r<a href="r[i] V(r[i]) + Z">i</a> dr[i]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_fourier(psp, q)</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space: Vloc(q) = ∫<em>{R^3} Vloc(r) e^{-iqr} dr         = 4π ∫</em>{R+} Vloc(r) sin(qr)/q r dr In practice, the local potential should be corrected using a Coulomb-like term C(r) = -Z/r to remove the long-range tail of Vloc(r) from the integral: Vloc(q) = (∫_{R^3} (Vloc(r) - C(r)) e^{-iqr} dr) + F[C(r)]         = 4π ∫{R+} (Vloc(r) + Z/r) sin(qr)/qr r^2 dr - Z/q^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_fourier-Union{Tuple{T}, Tuple{PspUpf, T}} where T&lt;:Real" href="#DFTK.eval_psp_local_fourier-Union{Tuple{T}, Tuple{PspUpf, T}} where T&lt;:Real"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_fourier(psp::PspUpf, q&lt;:Real)</code></pre><p>for UPFs, the integral is transformed to the following sum: 4π/q (Σ{i} sin(q r[i]) (r[i] V(r[i]) + Z) dr[i] - Z/q)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_local_real-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_real-Union{Tuple{T}, Tuple{PspUpf, T}} where T&lt;:Real" href="#DFTK.eval_psp_local_real-Union{Tuple{T}, Tuple{PspUpf, T}} where T&lt;:Real"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> eval_psp_local_real(psp::PspUpf, r&lt;:Real)</code></pre><p>Evaluate the local potential at real-space distance <code>r</code> via linear interpolation on the real-space mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}" href="#DFTK.eval_psp_projector_fourier-Tuple{DFTK.NormConservingPsp, AbstractVector}"><code>DFTK.eval_psp_projector_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_fourier(psp, i, l, q)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal vector with modulus <code>q</code>: p(q) = ∫<em>R^3 p</em>{il}(r) e^{-iqr} dr      = 4π ∫<em>{R+} r^2 p</em>{il}(r) j_l(q r) dr</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projector_fourier-Union{Tuple{T}, Tuple{PspUpf, Any, Any, T}} where T&lt;:Real" href="#DFTK.eval_psp_projector_fourier-Union{Tuple{T}, Tuple{PspUpf, Any, Any, T}} where T&lt;:Real"><code>DFTK.eval_psp_projector_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_fourier(psp::PspUPF, i::Number, l::Number, q&lt;:Real)</code></pre><p>For UPFs, the integral is transformed to the following sum: 4π Σ{k} j<em>l(q r[k]) (r[k]^2 p</em>{il}(r[k]) dr[k])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}" href="#DFTK.eval_psp_projector_real-Tuple{DFTK.NormConservingPsp, Any, Any, AbstractVector}"><code>DFTK.eval_psp_projector_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_real(psp, i, l, r)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> in real-space at the vector with modulus <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/NormConservingPsp.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projector_real-Union{Tuple{T}, Tuple{PspUpf, Any, Any, T}} where T&lt;:Real" href="#DFTK.eval_psp_projector_real-Union{Tuple{T}, Tuple{PspUpf, Any, Any, T}} where T&lt;:Real"><code>DFTK.eval_psp_projector_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_psp_projector_real(psp::PspUpf, i::Number, l::Number, r&lt;:Real)</code></pre><p>Evaluate the ith Kleinman-Bylander β projector with angular momentum l at real-space distance r via linear interpolation on the real-space mesh.</p><p>Note: UPFs store <code>r[j] β_{li}(r[j])</code>, so r=0 is undefined and will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspUpf.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.filled_occupation-Tuple{Any}" href="#DFTK.filled_occupation-Tuple{Any}"><code>DFTK.filled_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maximal occupation of a state (2 for non-spin-polarized electrons, 1 otherwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L252-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T" href="#DFTK.find_equivalent_kpt-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any}} where T"><code>DFTK.find_equivalent_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the equivalent index of the coordinate <code>kcoord</code> ∈ ℝ³ in a list <code>kcoords</code> ∈ [-½, ½)³. <code>ΔG</code> is the vector of ℤ³ such that <code>kcoords[index] = kcoord + ΔG</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L125-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.gather_kpts-Tuple{AbstractArray, PlaneWaveBasis}" href="#DFTK.gather_kpts-Tuple{AbstractArray, PlaneWaveBasis}"><code>DFTK.gather_kpts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gather the distributed data of a quantity depending on <code>k</code>-Points on the master process and return it. On the other (non-master) processes <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L524-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.gather_kpts-Tuple{PlaneWaveBasis}" href="#DFTK.gather_kpts-Tuple{PlaneWaveBasis}"><code>DFTK.gather_kpts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gather the distributed <span>$k$</span>-point data on the master process and return it as a <code>PlaneWaveBasis</code>. On the other (non-master) processes <code>nothing</code> is returned. The returned object should not be used for computations and only to extract data for post-processing and serialisation to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L488-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.gaussian_superposition-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T" href="#DFTK.gaussian_superposition-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T"><code>DFTK.gaussian_superposition</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a superposition of Gaussians as a guess for the density and magnetisation. Expects a list of tuples <code>(coefficient, length, position)</code> for each of the Gaussian, which follow the functional form</p><p class="math-container">\[\hat{ρ}(G) = \text{coefficient} \exp\left(-(2π \text{length} |G|)^2\right)\]</p><p>and are placed at <code>position</code> (in fractional coordinates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/guess_density.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.guess_density" href="#DFTK.guess_density"><code>DFTK.guess_density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">guess_density(basis, magnetic_moments=[])
guess_density(basis, system)</code></pre><p>Build a superposition of atomic densities (SAD) guess density.</p><p>We take for the guess density a Gaussian centered around the atom, of length specified by <code>atom_decay_length</code>, normalized to get the right number of electrons</p><p class="math-container">\[\hat{ρ}(G) = Z \exp\left(-(2π \text{length} |G|)^2\right)\]</p><p>When magnetic moments are provided, construct a symmetry-broken density guess. The magnetic moments should be specified in units of <span>$μ_B$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/guess_density.jl#L18-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}" href="#DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian, Any}"><code>DFTK.hamiltonian_with_total_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a new Hamiltonian with local potential replaced by the given one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/Hamiltonian.jl#L220-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}" href="#DFTK.index_G_vectors-Tuple{Tuple, AbstractVector{&lt;:Integer}}"><code>DFTK.index_G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the index tuple <code>I</code> such that <code>G_vectors(basis)[I] == G</code> or the index <code>i</code> such that <code>G_vectors(basis, kpoint)[i] == G</code>. Returns nothing if outside the range of valid wave vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L433-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}" href="#DFTK.interpolate_density-Tuple{Any, PlaneWaveBasis, PlaneWaveBasis}"><code>DFTK.interpolate_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate a function expressed in a basis <code>basis_in</code> to a basis <code>basis_out</code>. This interpolation uses a very basic real-space algorithm, and makes a DWIM-y attempt to take into account the fact that <code>basis_out</code> can be a supercell of <code>basis_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/interpolation.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}" href="#DFTK.interpolate_kpoint-Tuple{AbstractVecOrMat, PlaneWaveBasis, Kpoint, PlaneWaveBasis, Kpoint}"><code>DFTK.interpolate_kpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate some data from one <span>$k$</span>-point to another. The interpolation is fast, but not necessarily exact. Intended only to construct guesses for iterative solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/interpolation.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T" href="#DFTK.irfft-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, AbstractArray}} where T"><code>DFTK.irfft</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform a real valued iFFT; see <a href="#AbstractFFTs.ifft-Tuple{PlaneWaveBasis, AbstractArray}"><code>ifft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.is_metal-Tuple{Any, Any}" href="#DFTK.is_metal-Tuple{Any, Any}"><code>DFTK.is_metal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_metal(eigenvalues, εF; tol)</code></pre><p>Determine whether the provided bands indicate the material is a metal, i.e. where bands are cut by the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/band_structure.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.k_to_kpq_mapping-Tuple{PlaneWaveBasis, Any}" href="#DFTK.k_to_kpq_mapping-Tuple{PlaneWaveBasis, Any}"><code>DFTK.k_to_kpq_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the indices of the <code>kpoints</code> shifted by <code>q</code>. That is for each <code>kpoint</code> of the <code>basis</code>: <code>kpoints[ik].coordinate + q = kpoints[indices[ik]].coordinate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L159-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}" href="#DFTK.kgrid_from_minimal_n_kpoints-Tuple{Any, Integer}"><code>DFTK.kgrid_from_minimal_n_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Selects a kgrid size which ensures that at least a <code>n_kpoints</code> total number of <span>$k$</span>-points are used. The distribution of <span>$k$</span>-points amongst coordinate directions is as uniformly as possible, trying to achieve an identical minimal spacing in all directions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kgrid_from_minimal_spacing-Tuple{Any, Any}" href="#DFTK.kgrid_from_minimal_spacing-Tuple{Any, Any}"><code>DFTK.kgrid_from_minimal_spacing</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Selects a kgrid size to ensure a minimal spacing (in inverse Bohrs) between kpoints. A reasonable spacing is <code>0.13</code> inverse Bohrs (around <span>$2π * 0.04 \AA^{-1}$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L109-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kgrid_monkhorst_pack-Tuple{Any}" href="#DFTK.kgrid_monkhorst_pack-Tuple{Any}"><code>DFTK.kgrid_monkhorst_pack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the coordinates of the <span>$k$</span>-points in a (shifted) Monkorst-Pack grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D" href="#DFTK.kpath_get_kcoords-Union{Tuple{Brillouin.KPaths.KPathInterpolant{D}}, Tuple{D}} where D"><code>DFTK.kpath_get_kcoords</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return kpoint coordinates in reduced coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/band_structure.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}" href="#DFTK.krange_spin-Tuple{PlaneWaveBasis, Integer}"><code>DFTK.krange_spin</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the index range of <span>$k$</span>-points that have a particular spin component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L469-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.list_psp" href="#DFTK.list_psp"><code>DFTK.list_psp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">list_psp(element; functional, family, core, datadir_psp)</code></pre><p>List the pseudopotential files known to DFTK. Allows various ways to restrict the displayed files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(family=&quot;hgh&quot;)</code></pre><p>will list all HGH-type pseudopotentials and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(family=&quot;hgh&quot;, functional=&quot;lda&quot;)</code></pre><p>will only list those for LDA (also known as Pade in this context) and</p><pre><code class="language-julia-repl hljs">julia&gt; list_psp(:O, core=:semicore)</code></pre><p>will list all oxygen semicore pseudopotentials known to DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/list_psp.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_psp-Tuple{AbstractString}" href="#DFTK.load_psp-Tuple{AbstractString}"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>datadir_psp()</code> and by the <code>key</code>. If the <code>key</code> is a path to a valid file, the extension is used to determine the type of the pseudopotential file format and a respective class is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/load_psp.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_scfres" href="#DFTK.load_scfres"><code>DFTK.load_scfres</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_scfres(filename)</code></pre><p>Load back an <code>scfres</code>, which has previously been stored with <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>. Note the warning in <a href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>save_scfres</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scfres.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.local_potential_fourier-Tuple{DFTK.Element, AbstractVector}" href="#DFTK.local_potential_fourier-Tuple{DFTK.Element, AbstractVector}"><code>DFTK.local_potential_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radial local potential, in Fourier space: V(q) = int_{R^3} V(x) e^{-iqx} dx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.local_potential_real-Tuple{DFTK.Element, AbstractVector}" href="#DFTK.local_potential_real-Tuple{DFTK.Element, AbstractVector}"><code>DFTK.local_potential_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radial local potential, in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}" href="#DFTK.model_DFT-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}, Xc}"><code>DFTK.model_DFT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a DFT model from the specified atoms, with the specified functionals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/standard_models.jl#L27-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_LDA-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_LDA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an LDA model (Perdew &amp; Wang parametrization) from the specified atoms. DOI:10.1103/PhysRevB.45.13244</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/standard_models.jl#L48-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_PBE-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_PBE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an PBE-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.77.3865</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/standard_models.jl#L58-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_SCAN-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_SCAN</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a SCAN meta-GGA model from the specified atoms. DOI:10.1103/PhysRevLett.115.036402</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/standard_models.jl#L68-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}" href="#DFTK.model_atomic-Tuple{AbstractMatrix, Vector{&lt;:DFTK.Element}, Vector{&lt;:AbstractVector}}"><code>DFTK.model_atomic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience constructor, which builds a standard atomic (kinetic + atomic potential) model. Use <code>extra_terms</code> to add additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/standard_models.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.mpi_nprocs" href="#DFTK.mpi_nprocs"><code>DFTK.mpi_nprocs</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Number of processors used in MPI. Can be called without ensuring initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/mpi.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.multiply_by_expiqr-NTuple{4, Any}" href="#DFTK.multiply_by_expiqr-NTuple{4, Any}"><code>DFTK.multiply_by_expiqr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the Fourier coefficients for <code>ψk · e^{i q·r}</code> in the basis of <code>kpt_out</code>, where <code>ψk</code> is defined on a basis <code>kpt_in</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L148-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.n_elec_core-Tuple{DFTK.Element}" href="#DFTK.n_elec_core-Tuple{DFTK.Element}"><code>DFTK.n_elec_core</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of core electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.n_elec_valence-Tuple{DFTK.Element}" href="#DFTK.n_elec_valence-Tuple{DFTK.Element}"><code>DFTK.n_elec_valence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of valence electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/elements.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.n_electrons_from_atoms-Tuple{Any}" href="#DFTK.n_electrons_from_atoms-Tuple{Any}"><code>DFTK.n_electrons_from_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Number of valence electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T" href="#DFTK.newton-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any}} where T"><code>DFTK.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton(basis::PlaneWaveBasis{T}, ψ0;
       tol=1e-6, tol_cg=tol / 100, maxiter=20, callback=ScfDefaultCallback(),
       is_converged=ScfConvergenceDensity(tol))</code></pre><p>Newton algorithm. Be careful that the starting point needs to be not too far from the solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/newton.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.next_compatible_fft_size-Tuple{Int64}" href="#DFTK.next_compatible_fft_size-Tuple{Int64}"><code>DFTK.next_compatible_fft_size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the next compatible FFT size Sizes must (a) be a product of small primes only and (b) contain the factors. If smallprimes is empty (a) is skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/fft.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.next_density" href="#DFTK.next_density"><code>DFTK.next_density</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Obtain new density ρ by diagonalizing <code>ham</code>. Follows the policy imposed by the <code>bands</code> data structure to determine and adjust the number of bands to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/self_consistent_field.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.norm2-Tuple{Any}" href="#DFTK.norm2-Tuple{Any}"><code>DFTK.norm2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Square of the ℓ²-norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/norm.jl#L11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.norm_cplx-Tuple{Any}" href="#DFTK.norm_cplx-Tuple{Any}"><code>DFTK.norm_cplx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Complex-analytic extension of <code>LinearAlgebra.norm(x)</code> from real to complex inputs. Needed for phonons as we want to perform a matrix-vector product <code>f&#39;(x)·h</code>, where <code>f</code> is a real-to-real function and <code>h</code> a complex vector. To do this using automatic differentiation, we can extend analytically f to accept complex inputs, then differentiate <code>t -&gt; f(x+t·h)</code>. This will fail if non-analytic functions like norm are used for complex inputs, and therefore we have to redefine it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/norm.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.normalize_kpoint_coordinate-Tuple{Real}" href="#DFTK.normalize_kpoint_coordinate-Tuple{Real}"><code>DFTK.normalize_kpoint_coordinate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bring <span>$k$</span>-point coordinates into the range [-0.5, 0.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/bzmesh.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Any, Any, Any, Any, Any}" href="#DFTK.overlap_Mmn_k_kpb-Tuple{PlaneWaveBasis, Any, Any, Any, Any, Any}"><code>DFTK.overlap_Mmn_k_kpb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the matrix <span>$[M^{k,b}]_{m,n} = \langle u_{m,k} | u_{n,k+b} \rangle$</span> for given k, kpb = k+b.</p><p><code>G_shift</code> is the &quot;shifting&quot; vector, correction due to the periodicity conditions imposed on k -&gt; ψ<em>k. It is non zero if kpb is taken in another unit cell of the reciprocal lattice. We use here that : ``u</em>{n(k + G<em>shift)}(r) = e^{-i*\langle G</em>shift,r \rangle} u_{nk}``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.plot_bandstructure" href="#DFTK.plot_bandstructure"><code>DFTK.plot_bandstructure</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Compute and plot the band structure. <code>n_bands</code> selects the number of bands to compute. If this value is absent and an <code>scfres</code> is used to start the calculation a default of <code>n_bands_scf + 5sqrt(n_bands_scf)</code> is used. The unit used to plot the bands can be selected using the <code>unit</code> parameter. Like in the rest of DFTK Hartree is used by default. Another standard choices is <code>unit=u&quot;eV&quot;</code> (electron volts). The <code>kline_density</code> is given in number of <span>$k$</span>-points per inverse bohrs (i.e. overall in units of length).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/band_structure.jl#L210-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.plot_dos" href="#DFTK.plot_dos"><code>DFTK.plot_dos</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the density of states over a reasonable range. Requires to load <code>Plots.jl</code> beforehand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/postprocess/dos.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.psp_local_polynomial" href="#DFTK.psp_local_polynomial"><code>DFTK.psp_local_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The local potential of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) / (t^2 exp(t^2 / 2))$</span> where <span>$t = r_\text{loc} q$</span> and <code>Q</code> is a polynomial of at most degree 8. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspHgh.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.psp_projector_polynomial" href="#DFTK.psp_projector_polynomial"><code>DFTK.psp_projector_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The nonlocal projectors of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) exp(-t^2 / 2)$</span> where <span>$t = r_l q$</span> and <code>Q</code> is a polynomial. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspHgh.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T" href="#DFTK.qcut_psp_local-Union{Tuple{PspHgh{T}}, Tuple{T}} where T"><code>DFTK.qcut_psp_local</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>abs(eval_psp_local_fourier(psp, q))</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspHgh.jl#L134-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T" href="#DFTK.qcut_psp_projector-Union{Tuple{T}, Tuple{PspHgh{T}, Any, Any}} where T"><code>DFTK.qcut_psp_projector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>eval_psp_projector_fourier(psp, q)</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/pseudo/PspHgh.jl#L191-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.r_vectors-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in reduced coordinates. By convention, this is in [0,1)^3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}" href="#DFTK.r_vectors_cart-Tuple{PlaneWaveBasis}"><code>DFTK.r_vectors_cart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r_vectors_cart(basis::PlaneWaveBasis)</code></pre><p>The list of <span>$r$</span> vectors, in cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L425-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.random_density-Tuple{PlaneWaveBasis}" href="#DFTK.random_density-Tuple{PlaneWaveBasis}"><code>DFTK.random_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generate a physically valid random density integrating to the given number of electrons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/guess_density.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.read_w90_nnkp-Tuple{String}" href="#DFTK.read_w90_nnkp-Tuple{String}"><code>DFTK.read_w90_nnkp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Read the .nnkp file provided by the preprocessing routine of Wannier90 (i.e. &quot;wannier90.x -pp prefix&quot;) Returns:</p><ol><li>the array &#39;nnkpts&#39; of k points, their respective nearest neighbors and associated shifing vectors (non zero if the neighbor is located in another cell).</li><li>the number &#39;nntot&#39; of neighbors per k point.</li></ol><p>TODO: add the possibility to exclude bands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.run_wannier90" href="#DFTK.run_wannier90"><code>DFTK.run_wannier90</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Wannerize the obtained bands using wannier90. By default all converged bands from the <code>scfres</code> are employed (change with <code>n_bands</code> kwargs) and <code>n_wannier = n_bands</code> wannier functions are computed using random Gaussians as guesses. All keyword arguments supported by Wannier90 for the disentanglement may be added as keyword arguments. The function returns the <code>fileprefix</code>.</p><div class="admonition is-warning"><header class="admonition-header">Experimental feature</header><div class="admonition-body"><p>Currently this is an experimental feature, which has not yet been tested to full depth. The interface is considered unstable and may change incompatibly in the future. Use at your own risk and please report bugs in case you encounter any.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/stubs.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.save_scfres-Tuple{AbstractString, NamedTuple}" href="#DFTK.save_scfres-Tuple{AbstractString, NamedTuple}"><code>DFTK.save_scfres</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_scfres(filename, scfres)</code></pre><p>Save an <code>scfres</code> obtained from <code>self_consistent_field</code> to a file. The format is determined from the file extension. Currently the following file extensions are recognized and supported:</p><ul><li><strong>jld2</strong>: A JLD2 file. Stores the complete state and can be used (with <a href="#DFTK.load_scfres"><code>load_scfres</code></a>) to restart an SCF from a checkpoint or post-process an SCF solution. See <a href="../tricks/scf_checkpoints/#Saving-SCF-results-on-disk-and-SCF-checkpoints">Saving SCF results on disk and SCF checkpoints</a> for details.</li><li><strong>vts</strong>: A VTK file for visualisation e.g. in <a href="https://www.paraview.org/">paraview</a>. Stores the density, spin density and some metadata (energy, Fermi level, occupation etc.). Supports these keyword arguments:<ul><li><code>save_ψ</code>: Save the real-space representation of the orbitals as well (may lead to larger files).</li><li><code>extra_data</code>: <code>Dict{String,Array}</code> with additional data on the 3D real-space grid to store into the VTK file.</li></ul></li></ul><div class="admonition is-warning"><header class="admonition-header">No compatibility guarantees</header><div class="admonition-body"><p>No guarantees are made with respect to this function at this point. It may change incompatibly between DFTK versions or stop working / be removed in the future.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scfres.jl#L30-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.scf_anderson_solver" href="#DFTK.scf_anderson_solver"><code>DFTK.scf_anderson_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a simple anderson-accelerated SCF solver. <code>m</code> specifies the number of steps to keep the history of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_solvers.jl#L34-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.scf_damping_quadratic_model-Tuple{Any, Any}" href="#DFTK.scf_damping_quadratic_model-Tuple{Any, Any}"><code>DFTK.scf_damping_quadratic_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use the two iteration states <code>info</code> and <code>info_next</code> to find a damping value from a quadratic model for the SCF energy. Returns <code>nothing</code> if the constructed model is not considered trustworthy, else returns the suggested damping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/potential_mixing.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.scf_damping_solver" href="#DFTK.scf_damping_solver"><code>DFTK.scf_damping_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a damped SCF solver updating the density as <code>x = β * x_new + (1 - β) * x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/scf_solvers.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}" href="#DFTK.select_eigenpairs_all_kblocks-Tuple{Any, Any}"><code>DFTK.select_eigenpairs_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to select a subset of eigenpairs on each <span>$k$</span>-Point. Works on the Tuple returned by <code>diagonalize_all_kblocks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/eigen/diag.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T" href="#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real}, Tuple{T}} where T"><code>DFTK.self_consistent_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">self_consistent_field(basis; [tol, mixing, damping, ρ, ψ])</code></pre><p>Solve the Kohn-Sham equations with a density-based SCF algorithm using damped, preconditioned iterations where <span>$ρ_\text{next} = α P^{-1} (ρ_\text{out} - ρ_\text{in})$</span>.</p><p>Overview of parameters:</p><ul><li><code>ρ</code>:   Initial density</li><li><code>ψ</code>:   Initial orbitals</li><li><code>tol</code>: Tolerance for the density change (<span>$\|ρ_\text{out} - ρ_\text{in}\|$</span>) to flag convergence. Default is <code>1e-6</code>.</li><li><code>is_converged</code>: Convergence control callback. Typical objects passed here are <code>DFTK.ScfConvergenceDensity(tol)</code> (the default), <code>DFTK.ScfConvergenceEnergy(tol)</code> or <code>DFTK.ScfConvergenceForce(tol)</code>.</li><li><code>maxiter</code>: Maximal number of SCF iterations</li><li><code>mixing</code>: Mixing method, which determines the preconditioner <span>$P^{-1}$</span> in the above equation. Typical mixings are <a href="#DFTK.LdosMixing-Tuple{}"><code>LdosMixing</code></a>, <a href="#DFTK.KerkerMixing"><code>KerkerMixing</code></a>, <a href="#DFTK.SimpleMixing"><code>SimpleMixing</code></a> or <a href="#DFTK.DielectricMixing"><code>DielectricMixing</code></a>. Default is <code>LdosMixing()</code></li><li><code>damping</code>: Damping parameter <span>$α$</span> in the above equation. Default is <code>0.8</code>.</li><li><code>nbandsalg</code>: By default DFTK uses <code>nbandsalg=AdaptiveBands(model)</code>, which adaptively determines the number of bands to compute. If you want to influence this algorithm or use a predefined number of bands in each SCF step, pass a <a href="#DFTK.FixedBands"><code>FixedBands</code></a> or <a href="#DFTK.AdaptiveBands"><code>AdaptiveBands</code></a>.</li><li><code>callback</code>: Function called at each SCF iteration. Usually takes care of printing the intermediate state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/scf/self_consistent_field.jl#L58-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.sin2pi-Tuple{Any}" href="#DFTK.sin2pi-Tuple{Any}"><code>DFTK.sin2pi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to compute sin(2π x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/cis2pi.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T" href="#DFTK.solve_ΩplusK-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Any, Any, Any}} where T"><code>DFTK.solve_ΩplusK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_ΩplusK(basis::PlaneWaveBasis{T}, ψ, res, occupation;
             tol=1e-10, verbose=false) where {T}</code></pre><p>Return δψ where (Ω+K) δψ = rhs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/hessian.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Any, Any, Any, Any, Any}} where T" href="#DFTK.solve_ΩplusK_split-Union{Tuple{T}, Tuple{Hamiltonian, AbstractArray{T}, Any, Any, Any, Any, Any}} where T"><code>DFTK.solve_ΩplusK_split</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solve the problem <code>(Ω+K) δψ = rhs</code> using a split algorithm, where <code>rhs</code> is typically <code>-δHextψ</code> (the negative matvec of an external perturbation with the SCF orbitals <code>ψ</code>) and <code>δψ</code> is the corresponding total variation in the orbitals <code>ψ</code>. Additionally returns:     - <code>δρ</code>:  Total variation in density)     - <code>δHψ</code>: Total variation in Hamiltonian applied to orbitals     - <code>δeigenvalues</code>: Total variation in eigenvalues     - <code>δVind</code>: Change in potential induced by <code>δρ</code> (the term needed on top of <code>δHextψ</code>       to get <code>δHψ</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/response/hessian.jl#L123-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.spglib_atoms-Tuple{Any, AbstractVector{&lt;:AbstractVector{&lt;:AbstractFloat}}, Any}" href="#DFTK.spglib_atoms-Tuple{Any, AbstractVector{&lt;:AbstractVector{&lt;:AbstractFloat}}, Any}"><code>DFTK.spglib_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convert the DFTK atom groups and positions datastructure into a tuple of datastructures for use with spglib. Validity of the input data is assumed. The output <code>positions</code> contains positions per atom, <code>numbers</code> contains the mapping atom to a unique number for each group of indistinguishable atoms, <code>spins</code> contains the <span>$z$</span>-component of the initial magnetic moment on each atom, <code>mapping</code> contains the mapping of the <code>numbers</code> to the element objects in DFTK and <code>collinear</code> whether the atoms mark a case of collinear spin or not. Notice that if <code>collinear</code> is false then <code>spins</code> is garbage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/spglib.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T" href="#DFTK.spglib_standardize_cell-Union{Tuple{T}, Tuple{AbstractArray{T}, Any, Any}, Tuple{AbstractArray{T}, Any, Any, Any}} where T"><code>DFTK.spglib_standardize_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns crystallographic conventional cell according to the International Table of Crystallography Vol A (ITA) in case <code>primitive=false</code>. If <code>primitive=true</code> the primitive lattice is returned in the convention of the reference work of Cracknell, Davies, Miller, and Love (CDML). Of note this has minor differences to the primitive setting choice made in the ITA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/spglib.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T" href="#DFTK.sphericalbesselj_fast-Union{Tuple{T}, Tuple{Integer, T}} where T"><code>DFTK.sphericalbesselj_fast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sphericalbesselj_fast(l::Integer, x::Number)</code></pre><p>Returns the spherical Bessel function of the first kind j<em>l(x). Consistent with https://en.wikipedia.org/wiki/Bessel</em>function#Spherical<em>Bessel</em>functions and with <code>SpecialFunctions.sphericalbesselj</code>. Specialized for integer <code>0 &lt;= l &lt;= 5</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/spherical_bessels.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.spin_components-Tuple{Symbol}" href="#DFTK.spin_components-Tuple{Symbol}"><code>DFTK.spin_components</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Explicit spin components of the KS orbitals and the density</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Model.jl#L266-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.split_evenly-Tuple{Any, Any}" href="#DFTK.split_evenly-Tuple{Any, Any}"><code>DFTK.split_evenly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Split an iterable evenly into N chunks, which will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/split_evenly.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.standardize_atoms" href="#DFTK.standardize_atoms"><code>DFTK.standardize_atoms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply various standardisations to a lattice and a list of atoms. It uses spglib to detect symmetries (within <code>tol_symmetry</code>), then cleans up the lattice according to the symmetries (unless <code>correct_symmetry</code> is <code>false</code>) and returns the resulting standard lattice and atoms. If <code>primitive</code> is <code>true</code> (default) the primitive unit cell is returned, else the conventional unit cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_kgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_kgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete BZ grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}" href="#DFTK.symmetries_preserving_rgrid-Tuple{Any, Any}"><code>DFTK.symmetries_preserving_rgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Filter out the symmetry operations that don&#39;t respect the symmetries of the discrete real-space grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetrize_forces-Tuple{Model, Any}" href="#DFTK.symmetrize_forces-Tuple{Model, Any}"><code>DFTK.symmetrize_forces</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize the forces in <em>reduced coordinates</em>, forces given as an array forces[iel][α,i]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L237-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetrize_stresses-Tuple{Model, Any}" href="#DFTK.symmetrize_stresses-Tuple{Model, Any}"><code>DFTK.symmetrize_stresses</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize the stress tensor, given as a Matrix in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L220-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetrize_ρ-Tuple{Any, Any}" href="#DFTK.symmetrize_ρ-Tuple{Any, Any}"><code>DFTK.symmetrize_ρ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize a density by applying all the basis (by default) symmetries and forming the average.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L206-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetry_operations" href="#DFTK.symmetry_operations"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the <span>$k$</span>-point symmetry operations associated to a lattice and atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}" href="#DFTK.synchronize_device-Tuple{DFTK.AbstractArchitecture}"><code>DFTK.synchronize_device</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Synchronize data and finish all operations on the execution stream of the device. This needs to be called explicitly before a task finishes (e.g. in an <code>@spawn</code> block).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/architecture.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.to_cpu-Tuple{AbstractArray}" href="#DFTK.to_cpu-Tuple{AbstractArray}"><code>DFTK.to_cpu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array from a device (typically a GPU) to the CPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/architecture.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.to_device-Tuple{DFTK.CPU, Any}" href="#DFTK.to_device-Tuple{DFTK.CPU, Any}"><code>DFTK.to_device</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array to a particular device (typically a GPU)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/architecture.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.total_local_potential-Tuple{Hamiltonian}" href="#DFTK.total_local_potential-Tuple{Hamiltonian}"><code>DFTK.total_local_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the total local potential of the given Hamiltonian, in real space in the spin components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/terms/Hamiltonian.jl#L201-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T" href="#DFTK.transfer_blochwave-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, PlaneWaveBasis{T, VT} where VT&lt;:Real}} where T"><code>DFTK.transfer_blochwave</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer Bloch wave between two basis sets. Limited feature set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}" href="#DFTK.transfer_blochwave_kpt-Tuple{Any, PlaneWaveBasis, Any, Any, Any}"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array <code>ψk_in</code> expanded on <code>kpt_in</code>, and produce <span>$ψ(r) e^{i ΔG·r}$</span> expanded on <code>kpt_out</code>. It is mostly useful for phonons. Beware: <code>ψk_out</code> can lose information if the shift <code>ΔG</code> is large or if the <code>G_vectors</code> differ between <code>k</code>-points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_blochwave_kpt-Union{Tuple{T}, Tuple{Any, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_blochwave_kpt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Transfer an array <code>ψk</code> defined on basis<em>in <span>$k$</span>-point kpt</em>in to basis<em>out <span>$k$</span>-point kpt</em>out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T" href="#DFTK.transfer_mapping-Union{Tuple{T}, Tuple{PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint, PlaneWaveBasis{T, VT} where VT&lt;:Real, Kpoint}} where T"><code>DFTK.transfer_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the index mapping between two bases. Returns two arrays <code>idcs_in</code> and <code>idcs_out</code> such that <code>ψkout[idcs_out] = ψkin[idcs_in]</code> does the transfer from <code>ψkin</code> (defined on <code>basis_in</code> and <code>kpt_in</code>) to <code>ψkout</code> (defined on <code>basis_out</code> and <code>kpt_out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/transfer.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.unfold_bz-Tuple{PlaneWaveBasis}" href="#DFTK.unfold_bz-Tuple{PlaneWaveBasis}"><code>DFTK.unfold_bz</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot; Convert a <code>basis</code> into one that doesn&#39;t use BZ symmetry. This is mainly useful for debug purposes (e.g. in cases we don&#39;t want to bother thinking about symmetries).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/symmetry.jl#L262-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}" href="#DFTK.weighted_ksum-Tuple{PlaneWaveBasis, Any}"><code>DFTK.weighted_ksum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sum an array over kpoints, taking weights into account</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/PlaneWaveBasis.jl#L479-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.write_w90_eig-Tuple{String, Any}" href="#DFTK.write_w90_eig-Tuple{String, Any}"><code>DFTK.write_w90_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write the eigenvalues in a format readable by Wannier90.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L106-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}" href="#DFTK.write_w90_win-Tuple{String, PlaneWaveBasis}"><code>DFTK.write_w90_win</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Write a win file at the indicated prefix. Parameters to Wannier90 can be added as kwargs: e.g. <code>num_iter=500</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/external/wannier90.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T" href="#DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer, Integer, AbstractVector{T}}} where T"><code>DFTK.ylm_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the (l,m) real spherical harmonic Y<em>lm(r). Consistent with https://en.wikipedia.org/wiki/Table</em>of<em>spherical</em>harmonics#Real<em>spherical</em>harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/spherical_harmonics.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.zeros_like" href="#DFTK.zeros_like"><code>DFTK.zeros_like</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create an array of same &quot;array type&quot; as X filled with zeros, minimizing the number of allocations. This unifies CPU and GPU code, as the output will always be on the same device as the input.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/zeros_like.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.@timing-Tuple" href="#DFTK.@timing-Tuple"><code>DFTK.@timing</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Shortened version of the <code>@timeit</code> macro from <code>TimerOutputs</code>, which writes to the DFTK timer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/common/timer.jl#L13-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.A-Tuple{Any, Any}" href="#DFTK.Smearing.A-Tuple{Any, Any}"><code>DFTK.Smearing.A</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>A</code> term in the Hermite delta expansion</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L113-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.H-Tuple{Any, Any}" href="#DFTK.Smearing.H-Tuple{Any, Any}"><code>DFTK.Smearing.H</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Standard Hermite function using physicist&#39;s convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L118-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Entropy. Note that this is a function of the energy <code>x</code>, not of <code>occupation(x)</code>. This function satisfies s&#39; = x f&#39; (see https://www.vasp.at/vasp-workshop/k-points.pdf p. 12 and https://arxiv.org/pdf/1805.07144.pdf p. 18.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation" href="#DFTK.Smearing.occupation"><code>DFTK.Smearing.occupation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">occupation(S::SmearingFunction, x)</code></pre><p>Occupation at <code>x</code>, where in practice <code>x = (ε - εF) / temperature</code>. If temperature is zero, <code>(ε-εF)/temperature  = ±∞</code>. The occupation function is required to give 1 and 0 respectively in these cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}" href="#DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction, Any}"><code>DFTK.Smearing.occupation_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Derivative of the occupation function, approximation to minus the delta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Any, Any, Any, Any}" href="#DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction, Any, Any, Any, Any}"><code>DFTK.Smearing.occupation_divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(f(x) - f(y))/(x - y), computed stably in the case where x and y are close</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl.git/blob/b47e029fff7fdf45eab81ed7af6d0bcb1dcf8556/src/Smearing.jl#L31-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer/gpu_computations/">« GPU computations</a><a class="docs-footer-nextpage" href="../publications/">Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 6 February 2023 20:48">Monday 6 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
