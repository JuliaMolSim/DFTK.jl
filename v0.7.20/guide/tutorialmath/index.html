<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mathematical Tutorial · DFTK.jl</title><meta name="title" content="Mathematical Tutorial · DFTK.jl"/><meta property="og:title" content="Mathematical Tutorial · DFTK.jl"/><meta property="twitter:title" content="Mathematical Tutorial · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/guide/tutorialmath/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/guide/tutorialmath/"/><link rel="canonical" href="https://docs.dftk.org/stable/guide/tutorialmath/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../tutorial/">General Tutorial</a></li><li class="is-active"><a class="tocitem" href>Mathematical Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Density-functional-theory-models"><span>Density-functional theory models</span></a></li><li><a class="tocitem" href="#Discretization-and-techniques"><span>Discretization and techniques</span></a></li><li><a class="tocitem" href="#A-first-computation"><span>A first computation</span></a></li><li><a class="tocitem" href="#Inspecting-the-results"><span>Inspecting the results</span></a></li><li><a class="tocitem" href="#Post-processing-quantities"><span>Post-processing quantities</span></a></li></ul></li><li><a class="tocitem" href="../introductory_resources/">Introductory resources</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li><li><a class="tocitem" href="../../examples/hubbard/">Hubbard correction (DFT+U)</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/elastic_constants/">Elastic constants</a></li><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../../examples/phonons/">Phonon computations</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../ecosystem/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../ecosystem/atomscalculators/">AtomsCalculators integration</a></li><li><a class="tocitem" href="../../ecosystem/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../ecosystem/atomistic_simulation_environment/">Atomistic simulation environment (ASE)</a></li><li><a class="tocitem" href="../../ecosystem/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li><a class="tocitem" href="../../tricks/achieving_convergence/">Achieving DFT convergence</a></li><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/gpu/">Using DFTK on GPUs</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li><li><a class="tocitem" href="../../tricks/compute_clusters/">Using DFTK on compute clusters</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li><li><a class="tocitem" href="../../examples/analysing_scf_convergence/">Analysing SCF convergence</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Theoretical Background</span><ul><li><a class="tocitem" href="../periodic_problems/">Periodic problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../discretisation/">Comparing discretization techniques</a></li><li><a class="tocitem" href="../atomic_chains/">Modelling atomic chains</a></li><li><a class="tocitem" href="../density_functional_theory/">Introduction to density-functional theory</a></li><li><a class="tocitem" href="../self_consistent_field/">Self-consistent field methods</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../../developer/setup/">Developer setup</a></li><li><a class="tocitem" href="../../developer/testsystem/">Unit test system</a></li><li><a class="tocitem" href="../../developer/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../../developer/style_guide/">Developer&#39;s style guide</a></li><li><a class="tocitem" href="../../developer/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../developer/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../../developer/symmetries/">Crystal symmetries</a></li><li><a class="tocitem" href="../../developer/gpu_computations/">GPU computations</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Mathematical Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mathematical Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/guide/tutorialmath.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mathematical-Tutorial"><a class="docs-heading-anchor" href="#Mathematical-Tutorial">Mathematical Tutorial</a><a id="Mathematical-Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Tutorial" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/JuliaMolSim/DFTK.jl/gh-pages?filepath=v0.7.20/guide/tutorialmath.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/JuliaMolSim/DFTK.jl/blob/gh-pages/v0.7.20/guide/tutorialmath.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>This document provides an overview of the structure of DFTK and how to access basic information about calculations. Unlike the <a href="../tutorial/#Tutorial">General tutorial</a> this document is intended for a mathematical readership, which is not necessarily familiar with materials modelling or plane-wave density-functional theory.</p><h2 id="Density-functional-theory-models"><a class="docs-heading-anchor" href="#Density-functional-theory-models">Density-functional theory models</a><a id="Density-functional-theory-models-1"></a><a class="docs-heading-anchor-permalink" href="#Density-functional-theory-models" title="Permalink"></a></h2><p>The goal of electronic structure theory is to obtain a quantum-mechanical description of electrons in a material, which is important to accurately predict important physical or chemical properties. Exact electronic structure models are in practice prohibitively expensive, see <a href="../density_functional_theory/#Introduction-to-density-functional-theory">Introduction to density-functional theory</a> for details. The most widely employed <em>approximate</em> electronic-structure model is <strong>Kohn-Sham density-functional theory</strong>, which is the focus in this tutorial.</p><p>Mathematically, Kohn-Sham DFT is described by an energy minimisation problem, in which the unknowns are functions <span>$\mathbb{R}^3 → \mathbb{C}$</span>, called <strong>orbitals</strong> <span>$ψ_{kn}$</span> as well as for each orbital an associated occupation value <span>$f_{kn}$</span>, a scalar. These collectively make up the so-called density matrix, which describes the many-body quantum state of the electrons of the material. For details on this energy minimisation problem and its connection to the exact theory, see <a href="../density_functional_theory/#Introduction-to-density-functional-theory">Introduction to density-functional theory</a>.</p><p>While approaches to directly solve above energy minimisation problem exist, the common approach is to directly satisfy the corresponding first-order optimality conditions, also called the <strong>self-consistent field equations</strong>. These read</p><p class="math-container">\[\tag{1}
\left\{
\begin{aligned}
&amp;\left( \frac12 (-i∇ + k)^2 + V\left(\rho\right) \right) ψ_{kn}
  = ε_{kn} ψ_{kn}, \qquad \text{for } 1 ≤ n ≤ N, k ∈ \Omega^∗ ⊂ \mathbb{R}^3 \\
V(ρ) = &amp;\, V_\text{nuc} + V_\text{H}(ρ) + V_\text{XC}(ρ), \\
ρ(r) = &amp; \frac{1}{|\Omega|}  ∫_{\Omega^∗} ∑_{n=1}^N f\left(\frac{ε_{kn} - ε_F}{T}\right) \,  \abs{ψ_{kn}(r)}^2 \, d k, \\
N_\text{el} &amp;= ∫_{\Omega} ρ(r) \, dr.
\end{aligned}
\right.\]</p><p>where the unknowns are for each <span>$k ∈ \Omega^∗$</span> the <strong>eigenvalues</strong> <span>$ε_{k1} ≤ ε_{k2} ≤ ⋯ ≤ ε_{kN}$</span> (each real numbers), the <strong>orbitals</strong> (eigenfunctions) <span>$ψ_{kn} ∈ H^1(\Omega)$</span> as well as the <strong>Fermi level</strong> <span>$ε_F ∈ \mathbb{R}$</span>. This is an eigenvector-dependent non-linear eigenvalue problem of the operators (<span>$k ∈ \Omega^∗$</span>)</p><p class="math-container">\[H_k = \frac12 (-i∇ + k)^2 + V\left(\rho\right),\]</p><p>which has as its principle parameters the functional form of the <strong>potential</strong> <span>$V$</span>, respectively its terms <span>$V_\text{nuc}$</span>, <span>$V_\text{H}(ρ)$</span> and <span>$V_\text{XC}$</span>, the value for the <strong>number of electrons</strong> <span>$N_\text{el} ∈ \mathbb{N}$</span> as well as the <strong>smearing temperature</strong> <span>$T$</span>. Physically, the first term of <span>$H_k$</span>, i.e.  <span>$\frac12 (-i∇ + k)^2$</span> is the <strong>kinetic operator</strong>, which arises from a quantum-mechanical treatment of the classical kinetic energy of the electrons. In turn the terms of <span>$V$</span> arise from the interaction of the electrons with themselves as well as the nuclei:</p><ul><li>the <strong>nuclear attraction potential</strong> <span>$V_\text{nuc}$</span> describes the interaction of electrons and nuclei,</li><li>the <strong>Hartree potential</strong> <span>$V_\text{H}(ρ)$</span> provides the classical interaction of the electrons and is obtained as the unique zero-mean solution to the periodic Poisson equation<p class="math-container">\[-\Delta \left(V_\text{H}(ρ)\right)(r)
= 4\pi \left(\rho(r) - \frac{1}{|\Omega|} \int_\Omega \rho \right).\]</p></li><li>the <strong>exchange-correlation potential</strong> <span>$V_\text{xc}$</span> provides the quantum-mechanical part of the electron-electron interaction and depends on <span>$ρ$</span> as well as potentially its derivatives.</li></ul><p>It can be shown that for the usual potentials (Coulomb or more regular) that <span>$H_k$</span> is self-adjoint with compact support, meaning that its spectrum is entirely discrete and its eigenfunctions countable.</p><p>In principle the sum over <span>$n$</span> in the expression for the <strong>electron density</strong> <span>$ρ$</span> in (1) needs to be infinite, meaning that we need to know in theory the entire spectrum of all <span>$H_k$</span> in order to compute <span>$ρ$</span>. However, since the <strong>occupation function</strong> <span>$f$</span> decays to zero as its argument gets larger, there exists a finite value <span>$N$</span> at which we obtain the electron density <span>$ρ$</span> to very good approximation. Numerical routines in DFTK determine this value of <span>$N$</span> adaptively ensuring that <span>$N$</span> is taken sufficiently large.</p><p>The set <span>$\Omega ⊂ \mathbb{R}^3$</span> is the <strong>unit cell</strong> of the problem, that is the periodically repeating unit with respect to which the material as well as the potential <span>$V$</span> are periodic. More precisely. Let <span>$a_1, a_2, a_3 ∈ \mathbb{R}^3$</span> linearly independent. Then <span>$\mathbb{L} = a_1 \mathbb{Z} + a_2 \mathbb{Z} + a_3 \mathbb{Z}$</span> is the <strong>lattice</strong> of this problem, providing the set of all vectors <span>$R∈\mathbb{L}$</span> such that <span>$V(r+R) = V(r)$</span>. The unit cell is the open set of all points which are closer to the origin than to any other point of <span>$\mathbb{L}$</span>. Associated to <span>$\mathbb{L}$</span> is the <strong>reciprocal lattice</strong> <span>$\mathbb{L}^∗ = b_1 \mathbb{Z} + b_2 \mathbb{Z} + b_3 \mathbb{Z}$</span> with <span>$a_i ⋅ b_j = 2π δ_{ij}$</span>. Its unit cell is the domain <span>$\Omega^∗ ⊂ \mathbb{R}^3$</span>, the <strong>first Brillouin zone</strong>. All <span>$k$</span>-points are taken from <span>$\Omega^∗$</span>. For more intuition about periodic problems, see <a href="../periodic_problems/#periodic-problems">Periodic problems and plane-wave discretisations</a>.</p><h2 id="Discretization-and-techniques"><a class="docs-heading-anchor" href="#Discretization-and-techniques">Discretization and techniques</a><a id="Discretization-and-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization-and-techniques" title="Permalink"></a></h2><p>The usual discretisation strategy for solving the self-consistent field equations (1) consists of two aspects:</p><ul><li>Discretization of the integrals over <span>$\Omega^∗$</span> (e.g. in the computation of <span>$ρ$</span>). For this one usually employs a trapezoidal rule with an equispaced integration grid. This selected regular subset of points from <span>$\Omega^∗$</span> is called the <strong><span>$k$</span>-points</strong> –- also called a Monkhorst-Pack grid. Typically one refers to a grid of <span>$n_x, n_y$</span> and <span>$n_z$</span> points in <span>$x$</span>, <span>$y$</span> and <span>$z$</span> direction of <span>$\Omega^∗$</span> as an <span>$(n_x, n_y, n_z)$</span> Monkhorst-Pack grid.</li><li>Discretization of the orbitals. For this many choices are possible. In DFTK we employ plane waves, i.e. basis sets of the form<p class="math-container">\[\left\{ e_G \, \middle| \, G ∈ \mathbb{L}^∗, \frac12 |G+k|^2 ≤ E_\text{cut} \right\}\]</p>where the plane-waves are functions <span>$\mathbb{R}^3 → \mathbb{C}$</span> of the form<p class="math-container">\[e_G(r) = \frac{1}{\sqrt{|\Omega|}} e^{2π\, G⋅r}.\]</p>Crucially the size of the basis is controlled by the <strong>plane-wave cutoff</strong> <code>Ecut</code>.</li></ul><p>More intuition about the role of <span>$k$</span>-points provides <a href="../periodic_problems/#periodic-problems">Periodic problems and plane-wave discretisations</a> and <a href="../atomic_chains/#Modelling-atomic-chains">Modelling atomic chains</a>. Some comparison of plane-wave discretisation techniques in contrast to finite difference methods is provided in <a href="../discretisation/#Comparing-discretization-techniques">Comparing discretization techniques</a>.</p><h2 id="A-first-computation"><a class="docs-heading-anchor" href="#A-first-computation">A first computation</a><a id="A-first-computation-1"></a><a class="docs-heading-anchor-permalink" href="#A-first-computation" title="Permalink"></a></h2><p>Summarising the above discussion we collect the <strong>input parameters of a DFT calculation</strong> and show how to provide them to DFTK. We will use the classic example of computing the LDA ground state of the <a href="https://www.materialsproject.org/materials/mp-149">silicon crystal</a>.</p><pre><code class="language-julia hljs">using DFTK
using Unitful
using UnitfulAtomic
using PseudoPotentialData
using Plots</code></pre><p><strong>Step 1:</strong> Define the lattice vectors <span>$a_1$</span>, <span>$a_2$</span>, <span>$a_3$</span> as columns of a matrix. Note that DFTK permits using unit annotations using the <a href="https://juliaphysics.github.io/Unitful.jl/stable/">Unitful package</a> and the <a href="https://github.com/sostock/UnitfulAtomic.jl">UnitfulAtomic package</a> in most input parameters.</p><pre><code class="language-julia hljs">a = 5.431u&quot;angstrom&quot;          # Silicon lattice constant
lattice = a / 2 * [[0 1 1.];  # Silicon lattice vectors
                   [1 0 1.];  # specified column by column
                   [1 1 0.]];</code></pre><p>This defines <span>$\mathbb{L}$</span> and <span>$\mathbb{L}^∗$</span> and as a result the unit cell <span>$\Omega$</span> and Brillouin zone <span>$\Omega^∗$</span>.</p><p>Next we specify the location of the nuclei and their chemical elements. Additionally we attach a pseudopotential from <a href="https://github.com/JuliaMolSim/PseudoPotentialData.jl">PseudoPotentialData</a>, which defines <span>$V_\text{ext}$</span>, i.e. the model used for the interactions of nuclei and electrons (see <a href="../../examples/pseudopotentials/#Pseudopotentials">Pseudopotentials</a> for more details).</p><pre><code class="language-julia hljs">pd_lda_family = PseudoFamily(&quot;dojo.nc.sr.lda.v0_4_1.standard.upf&quot;)
Si = ElementPsp(:Si, pd_lda_family)

# Specify type and positions of atoms
atoms     = [Si, Si]
positions = [ones(3)/8, -ones(3)/8]</code></pre><p><strong>Step 1a:</strong> Note that DFTK supports a few other ways to supply atomistic structures, see for example the sections on <a href="../../ecosystem/atomsbase/#AtomsBase-integration">AtomsBase integration</a> and <a href="../../ecosystem/input_output/#Input-and-output-formats">Input and output formats</a> for details.</p><p><strong>Step 2:</strong> Define the DFT model, that is the functional form of <span>$V_\text{xc}$</span> This is indicated below by <code>functionals=LDA()</code>, which defines an LDA (local density approximation) model. Notice, that <span>$V_H(ρ)$</span> is used by all DFT models in the potential <span>$V$</span>, so it is not explicitly mentioned in the code below.</p><p>The additional keyword arguments <code>temperature</code> and <code>smearing</code> define the value for the smearing temperate <span>$T$</span> to <code>1e-3</code> as well as the functional form of the <strong>occupation function</strong> <span>$f$</span>, which is often also called <strong>smearing function</strong>. Here we employ <a href="../../api/#DFTK.Smearing.Gaussian"><code>Smearing.Gaussian</code></a>.</p><pre><code class="language-julia hljs">model = model_DFT(lattice, atoms, positions; functionals=LDA(),
                  temperature=1e-3, smearing=Smearing.Gaussian())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Model(lda_x+lda_c_pw, 3D):
    lattice (in Bohr)    : [0         , 5.13155   , 5.13155   ]
                           [5.13155   , 0         , 5.13155   ]
                           [5.13155   , 5.13155   , 0         ]
    unit cell volume     : 270.26 Bohr³

    atoms                : Si₂
    pseudopot. family    : PseudoFamily(&quot;dojo.nc.sr.lda.v0_4_1.standard.upf&quot;)

    num. electrons       : 8
    spin polarization    : none
    temperature          : 0.001 Ha
    smearing             : DFTK.Smearing.Gaussian()

    terms                : Kinetic()
                           AtomicLocal()
                           AtomicNonlocal()
                           Ewald(nothing)
                           PspCorrection()
                           Hartree()
                           Xc(lda_x, lda_c_pw)
                           Entropy()</code></pre><p>Note, that for silicon (an insulator) we can actually avoid using a smearing temperature and equally define the model as <code>model_DFT(lattice, atoms, positions; functionals=LDA())</code>.</p><p><strong>Step 3:</strong> Discretize the problem.</p><pre><code class="language-julia hljs">kgrid = KgridSpacing(0.3 / u&quot;bohr&quot;)  # Regular k-point grid (Monkhorst-Pack grid)
#                                      with spacing 0.3/bohr between k-points
# kgrid = [4, 4, 4]                    Alternative: Number of k-points per dimension
Ecut = 7              # kinetic energy cutoff
# Ecut = 190.5u&quot;eV&quot;  # Could also use eV or other energy-compatible units

basis = PlaneWaveBasis(model; Ecut, kgrid)
# Note the implicit passing of keyword arguments here:
# this is equivalent to PlaneWaveBasis(model; Ecut=Ecut, kgrid=kgrid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PlaneWaveBasis discretization:
    architecture         : DFTK.CPU()
    num. mpi processes   : 1
    num. julia threads   : 1
    num. DFTK  threads   : 1
    num. blas  threads   : 2
    num. fft   threads   : 1

    Ecut                 : 7.0 Ha
    fft_size             : (20, 20, 20), 8000 total points
    kgrid                : MonkhorstPack([4, 4, 4])
    num.   red. kpoints  : 64
    num. irred. kpoints  : 8

    Estimated memory usage (per MPI process):
        nonlocal projectors  :   1.14MiB
        single ψ             :    259KiB
        single ρ             :   62.5KiB
        peak memory (SCF)    :   2.57MiB
    
    Discretized Model(lda_x+lda_c_pw, 3D):
        lattice (in Bohr)    : [0         , 5.13155   , 5.13155   ]
                               [5.13155   , 0         , 5.13155   ]
                               [5.13155   , 5.13155   , 0         ]
        unit cell volume     : 270.26 Bohr³
    
        atoms                : Si₂
        pseudopot. family    : PseudoFamily(&quot;dojo.nc.sr.lda.v0_4_1.standard.upf&quot;)
    
        num. electrons       : 8
        spin polarization    : none
        temperature          : 0.001 Ha
        smearing             : DFTK.Smearing.Gaussian()
    
        terms                : Kinetic()
                               AtomicLocal()
                               AtomicNonlocal()
                               Ewald(nothing)
                               PspCorrection()
                               Hartree()
                               Xc(lda_x, lda_c_pw)
                               Entropy()</code></pre><div class="admonition is-info"><header class="admonition-header">Convergence parameters in the documentation</header><div class="admonition-body"><p>We use rough parameters in order to be able to automatically generate this documentation very quickly. Therefore results are far from converged. Tighter thresholds and larger grids should be used for more realistic results.</p></div></div><p><strong>Step 4:</strong> Run the SCF procedure to obtain the ground state. This triggers an iterative procedure solving the fixed-point problem encoded in the SCF equations (1), see <a href="../self_consistent_field/#Self-consistent-field-methods">Self-consistent field methods</a> and the <a href="../../api/#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT, Arch, FFTtype} where {VT&lt;:Real, Arch&lt;:DFTK.AbstractArchitecture, FFTtype&lt;:(FFTGrid{T, VT, T_G_vectors, T_r_vectors} where {T_G_vectors&lt;:AbstractArray{StaticArraysCore.SVector{3, Int64}, 3}, T_r_vectors&lt;:AbstractArray{StaticArraysCore.SVector{3, VT}, 3}})}}, Tuple{T}} where T"><code>self_consistent_field</code></a> function documentation for more details:</p><pre><code class="language-julia hljs">scfres = self_consistent_field(basis, tol=1e-5);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">n     Energy            log10(ΔE)   log10(Δρ)   Diag   Δtime
---   ---------------   ---------   ---------   ----   ------
  1   -8.505123159068                   -0.93    5.1   49.4ms
  2   -8.508289061299       -2.50       -1.64    1.0   34.9ms
  3   -8.508455796931       -3.78       -2.69    1.6   38.3ms
  4   -8.508482909145       -4.57       -3.10    2.6   44.1ms
  5   -8.508483186295       -6.56       -3.65    1.2   35.0ms
  6   -8.508483225619       -7.41       -4.53    1.8   38.0ms
  7   -8.508483227604       -8.70       -5.31    2.2   41.1ms</code></pre><p>This is it, in the next sections we will discuss how to inspect the results more closely.</p><h2 id="Inspecting-the-results"><a class="docs-heading-anchor" href="#Inspecting-the-results">Inspecting the results</a><a id="Inspecting-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-the-results" title="Permalink"></a></h2><p>The <strong>key outputs</strong> of solving the DFT problem are:</p><ul><li>The orbitals <span>$ψ_{kn}$</span> and eigenvalues <span>$ε_{kn}$</span></li><li>The occupations <span>$f_{kn} = f(ε_{kn})$</span></li><li>The electron density <span>$ρ$</span></li></ul><p>from these quantities other quantities of interest are frequently computed.</p><p>For example, the eigenvalues are obtained as an array indexed as <code>eigenvalues[ik][n]</code> where <code>ik</code> is an index running over all <span>$k$</span>-points.</p><pre><code class="language-julia hljs">length(scfres.eigenvalues)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><pre><code class="language-julia hljs">length(scfres.eigenvalues[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8</code></pre><pre><code class="language-julia hljs">stack(scfres.eigenvalues)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 Matrix{Float64}:
 -0.264799  -0.235353  -0.179075   …  -0.18931    -0.112073   -0.106307
  0.174323   0.029531  -0.0825377     -0.0265562  -0.112073   -0.106307
  0.174323   0.146147   0.129857       0.0347389   0.0686548   0.0309533
  0.174323   0.146147   0.129857       0.12521     0.0686548   0.0309533
  0.267151   0.247826   0.229556       0.263041    0.198144    0.329876
  0.267151   0.302404   0.297036   …   0.349551    0.198144    0.329876
  0.267151   0.302404   0.297036       0.362143    0.542253    0.356807
  0.293259   0.423891   0.450572       0.397261    0.542751    0.356807</code></pre><p>The resulting matrix is 8 (number of computed eigenvalues) by 8 (number of irreducible k-points). There are 8 eigenvalues per k-point because there are 4 occupied states in the system (4 valence electrons per silicon atom, two atoms per unit cell, and paired spins), and the eigensolver gives itself some breathing room by computing some extra states (see the <code>bands</code> argument to <a href="../../api/#DFTK.self_consistent_field-Union{Tuple{PlaneWaveBasis{T, VT, Arch, FFTtype} where {VT&lt;:Real, Arch&lt;:DFTK.AbstractArchitecture, FFTtype&lt;:(FFTGrid{T, VT, T_G_vectors, T_r_vectors} where {T_G_vectors&lt;:AbstractArray{StaticArraysCore.SVector{3, Int64}, 3}, T_r_vectors&lt;:AbstractArray{StaticArraysCore.SVector{3, VT}, 3}})}}, Tuple{T}} where T"><code>self_consistent_field</code></a> as well as the <a href="../../api/#DFTK.AdaptiveBands"><code>AdaptiveBands</code></a> documentation). There are only 8 k-points (instead of 4x4x4) because symmetry has been used to reduce the amount of computations to just the irreducible k-points (see <a href="../../developer/symmetries/#Crystal-symmetries">Crystal symmetries</a> for details).</p><p>We check the occupations ...</p><pre><code class="language-julia hljs">stack(scfres.occupation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8×8 Matrix{Float64}:
 2.0  2.0  2.0  2.0          2.0  2.0  2.0          2.0
 2.0  2.0  2.0  2.0          2.0  2.0  2.0          2.0
 2.0  2.0  2.0  2.0          2.0  2.0  2.0          2.0
 2.0  2.0  2.0  2.0          2.0  2.0  2.0          2.0
 0.0  0.0  0.0  4.3814e-320  0.0  0.0  1.15505e-63  0.0
 0.0  0.0  0.0  0.0          0.0  0.0  1.15505e-63  0.0
 0.0  0.0  0.0  0.0          0.0  0.0  0.0          0.0
 0.0  0.0  0.0  0.0          0.0  0.0  0.0          0.0</code></pre><p>... and density, where we use that the density objects in DFTK are indexed as ρ[ix, iy, iz, iσ], i.e. first in the 3-dimensional real-space grid and then in the spin component.</p><pre><code class="language-julia hljs">rvecs = collect(r_vectors(basis))[:, 1, 1]  # slice along the x axis
x = [r[1] for r in rvecs]                   # only keep the x coordinate
plot(x, scfres.ρ[:, 1, 1, 1], label=&quot;&quot;, xlabel=&quot;x&quot;, ylabel=&quot;ρ&quot;, marker=2)</code></pre><img src="70a2ea23.svg" alt="Example block output"/><p>For each term of the Hamiltonian <span>$H$</span>, respectively the potential <span>$V$</span> there are also individual contributions to the total energy, which is minimised. These components we can also inspect:</p><pre><code class="language-julia hljs">scfres.energies</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Energy breakdown (in Ha):
    Kinetic             3.0841995 
    AtomicLocal         -2.3554933
    AtomicNonlocal      1.3116722 
    Ewald               -8.3979253
    PspCorrection       0.3948680 
    Hartree             0.5559233 
    Xc                  -3.1017277
    Entropy             -0.0000000

    total               -8.508483227604</code></pre><h2 id="Post-processing-quantities"><a class="docs-heading-anchor" href="#Post-processing-quantities">Post-processing quantities</a><a id="Post-processing-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing-quantities" title="Permalink"></a></h2><p>Further important post-processing quantities, such as the density of states (<a href="../../api/#DFTK.plot_dos"><code>plot_dos</code></a>), the computation of band structures (<a href="../../api/#DFTK.compute_bands-Tuple{Any, Brillouin.KPaths.KPath}"><code>compute_bands</code></a>) or the computation of response properties such as <a href="../../examples/elastic_constants/#Elastic-constants">Elastic constants</a> are also readily available in DFTK. See also the end of the <a href="../tutorial/#Tutorial">General Tutorial</a> for some examples as well as a list of pointers where to go from here.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« General Tutorial</a><a class="docs-footer-nextpage" href="../introductory_resources/">Introductory resources »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 19 December 2025 17:06">Friday 19 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
