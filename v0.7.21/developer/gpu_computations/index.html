<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU computations · DFTK.jl</title><meta name="title" content="GPU computations · DFTK.jl"/><meta property="og:title" content="GPU computations · DFTK.jl"/><meta property="twitter:title" content="GPU computations · DFTK.jl"/><meta name="description" content="Documentation for DFTK.jl."/><meta property="og:description" content="Documentation for DFTK.jl."/><meta property="twitter:description" content="Documentation for DFTK.jl."/><meta property="og:url" content="https://docs.dftk.org/stable/developer/gpu_computations/"/><meta property="twitter:url" content="https://docs.dftk.org/stable/developer/gpu_computations/"/><link rel="canonical" href="https://docs.dftk.org/stable/developer/gpu_computations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DFTK.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../features/">DFTK features</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/installation/">Installation</a></li><li><a class="tocitem" href="../../guide/tutorial/">General Tutorial</a></li><li><a class="tocitem" href="../../guide/tutorialmath/">Mathematical Tutorial</a></li><li><a class="tocitem" href="../../guide/introductory_resources/">Introductory resources</a></li></ul></li><li><span class="tocitem">Basic DFT calculations</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/convergence_study/">Performing a convergence study</a></li><li><a class="tocitem" href="../../examples/pseudopotentials/">Pseudopotentials</a></li><li><a class="tocitem" href="../../examples/supercells/">Creating and modelling metallic supercells</a></li><li><a class="tocitem" href="../../examples/gaas_surface/">Modelling a gallium arsenide surface</a></li><li><a class="tocitem" href="../../examples/graphene/">Graphene band structure</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/energy_cutoff_smearing/">Energy cutoff smearing</a></li><li><a class="tocitem" href="../../examples/hubbard/">Hubbard correction (DFT+U)</a></li></ul></li><li><span class="tocitem">Response and properties</span><ul><li><a class="tocitem" href="../../examples/elastic_constants/">Elastic constants</a></li><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/forwarddiff/">Polarizability using automatic differentiation</a></li><li><a class="tocitem" href="../../examples/phonons/">Phonon computations</a></li></ul></li><li><span class="tocitem">Ecosystem integration</span><ul><li><a class="tocitem" href="../../ecosystem/atomsbase/">AtomsBase integration</a></li><li><a class="tocitem" href="../../ecosystem/atomscalculators/">AtomsCalculators integration</a></li><li><a class="tocitem" href="../../ecosystem/input_output/">Input and output formats</a></li><li><a class="tocitem" href="../../ecosystem/atomistic_simulation_environment/">Atomistic simulation environment (ASE)</a></li><li><a class="tocitem" href="../../ecosystem/wannier/">Wannierization using Wannier.jl or Wannier90</a></li></ul></li><li><span class="tocitem">Tips and tricks</span><ul><li><a class="tocitem" href="../../tricks/achieving_convergence/">Achieving DFT convergence</a></li><li><a class="tocitem" href="../../tricks/parallelization/">Timings and parallelization</a></li><li><a class="tocitem" href="../../tricks/gpu/">Using DFTK on GPUs</a></li><li><a class="tocitem" href="../../tricks/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li><li><a class="tocitem" href="../../tricks/compute_clusters/">Using DFTK on compute clusters</a></li></ul></li><li><span class="tocitem">Solvers</span><ul><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/compare_solvers/">Comparison of DFT solvers</a></li><li><a class="tocitem" href="../../examples/analysing_scf_convergence/">Analysing SCF convergence</a></li></ul></li><li><span class="tocitem">Nonstandard models</span><ul><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with external magnetic field</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/anyons/">Anyonic models</a></li></ul></li><li><span class="tocitem">Error control</span><ul><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/error_estimates_forces/">Practical error bounds for the forces</a></li></ul></li><li><span class="tocitem">Theoretical Background</span><ul><li><a class="tocitem" href="../../guide/periodic_problems/">Periodic problems and plane-wave discretisations</a></li><li><a class="tocitem" href="../../guide/discretisation/">Comparing discretization techniques</a></li><li><a class="tocitem" href="../../guide/atomic_chains/">Modelling atomic chains</a></li><li><a class="tocitem" href="../../guide/density_functional_theory/">Introduction to density-functional theory</a></li><li><a class="tocitem" href="../../guide/self_consistent_field/">Self-consistent field methods</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../setup/">Developer setup</a></li><li><a class="tocitem" href="../testsystem/">Unit test system</a></li><li><a class="tocitem" href="../conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../style_guide/">Developer&#39;s style guide</a></li><li><a class="tocitem" href="../data_structures/">Data structures</a></li><li><a class="tocitem" href="../useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../symmetries/">Crystal symmetries</a></li><li class="is-active"><a class="tocitem" href>GPU computations</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Pitfalls"><span>Pitfalls</span></a></li><li><a class="tocitem" href="#Known-issues"><span>Known issues</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li class="is-active"><a href>GPU computations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU computations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/developer/gpu_computations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GPU-computations"><a class="docs-heading-anchor" href="#GPU-computations">GPU computations</a><a id="GPU-computations-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-computations" title="Permalink"></a></h1><p>As of December 2025, DFTK porting to GPU is stable. SCF and forces are fully supported for standard Libxc functionals with norm-conserving pseudopotentials. Stress tensor calculations and automatic differentiation on the GPU is work in progress. DFTK can be run on NVIDIA and AMD devices.</p><p>Our approach to GPU computation relies on Julia&#39;s multiple dispatch mechanism, such that the same code base can be used on both CPU and GPU, regardless of the vendor. GPU sepcific code is only written when necessary, but always at a high level. There are no explicit CUDA/HIP kernels in DFTK. This high level approach is made possible by the following packages: <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA</a>, <a href="https://github.com/JuliaGPU/AMDGPU.jl">ROCm</a>, and <a href="https://github.com/JuliaGPU/GPUArrays.jl">GPUArrays</a>.</p><p>GPU acceleration of SCF has been measured to reach ~250x on NVIDIA GH200, and ~50x on AMD MI250.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>GPU computations are done by specializing the <code>architecture</code> keyword argument when creating the <a href="../../api/#DFTK.PlaneWaveBasis"><code>PlaneWaveBasis</code></a>. <code>architecture</code> should be an initialized instance of the (non-exported) <code>CPU</code> and <code>GPU</code> structures. <code>CPU</code> does not require any argument, but <code>GPU</code> requires the type of array which will be used for GPU computations.</p><pre><code class="language-julia hljs">PlaneWaveBasis(model; Ecut, kgrid, architecture = DFTK.CPU())</code></pre><pre><code class="language-julia hljs">using CUDA
PlaneWaveBasis(model; Ecut, kgrid, architecture = DFTK.GPU(CuArray))</code></pre><pre><code class="language-julia hljs">using AMDGPU
PlaneWaveBasis(model; Ecut, kgrid, architecture = DFTK.GPU(ROCArray))</code></pre><h2 id="Pitfalls"><a class="docs-heading-anchor" href="#Pitfalls">Pitfalls</a><a id="Pitfalls-1"></a><a class="docs-heading-anchor-permalink" href="#Pitfalls" title="Permalink"></a></h2><p>There are a few things to keep in mind when doing GPU programming in DFTK.</p><ul><li>Transfers to and from a device can be done simply by converting an array to</li></ul><p>another type. However, hard-coding the new array type (such as writing <code>CuArray(A)</code> to move <code>A</code> to a CUDA GPU) is not cross-architecture, and can be confusing for developers working only on the CPU code. These data transfers should be done using the helper functions <a href="../../api/#DFTK.to_device-Tuple{DFTK.CPU, Any}"><code>DFTK.to_device</code></a> and <a href="../../api/#DFTK.to_cpu-Tuple{AbstractArray}"><code>DFTK.to_cpu</code></a> which provide a level of abstraction while also allowing multiple architectures to be used.</p><pre><code class="language-julia hljs">cuda_gpu = DFTK.GPU(CuArray)
cpu_architecture = DFTK.CPU()
A = rand(10)  # A is on the CPU
B = DFTK.to_device(cuda_gpu, A)  # B is a copy of A on the CUDA GPU
B .+= 1.
C = DFTK.to_cpu(B)  # C is a copy of B on the CPU
D = DFTK.to_device(cpu_architecture, B)  # Equivalent to the previous line, but
                                         # should be avoided as it is less clear</code></pre><p><em>Notes:</em> <code>similar</code> can also be used, but then a reference array (one which already lives on the device) needs to be available at call time. DFTK is mostly GPU resident, and very few explicit data transfers are required in practice. Generally, this is done when an array must be accessed in an element-wise fashion (forbidden on <code>GPUArrays</code>).</p><ul><li>Functions which will get executed on the GPU should always have arguments</li></ul><p>which are <code>isbits</code> (immutable and contains no references to other values). When using <code>map</code>, also make sure that every structure used is also <code>isbits</code>. For example, the following map will fail, as <code>model</code> contains strings and arrays which are not <code>isbits</code>.</p><pre><code class="language-julia hljs">function map_lattice(model::Model, Gs::AbstractArray{Vec3})
    # model is not isbits
    map(Gs) do Gi
        model.lattice * Gi
    end
end</code></pre><p>However, the following map will run on a GPU, as the lattice is a static matrix.</p><pre><code class="language-julia hljs">function map_lattice(model::Model, Gs::AbstractArray{Vec3})
    lattice = model.lattice # lattice is isbits
    map(Gs) do Gi
        lattice * Gi
    end
end</code></pre><ul><li>All performance-critical for loops should be replaced by map or map! calls, since</li></ul><p>the former won&#39;t run on the GPU. In case of nested loops, the outermost one should be a map, such that each GPU thread can execute the inner loop (ideally the smaller one).</p><ul><li>List comprehensions should be avoided, as they always return a CPU <code>Array</code>.</li></ul><p>Instead, we should use <code>map</code> which returns an array of the same type as the input one.</p><ul><li>Sometimes, creating a new array or making a copy can be necessary to achieve good</li></ul><p>performance. For example, iterating through the columns of a matrix to compute their norms is not efficient, as a new kernel is launched for every column. Instead, it is better to build the vector containing these norms, as it is a vectorized operation and will be much faster on the GPU.</p><ul><li>Array broadcasting operations are compiled to GPU kernels. When possible, write</li></ul><p>multiple operations on the same line, such that a single fused kernel is created.  Few large GPU kernels are always more efficient than many small ones.</p><ul><li>Allocation of large GPUArrays can be costly, especially when happening repeatedly</li></ul><p>in a loop. When possible, pre-allocate such arrays and use in place operations (map!, mul!, etc.)</p><ul><li>Some operations are GPU-legal, but extremely slow. These can only be spotted with careful profiling.</li></ul><h2 id="Known-issues"><a class="docs-heading-anchor" href="#Known-issues">Known issues</a><a id="Known-issues-1"></a><a class="docs-heading-anchor-permalink" href="#Known-issues" title="Permalink"></a></h2><ul><li>Some operations on specific GPUArrays types are not properly taken care of with either CUDA</li></ul><p>or AMDGPU. When spotted, workarounds are implemented in the relevent DFTK extensions (<code>DFTKCUDAExt.jl</code>, <code>DFTKAMDGPUExt.jl</code>).</p><ul><li>Diagonalization of complex Hermitian matrices is very slow on AMDGPU. This becomes the main bottleneck of calculations where it should be negligible. Hopefully, this will be fixed with</li></ul><p>ROCm v7.</p><ul><li>In principle, GPU-aware MPI works out of the box. However, depending on the MPI provider, a whole</li></ul><p>host of environment variables might be necessary.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../symmetries/">« Crystal symmetries</a><a class="docs-footer-nextpage" href="../../api/">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 2 February 2026 19:10">Monday 2 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
